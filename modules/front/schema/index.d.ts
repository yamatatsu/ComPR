import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
export type Maybe<T> = T | null;
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type RequireFields<T, K extends keyof T> = { [X in Exclude<keyof T, K>]?: T[X] } & { [P in K]-?: NonNullable<T[P]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** An ISO-8601 encoded date string. */
  Date: any;
  /** An ISO-8601 encoded UTC date string. */
  DateTime: any;
  /** A Git object ID. */
  GitObjectID: any;
  /** A fully qualified reference name (e.g. `refs/heads/master`). */
  GitRefname: any;
  /** Git SSH string */
  GitSSHRemote: any;
  /** An ISO-8601 encoded date string. Unlike the DateTime type, GitTimestamp is not converted in UTC. */
  GitTimestamp: any;
  /** A string containing HTML code. */
  HTML: any;
  /** An ISO-8601 encoded UTC date string with millisecond precison. */
  PreciseDateTime: any;
  /** An RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string. */
  URI: any;
  /** A valid x509 certificate string */
  X509Certificate: any;
};



/** Autogenerated input type of AcceptEnterpriseAdministratorInvitation */
export type GQLAcceptEnterpriseAdministratorInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The id of the invitation being accepted */
  invitationId: Scalars['ID'];
};

/** Autogenerated return type of AcceptEnterpriseAdministratorInvitation */
export type GQLAcceptEnterpriseAdministratorInvitationPayload = {
  __typename?: 'AcceptEnterpriseAdministratorInvitationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The invitation that was accepted. */
  invitation?: Maybe<GQLEnterpriseAdministratorInvitation>;
  /** A message confirming the result of accepting an administrator invitation. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of AcceptTopicSuggestion */
export type GQLAcceptTopicSuggestionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The name of the suggested topic. */
  name: Scalars['String'];
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of AcceptTopicSuggestion */
export type GQLAcceptTopicSuggestionPayload = {
  __typename?: 'AcceptTopicSuggestionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The accepted topic. */
  topic?: Maybe<GQLTopic>;
};

/** The possible capabilities for action executions setting. */
export enum GQLActionExecutionCapabilitySetting {
  /** All action executions are enabled. */
  AllActions = 'ALL_ACTIONS',
  /** All action executions are disabled. */
  Disabled = 'DISABLED',
  /** Only actions defined within the repo are allowed. */
  LocalActionsOnly = 'LOCAL_ACTIONS_ONLY',
  /** Organization administrators action execution capabilities. */
  NoPolicy = 'NO_POLICY'
}

/** Represents an object which can take actions on GitHub. Typically a User or Bot. */
export type GQLActor = {
  /** A URL pointing to the actor's public avatar. */
  avatarUrl: Scalars['URI'];
  /** The username of the actor. */
  login: Scalars['String'];
  /** The HTTP path for this actor. */
  resourcePath: Scalars['URI'];
  /** The HTTP URL for this actor. */
  url: Scalars['URI'];
};


/** Represents an object which can take actions on GitHub. Typically a User or Bot. */
export type GQLActorAvatarUrlArgs = {
  size?: Maybe<Scalars['Int']>;
};

/** Location information for an actor */
export type GQLActorLocation = {
  __typename?: 'ActorLocation';
  /** City */
  city?: Maybe<Scalars['String']>;
  /** Country name */
  country?: Maybe<Scalars['String']>;
  /** Country code */
  countryCode?: Maybe<Scalars['String']>;
  /** Region name */
  region?: Maybe<Scalars['String']>;
  /** Region or state code */
  regionCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of AddAssigneesToAssignable */
export type GQLAddAssigneesToAssignableInput = {
  /** The id of the assignable object to add assignees to. */
  assignableId: Scalars['ID'];
  /** The id of users to add as assignees. */
  assigneeIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of AddAssigneesToAssignable */
export type GQLAddAssigneesToAssignablePayload = {
  __typename?: 'AddAssigneesToAssignablePayload';
  /** The item that was assigned. */
  assignable?: Maybe<GQLAssignable>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of AddComment */
export type GQLAddCommentInput = {
  /** The contents of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'];
};

/** Autogenerated return type of AddComment */
export type GQLAddCommentPayload = {
  __typename?: 'AddCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The edge from the subject's comment connection. */
  commentEdge?: Maybe<GQLIssueCommentEdge>;
  /** The subject */
  subject?: Maybe<GQLNode>;
  /** The edge from the subject's timeline connection. */
  timelineEdge?: Maybe<GQLIssueTimelineItemEdge>;
};

/** Autogenerated input type of AddLabelsToLabelable */
export type GQLAddLabelsToLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ids of the labels to add. */
  labelIds: Array<Scalars['ID']>;
  /** The id of the labelable object to add labels to. */
  labelableId: Scalars['ID'];
};

/** Autogenerated return type of AddLabelsToLabelable */
export type GQLAddLabelsToLabelablePayload = {
  __typename?: 'AddLabelsToLabelablePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The item that was labeled. */
  labelable?: Maybe<GQLLabelable>;
};

/** Autogenerated input type of AddProjectCard */
export type GQLAddProjectCardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The content of the card. Must be a member of the ProjectCardItem union */
  contentId?: Maybe<Scalars['ID']>;
  /** The note on the card. */
  note?: Maybe<Scalars['String']>;
  /** The Node ID of the ProjectColumn. */
  projectColumnId: Scalars['ID'];
};

/** Autogenerated return type of AddProjectCard */
export type GQLAddProjectCardPayload = {
  __typename?: 'AddProjectCardPayload';
  /** The edge from the ProjectColumn's card connection. */
  cardEdge?: Maybe<GQLProjectCardEdge>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ProjectColumn */
  projectColumn?: Maybe<GQLProjectColumn>;
};

/** Autogenerated input type of AddProjectColumn */
export type GQLAddProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The name of the column. */
  name: Scalars['String'];
  /** The Node ID of the project. */
  projectId: Scalars['ID'];
};

/** Autogenerated return type of AddProjectColumn */
export type GQLAddProjectColumnPayload = {
  __typename?: 'AddProjectColumnPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The edge from the project's column connection. */
  columnEdge?: Maybe<GQLProjectColumnEdge>;
  /** The project */
  project?: Maybe<GQLProject>;
};

/** Autogenerated input type of AddPullRequestReviewComment */
export type GQLAddPullRequestReviewCommentInput = {
  /** The text of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The SHA of the commit to comment on. */
  commitOID?: Maybe<Scalars['GitObjectID']>;
  /** The comment id to reply to. */
  inReplyTo?: Maybe<Scalars['ID']>;
  /** The relative path of the file to comment on. */
  path?: Maybe<Scalars['String']>;
  /** The line index in the diff to comment on. */
  position?: Maybe<Scalars['Int']>;
  /** The node ID of the pull request reviewing */
  pullRequestId?: Maybe<Scalars['ID']>;
  /** The Node ID of the review to modify. */
  pullRequestReviewId?: Maybe<Scalars['ID']>;
};

/** Autogenerated return type of AddPullRequestReviewComment */
export type GQLAddPullRequestReviewCommentPayload = {
  __typename?: 'AddPullRequestReviewCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created comment. */
  comment?: Maybe<GQLPullRequestReviewComment>;
  /** The edge from the review's comment connection. */
  commentEdge?: Maybe<GQLPullRequestReviewCommentEdge>;
};

/** Autogenerated input type of AddPullRequestReview */
export type GQLAddPullRequestReviewInput = {
  /** The contents of the review body comment. */
  body?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The review line comments. */
  comments?: Maybe<Array<Maybe<GQLDraftPullRequestReviewComment>>>;
  /** The commit OID the review pertains to. */
  commitOID?: Maybe<Scalars['GitObjectID']>;
  /** The event to perform on the pull request review. */
  event?: Maybe<GQLPullRequestReviewEvent>;
  /** The Node ID of the pull request to modify. */
  pullRequestId: Scalars['ID'];
  /** The review line comment threads. */
  threads?: Maybe<Array<Maybe<GQLDraftPullRequestReviewThread>>>;
};

/** Autogenerated return type of AddPullRequestReview */
export type GQLAddPullRequestReviewPayload = {
  __typename?: 'AddPullRequestReviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created pull request review. */
  pullRequestReview?: Maybe<GQLPullRequestReview>;
  /** The edge from the pull request's review connection. */
  reviewEdge?: Maybe<GQLPullRequestReviewEdge>;
};

/** Autogenerated input type of AddPullRequestReviewThread */
export type GQLAddPullRequestReviewThreadInput = {
  /** Body of the thread's first comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The line of the blob to which the thread refers. The end of the line range for multi-line comments. */
  line: Scalars['Int'];
  /** Path to the file being commented on. */
  path: Scalars['String'];
  /** The Node ID of the review to modify. */
  pullRequestReviewId: Scalars['ID'];
  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */
  side?: Maybe<GQLDiffSide>;
  /** The first line of the range to which the comment refers. */
  startLine?: Maybe<Scalars['Int']>;
  /** The side of the diff on which the start line resides. */
  startSide?: Maybe<GQLDiffSide>;
};

/** Autogenerated return type of AddPullRequestReviewThread */
export type GQLAddPullRequestReviewThreadPayload = {
  __typename?: 'AddPullRequestReviewThreadPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created thread. */
  thread?: Maybe<GQLPullRequestReviewThread>;
};

/** Autogenerated input type of AddReaction */
export type GQLAddReactionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The name of the emoji to react with. */
  content: GQLReactionContent;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'];
};

/** Autogenerated return type of AddReaction */
export type GQLAddReactionPayload = {
  __typename?: 'AddReactionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The reaction object. */
  reaction?: Maybe<GQLReaction>;
  /** The reactable subject. */
  subject?: Maybe<GQLReactable>;
};

/** Autogenerated input type of AddStar */
export type GQLAddStarInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Starrable ID to star. */
  starrableId: Scalars['ID'];
};

/** Autogenerated return type of AddStar */
export type GQLAddStarPayload = {
  __typename?: 'AddStarPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The starrable. */
  starrable?: Maybe<GQLStarrable>;
};

/** Represents a 'added_to_project' event on a given issue or pull request. */
export type GQLAddedToProjectEvent = GQLNode & {
  __typename?: 'AddedToProjectEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** Project referenced by event. */
  project?: Maybe<GQLProject>;
  /** Project card referenced by this project event. */
  projectCard?: Maybe<GQLProjectCard>;
  /** Column name referenced by this project event. */
  projectColumnName: Scalars['String'];
};

/** A GitHub App. */
export type GQLApp = GQLNode & {
  __typename?: 'App';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The description of the app. */
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The hex color code, without the leading '#', for the logo background. */
  logoBackgroundColor: Scalars['String'];
  /** A URL pointing to the app's logo. */
  logoUrl: Scalars['URI'];
  /** The name of the app. */
  name: Scalars['String'];
  /** A slug based on the name of the app for use in URLs. */
  slug: Scalars['String'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The URL to the app's homepage. */
  url: Scalars['URI'];
};


/** A GitHub App. */
export type GQLAppLogoUrlArgs = {
  size?: Maybe<Scalars['Int']>;
};

/** Autogenerated input type of ArchiveRepository */
export type GQLArchiveRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the repository to mark as archived. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of ArchiveRepository */
export type GQLArchiveRepositoryPayload = {
  __typename?: 'ArchiveRepositoryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The repository that was marked as archived. */
  repository?: Maybe<GQLRepository>;
};

/** An object that can have users assigned to it. */
export type GQLAssignable = {
  /** A list of Users assigned to this object. */
  assignees: GQLUserConnection;
};


/** An object that can have users assigned to it. */
export type GQLAssignableAssigneesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** Represents an 'assigned' event on any assignable object. */
export type GQLAssignedEvent = GQLNode & {
  __typename?: 'AssignedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the assignable associated with the event. */
  assignable: GQLAssignable;
  /** Identifies the user or mannequin that was assigned. */
  assignee?: Maybe<GQLAssignee>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /**
   * Identifies the user who was assigned.
   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.
   */
  user?: Maybe<GQLUser>;
};

/** Types that can be assigned to issues. */
export type GQLAssignee = GQLBot | GQLMannequin | GQLOrganization | GQLUser;

/** An entry in the audit log. */
export type GQLAuditEntry = {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Types that can initiate an audit log event. */
export type GQLAuditEntryActor = GQLBot | GQLOrganization | GQLUser;

/** Ordering options for Audit Log connections. */
export type GQLAuditLogOrder = {
  /** The ordering direction. */
  direction?: Maybe<GQLOrderDirection>;
  /** The field to order Audit Logs by. */
  field?: Maybe<GQLAuditLogOrderField>;
};

/** Properties by which Audit Log connections can be ordered. */
export enum GQLAuditLogOrderField {
  /** Order audit log entries by timestamp */
  CreatedAt = 'CREATED_AT'
}

/** Represents a 'automatic_base_change_failed' event on a given pull request. */
export type GQLAutomaticBaseChangeFailedEvent = GQLNode & {
  __typename?: 'AutomaticBaseChangeFailedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** The new base for this PR */
  newBase: Scalars['String'];
  /** The old base for this PR */
  oldBase: Scalars['String'];
  /** PullRequest referenced by event. */
  pullRequest: GQLPullRequest;
};

/** Represents a 'automatic_base_change_succeeded' event on a given pull request. */
export type GQLAutomaticBaseChangeSucceededEvent = GQLNode & {
  __typename?: 'AutomaticBaseChangeSucceededEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** The new base for this PR */
  newBase: Scalars['String'];
  /** The old base for this PR */
  oldBase: Scalars['String'];
  /** PullRequest referenced by event. */
  pullRequest: GQLPullRequest;
};

/** Represents a 'base_ref_changed' event on a given issue or pull request. */
export type GQLBaseRefChangedEvent = GQLNode & {
  __typename?: 'BaseRefChangedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
};

/** Represents a 'base_ref_force_pushed' event on a given pull request. */
export type GQLBaseRefForcePushedEvent = GQLNode & {
  __typename?: 'BaseRefForcePushedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the after commit SHA for the 'base_ref_force_pushed' event. */
  afterCommit?: Maybe<GQLCommit>;
  /** Identifies the before commit SHA for the 'base_ref_force_pushed' event. */
  beforeCommit?: Maybe<GQLCommit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: GQLPullRequest;
  /** Identifies the fully qualified ref name for the 'base_ref_force_pushed' event. */
  ref?: Maybe<GQLRef>;
};

/** Represents a Git blame. */
export type GQLBlame = {
  __typename?: 'Blame';
  /** The list of ranges from a Git blame. */
  ranges: Array<GQLBlameRange>;
};

/** Represents a range of information from a Git blame. */
export type GQLBlameRange = {
  __typename?: 'BlameRange';
  /**
   * Identifies the recency of the change, from 1 (new) to 10 (old). This is
   * calculated as a 2-quantile and determines the length of distance between the
   * median age of all the changes in the file and the recency of the current
   * range's change.
   */
  age: Scalars['Int'];
  /** Identifies the line author */
  commit: GQLCommit;
  /** The ending line for the range */
  endingLine: Scalars['Int'];
  /** The starting line for the range */
  startingLine: Scalars['Int'];
};

/** Represents a Git blob. */
export type GQLBlob = GQLGitObject & GQLNode & {
  __typename?: 'Blob';
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String'];
  /** Byte size of Blob object */
  byteSize: Scalars['Int'];
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['URI'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['URI'];
  id: Scalars['ID'];
  /**
   * Indicates whether the Blob is binary or text
   * 
   * **Upcoming Change on 2019-07-01 UTC**
   * **Description:** Type for `isBinary` will change from `Boolean!` to `Boolean`.
   * **Reason:** The `isBinary` field may return `null` when it cannot determine if a Blob is binary.
   */
  isBinary: Scalars['Boolean'];
  /** Indicates whether the contents is truncated */
  isTruncated: Scalars['Boolean'];
  /** The Git object ID */
  oid: Scalars['GitObjectID'];
  /** The Repository the Git object belongs to */
  repository: GQLRepository;
  /** UTF8 text data or null if the Blob is binary */
  text?: Maybe<Scalars['String']>;
};

/** A special type of user which takes actions on behalf of GitHub Apps. */
export type GQLBot = GQLActor & GQLNode & GQLUniformResourceLocatable & {
  __typename?: 'Bot';
  /** A URL pointing to the GitHub App's public avatar. */
  avatarUrl: Scalars['URI'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The username of the actor. */
  login: Scalars['String'];
  /** The HTTP path for this bot */
  resourcePath: Scalars['URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this bot */
  url: Scalars['URI'];
};


/** A special type of user which takes actions on behalf of GitHub Apps. */
export type GQLBotAvatarUrlArgs = {
  size?: Maybe<Scalars['Int']>;
};

/** A branch protection rule. */
export type GQLBranchProtectionRule = GQLNode & {
  __typename?: 'BranchProtectionRule';
  /** A list of conflicts matching branches protection rule and other branch protection rules */
  branchProtectionRuleConflicts: GQLBranchProtectionRuleConflictConnection;
  /** The actor who created this branch protection rule. */
  creator?: Maybe<GQLActor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews: Scalars['Boolean'];
  id: Scalars['ID'];
  /** Can admins overwrite branch protection. */
  isAdminEnforced: Scalars['Boolean'];
  /** Repository refs that are protected by this rule */
  matchingRefs: GQLRefConnection;
  /** Identifies the protection rule pattern. */
  pattern: Scalars['String'];
  /** A list push allowances for this branch protection rule. */
  pushAllowances: GQLPushAllowanceConnection;
  /** The repository associated with this branch protection rule. */
  repository?: Maybe<GQLRepository>;
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: Maybe<Scalars['Int']>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews: Scalars['Boolean'];
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews: Scalars['Boolean'];
  /** Are commits required to be signed. */
  requiresCommitSignatures: Scalars['Boolean'];
  /** Are status checks required to update matching branches. */
  requiresStatusChecks: Scalars['Boolean'];
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks: Scalars['Boolean'];
  /** Is pushing to matching branches restricted. */
  restrictsPushes: Scalars['Boolean'];
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals: Scalars['Boolean'];
  /** A list review dismissal allowances for this branch protection rule. */
  reviewDismissalAllowances: GQLReviewDismissalAllowanceConnection;
};


/** A branch protection rule. */
export type GQLBranchProtectionRuleBranchProtectionRuleConflictsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A branch protection rule. */
export type GQLBranchProtectionRuleMatchingRefsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  query?: Maybe<Scalars['String']>;
};


/** A branch protection rule. */
export type GQLBranchProtectionRulePushAllowancesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A branch protection rule. */
export type GQLBranchProtectionRuleReviewDismissalAllowancesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** A conflict between two branch protection rules. */
export type GQLBranchProtectionRuleConflict = {
  __typename?: 'BranchProtectionRuleConflict';
  /** Identifies the branch protection rule. */
  branchProtectionRule?: Maybe<GQLBranchProtectionRule>;
  /** Identifies the conflicting branch protection rule. */
  conflictingBranchProtectionRule?: Maybe<GQLBranchProtectionRule>;
  /** Identifies the branch ref that has conflicting rules */
  ref?: Maybe<GQLRef>;
};

/** The connection type for BranchProtectionRuleConflict. */
export type GQLBranchProtectionRuleConflictConnection = {
  __typename?: 'BranchProtectionRuleConflictConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLBranchProtectionRuleConflictEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLBranchProtectionRuleConflict>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLBranchProtectionRuleConflictEdge = {
  __typename?: 'BranchProtectionRuleConflictEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLBranchProtectionRuleConflict>;
};

/** The connection type for BranchProtectionRule. */
export type GQLBranchProtectionRuleConnection = {
  __typename?: 'BranchProtectionRuleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLBranchProtectionRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLBranchProtectionRule>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLBranchProtectionRuleEdge = {
  __typename?: 'BranchProtectionRuleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLBranchProtectionRule>;
};

/** Autogenerated input type of CancelEnterpriseAdminInvitation */
export type GQLCancelEnterpriseAdminInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the pending enterprise administrator invitation. */
  invitationId: Scalars['ID'];
};

/** Autogenerated return type of CancelEnterpriseAdminInvitation */
export type GQLCancelEnterpriseAdminInvitationPayload = {
  __typename?: 'CancelEnterpriseAdminInvitationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The invitation that was canceled. */
  invitation?: Maybe<GQLEnterpriseAdministratorInvitation>;
  /** A message confirming the result of canceling an administrator invitation. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of ChangeUserStatus */
export type GQLChangeUserStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The emoji to represent your status. Can either be a native Unicode emoji or an emoji name with colons, e.g., :grinning:. */
  emoji?: Maybe<Scalars['String']>;
  /** If set, the user status will not be shown after this date. */
  expiresAt?: Maybe<Scalars['DateTime']>;
  /** Whether this status should indicate you are not fully available on GitHub, e.g., you are away. */
  limitedAvailability?: Maybe<Scalars['Boolean']>;
  /** A short description of your current status. */
  message?: Maybe<Scalars['String']>;
  /**
   * The ID of the organization whose members will be allowed to see the status. If
   * omitted, the status will be publicly visible.
   */
  organizationId?: Maybe<Scalars['ID']>;
};

/** Autogenerated return type of ChangeUserStatus */
export type GQLChangeUserStatusPayload = {
  __typename?: 'ChangeUserStatusPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Your updated status. */
  status?: Maybe<GQLUserStatus>;
};

/** A single check annotation. */
export type GQLCheckAnnotation = {
  __typename?: 'CheckAnnotation';
  /** The annotation's severity level. */
  annotationLevel?: Maybe<GQLCheckAnnotationLevel>;
  /** The path to the file that this annotation was made on. */
  blobUrl: Scalars['URI'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The position of this annotation. */
  location: GQLCheckAnnotationSpan;
  /** The annotation's message. */
  message: Scalars['String'];
  /** The path that this annotation was made on. */
  path: Scalars['String'];
  /** Additional information about the annotation. */
  rawDetails?: Maybe<Scalars['String']>;
  /** The annotation's title */
  title?: Maybe<Scalars['String']>;
};

/** The connection type for CheckAnnotation. */
export type GQLCheckAnnotationConnection = {
  __typename?: 'CheckAnnotationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLCheckAnnotationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLCheckAnnotation>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Information from a check run analysis to specific lines of code. */
export type GQLCheckAnnotationData = {
  /** Represents an annotation's information level */
  annotationLevel: GQLCheckAnnotationLevel;
  /** The location of the annotation */
  location: GQLCheckAnnotationRange;
  /** A short description of the feedback for these lines of code. */
  message: Scalars['String'];
  /** The path of the file to add an annotation to. */
  path: Scalars['String'];
  /** Details about this annotation. */
  rawDetails?: Maybe<Scalars['String']>;
  /** The title that represents the annotation. */
  title?: Maybe<Scalars['String']>;
};

/** An edge in a connection. */
export type GQLCheckAnnotationEdge = {
  __typename?: 'CheckAnnotationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLCheckAnnotation>;
};

/** Represents an annotation's information level. */
export enum GQLCheckAnnotationLevel {
  /** An annotation indicating an inescapable error. */
  Failure = 'FAILURE',
  /** An annotation indicating some information. */
  Notice = 'NOTICE',
  /** An annotation indicating an ignorable error. */
  Warning = 'WARNING'
}

/** A character position in a check annotation. */
export type GQLCheckAnnotationPosition = {
  __typename?: 'CheckAnnotationPosition';
  /** Column number (1 indexed). */
  column?: Maybe<Scalars['Int']>;
  /** Line number (1 indexed). */
  line: Scalars['Int'];
};

/** Information from a check run analysis to specific lines of code. */
export type GQLCheckAnnotationRange = {
  /** The ending column of the range. */
  endColumn?: Maybe<Scalars['Int']>;
  /** The ending line of the range. */
  endLine: Scalars['Int'];
  /** The starting column of the range. */
  startColumn?: Maybe<Scalars['Int']>;
  /** The starting line of the range. */
  startLine: Scalars['Int'];
};

/** An inclusive pair of positions for a check annotation. */
export type GQLCheckAnnotationSpan = {
  __typename?: 'CheckAnnotationSpan';
  /** End position (inclusive). */
  end: GQLCheckAnnotationPosition;
  /** Start position (inclusive). */
  start: GQLCheckAnnotationPosition;
};

/** The possible states for a check suite or run conclusion. */
export enum GQLCheckConclusionState {
  /** The check suite or run requires action. */
  ActionRequired = 'ACTION_REQUIRED',
  /** The check suite or run has been cancelled. */
  Cancelled = 'CANCELLED',
  /** The check suite or run has failed. */
  Failure = 'FAILURE',
  /** The check suite or run was neutral. */
  Neutral = 'NEUTRAL',
  /** The check suite or run was skipped. */
  Skipped = 'SKIPPED',
  /** The check suite or run was marked stale by GitHub. Only GitHub can use this conclusion. */
  Stale = 'STALE',
  /** The check suite or run has succeeded. */
  Success = 'SUCCESS',
  /** The check suite or run has timed out. */
  TimedOut = 'TIMED_OUT'
}

/** A check run. */
export type GQLCheckRun = GQLNode & GQLUniformResourceLocatable & {
  __typename?: 'CheckRun';
  /** The check run's annotations */
  annotations?: Maybe<GQLCheckAnnotationConnection>;
  /** The check suite that this run is a part of. */
  checkSuite: GQLCheckSuite;
  /** Identifies the date and time when the check run was completed. */
  completedAt?: Maybe<Scalars['DateTime']>;
  /** The conclusion of the check run. */
  conclusion?: Maybe<GQLCheckConclusionState>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The URL from which to find full details of the check run on the integrator's site. */
  detailsUrl?: Maybe<Scalars['URI']>;
  /** A reference for the check run on the integrator's system. */
  externalId?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The name of the check for this check run. */
  name: Scalars['String'];
  /** The permalink to the check run summary. */
  permalink: Scalars['URI'];
  /** The repository associated with this check run. */
  repository: GQLRepository;
  /** The HTTP path for this check run. */
  resourcePath: Scalars['URI'];
  /** Identifies the date and time when the check run was started. */
  startedAt?: Maybe<Scalars['DateTime']>;
  /** The current status of the check run. */
  status: GQLCheckStatusState;
  /** A string representing the check run's summary */
  summary?: Maybe<Scalars['String']>;
  /** A string representing the check run's text */
  text?: Maybe<Scalars['String']>;
  /** A string representing the check run */
  title?: Maybe<Scalars['String']>;
  /** The HTTP URL for this check run. */
  url: Scalars['URI'];
};


/** A check run. */
export type GQLCheckRunAnnotationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** Possible further actions the integrator can perform. */
export type GQLCheckRunAction = {
  /** A short explanation of what this action would do. */
  description: Scalars['String'];
  /** A reference for the action on the integrator's system. */
  identifier: Scalars['String'];
  /** The text to be displayed on a button in the web UI. */
  label: Scalars['String'];
};

/** The connection type for CheckRun. */
export type GQLCheckRunConnection = {
  __typename?: 'CheckRunConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLCheckRunEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLCheckRun>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLCheckRunEdge = {
  __typename?: 'CheckRunEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLCheckRun>;
};

/** The filters that are available when fetching check runs. */
export type GQLCheckRunFilter = {
  /** Filters the check runs created by this application ID. */
  appId?: Maybe<Scalars['Int']>;
  /** Filters the check runs by this name. */
  checkName?: Maybe<Scalars['String']>;
  /** Filters the check runs by this type. */
  checkType?: Maybe<GQLCheckRunType>;
  /** Filters the check runs by this status. */
  status?: Maybe<GQLCheckStatusState>;
};

/** Descriptive details about the check run. */
export type GQLCheckRunOutput = {
  /** The annotations that are made as part of the check run. */
  annotations?: Maybe<Array<GQLCheckAnnotationData>>;
  /** Images attached to the check run output displayed in the GitHub pull request UI. */
  images?: Maybe<Array<GQLCheckRunOutputImage>>;
  /** The summary of the check run (supports Commonmark). */
  summary: Scalars['String'];
  /** The details of the check run (supports Commonmark). */
  text?: Maybe<Scalars['String']>;
  /** A title to provide for this check run. */
  title: Scalars['String'];
};

/** Images attached to the check run output displayed in the GitHub pull request UI. */
export type GQLCheckRunOutputImage = {
  /** The alternative text for the image. */
  alt: Scalars['String'];
  /** A short image description. */
  caption?: Maybe<Scalars['String']>;
  /** The full URL of the image. */
  imageUrl: Scalars['URI'];
};

/** The possible types of check runs. */
export enum GQLCheckRunType {
  /** Every check run available. */
  All = 'ALL',
  /** The latest check run. */
  Latest = 'LATEST'
}

/** The possible states for a check suite or run status. */
export enum GQLCheckStatusState {
  /** The check suite or run has been completed. */
  Completed = 'COMPLETED',
  /** The check suite or run is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The check suite or run has been queued. */
  Queued = 'QUEUED',
  /** The check suite or run has been requested. */
  Requested = 'REQUESTED'
}

/** A check suite. */
export type GQLCheckSuite = GQLNode & {
  __typename?: 'CheckSuite';
  /** The GitHub App which created this check suite. */
  app?: Maybe<GQLApp>;
  /** The name of the branch for this check suite. */
  branch?: Maybe<GQLRef>;
  /** The check runs associated with a check suite. */
  checkRuns?: Maybe<GQLCheckRunConnection>;
  /** The commit for this check suite */
  commit: GQLCommit;
  /** The conclusion of this check suite. */
  conclusion?: Maybe<GQLCheckConclusionState>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** A list of open pull requests matching the check suite. */
  matchingPullRequests?: Maybe<GQLPullRequestConnection>;
  /** The push that triggered this check suite. */
  push?: Maybe<GQLPush>;
  /** The repository associated with this check suite. */
  repository: GQLRepository;
  /** The HTTP path for this check suite */
  resourcePath: Scalars['URI'];
  /** The status of this check suite. */
  status: GQLCheckStatusState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this check suite */
  url: Scalars['URI'];
};


/** A check suite. */
export type GQLCheckSuiteCheckRunsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  filterBy?: Maybe<GQLCheckRunFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A check suite. */
export type GQLCheckSuiteMatchingPullRequestsArgs = {
  after?: Maybe<Scalars['String']>;
  baseRefName?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  headRefName?: Maybe<Scalars['String']>;
  labels?: Maybe<Array<Scalars['String']>>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLIssueOrder>;
  states?: Maybe<Array<GQLPullRequestState>>;
};

/** The auto-trigger preferences that are available for check suites. */
export type GQLCheckSuiteAutoTriggerPreference = {
  /** The node ID of the application that owns the check suite. */
  appId: Scalars['ID'];
  /** Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository. */
  setting: Scalars['Boolean'];
};

/** The connection type for CheckSuite. */
export type GQLCheckSuiteConnection = {
  __typename?: 'CheckSuiteConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLCheckSuiteEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLCheckSuite>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLCheckSuiteEdge = {
  __typename?: 'CheckSuiteEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLCheckSuite>;
};

/** The filters that are available when fetching check suites. */
export type GQLCheckSuiteFilter = {
  /** Filters the check suites created by this application ID. */
  appId?: Maybe<Scalars['Int']>;
  /** Filters the check suites by this name. */
  checkName?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of ClearLabelsFromLabelable */
export type GQLClearLabelsFromLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The id of the labelable object to clear the labels from. */
  labelableId: Scalars['ID'];
};

/** Autogenerated return type of ClearLabelsFromLabelable */
export type GQLClearLabelsFromLabelablePayload = {
  __typename?: 'ClearLabelsFromLabelablePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The item that was unlabeled. */
  labelable?: Maybe<GQLLabelable>;
};

/** Autogenerated input type of CloneProject */
export type GQLCloneProjectInput = {
  /** The description of the project. */
  body?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Whether or not to clone the source project's workflows. */
  includeWorkflows: Scalars['Boolean'];
  /** The name of the project. */
  name: Scalars['String'];
  /** The visibility of the project, defaults to false (private). */
  public?: Maybe<Scalars['Boolean']>;
  /** The source project to clone. */
  sourceId: Scalars['ID'];
  /** The owner ID to create the project under. */
  targetOwnerId: Scalars['ID'];
};

/** Autogenerated return type of CloneProject */
export type GQLCloneProjectPayload = {
  __typename?: 'CloneProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The id of the JobStatus for populating cloned fields. */
  jobStatusId?: Maybe<Scalars['String']>;
  /** The new cloned project. */
  project?: Maybe<GQLProject>;
};

/** Autogenerated input type of CloneTemplateRepository */
export type GQLCloneTemplateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A short description of the new repository. */
  description?: Maybe<Scalars['String']>;
  /**
   * Whether to copy all branches from the template to the new repository. Defaults
   * to copying only the default branch of the template.
   */
  includeAllBranches?: Maybe<Scalars['Boolean']>;
  /** The name of the new repository. */
  name: Scalars['String'];
  /** The ID of the owner for the new repository. */
  ownerId: Scalars['ID'];
  /** The Node ID of the template repository. */
  repositoryId: Scalars['ID'];
  /** Indicates the repository's visibility level. */
  visibility: GQLRepositoryVisibility;
};

/** Autogenerated return type of CloneTemplateRepository */
export type GQLCloneTemplateRepositoryPayload = {
  __typename?: 'CloneTemplateRepositoryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new repository. */
  repository?: Maybe<GQLRepository>;
};

/** An object that can be closed */
export type GQLClosable = {
  /** `true` if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']>;
};

/** Autogenerated input type of CloseIssue */
export type GQLCloseIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** ID of the issue to be closed. */
  issueId: Scalars['ID'];
};

/** Autogenerated return type of CloseIssue */
export type GQLCloseIssuePayload = {
  __typename?: 'CloseIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The issue that was closed. */
  issue?: Maybe<GQLIssue>;
};

/** Autogenerated input type of ClosePullRequest */
export type GQLClosePullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** ID of the pull request to be closed. */
  pullRequestId: Scalars['ID'];
};

/** Autogenerated return type of ClosePullRequest */
export type GQLClosePullRequestPayload = {
  __typename?: 'ClosePullRequestPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request that was closed. */
  pullRequest?: Maybe<GQLPullRequest>;
};

/** Represents a 'closed' event on any `Closable`. */
export type GQLClosedEvent = GQLNode & GQLUniformResourceLocatable & {
  __typename?: 'ClosedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Object that was closed. */
  closable: GQLClosable;
  /** Object which triggered the creation of this event. */
  closer?: Maybe<GQLCloser>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** The HTTP path for this closed event. */
  resourcePath: Scalars['URI'];
  /** The HTTP URL for this closed event. */
  url: Scalars['URI'];
};

/** The object which triggered a `ClosedEvent`. */
export type GQLCloser = GQLCommit | GQLPullRequest;

/** The Code of Conduct for a repository */
export type GQLCodeOfConduct = GQLNode & {
  __typename?: 'CodeOfConduct';
  /** The body of the Code of Conduct */
  body?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The key for the Code of Conduct */
  key: Scalars['String'];
  /** The formal name of the Code of Conduct */
  name: Scalars['String'];
  /** The HTTP path for this Code of Conduct */
  resourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for this Code of Conduct */
  url?: Maybe<Scalars['URI']>;
};

/** Collaborators affiliation level with a subject. */
export enum GQLCollaboratorAffiliation {
  /** All collaborators the authenticated user can see. */
  All = 'ALL',
  /** All collaborators with permissions to an organization-owned subject, regardless of organization membership status. */
  Direct = 'DIRECT',
  /** All outside collaborators of an organization-owned subject. */
  Outside = 'OUTSIDE'
}

/** Represents a comment. */
export type GQLComment = {
  /** The actor who authored the comment. */
  author?: Maybe<GQLActor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: GQLCommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** The actor who edited the comment. */
  editor?: Maybe<GQLActor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<GQLUserContentEditConnection>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
};


/** Represents a comment. */
export type GQLCommentUserContentEditsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** A comment author association with repository. */
export enum GQLCommentAuthorAssociation {
  /** Author has been invited to collaborate on the repository. */
  Collaborator = 'COLLABORATOR',
  /** Author has previously committed to the repository. */
  Contributor = 'CONTRIBUTOR',
  /** Author has not previously committed to GitHub. */
  FirstTimer = 'FIRST_TIMER',
  /** Author has not previously committed to the repository. */
  FirstTimeContributor = 'FIRST_TIME_CONTRIBUTOR',
  /** Author is a member of the organization that owns the repository. */
  Member = 'MEMBER',
  /** Author has no association with the repository. */
  None = 'NONE',
  /** Author is the owner of the repository. */
  Owner = 'OWNER'
}

/** The possible errors that will prevent a user from updating a comment. */
export enum GQLCommentCannotUpdateReason {
  /** Unable to create comment because repository is archived. */
  Archived = 'ARCHIVED',
  /** You cannot update this comment */
  Denied = 'DENIED',
  /** You must be the author or have write access to this repository to update this comment. */
  InsufficientAccess = 'INSUFFICIENT_ACCESS',
  /** Unable to create comment because issue is locked. */
  Locked = 'LOCKED',
  /** You must be logged in to update this comment. */
  LoginRequired = 'LOGIN_REQUIRED',
  /** Repository is under maintenance. */
  Maintenance = 'MAINTENANCE',
  /** At least one email address must be verified to update this comment. */
  VerifiedEmailRequired = 'VERIFIED_EMAIL_REQUIRED'
}

/** Represents a 'comment_deleted' event on a given issue or pull request. */
export type GQLCommentDeletedEvent = GQLNode & {
  __typename?: 'CommentDeletedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
};

/** Represents a Git commit. */
export type GQLCommit = GQLGitObject & GQLNode & GQLSubscribable & GQLUniformResourceLocatable & {
  __typename?: 'Commit';
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String'];
  /** The number of additions in this commit. */
  additions: Scalars['Int'];
  /** The pull requests associated with a commit */
  associatedPullRequests?: Maybe<GQLPullRequestConnection>;
  /** Authorship details of the commit. */
  author?: Maybe<GQLGitActor>;
  /** Check if the committer and the author match. */
  authoredByCommitter: Scalars['Boolean'];
  /** The datetime when this commit was authored. */
  authoredDate: Scalars['DateTime'];
  /** Fetches `git blame` information. */
  blame: GQLBlame;
  /** The number of changed files in this commit. */
  changedFiles: Scalars['Int'];
  /** The check suites associated with a commit. */
  checkSuites?: Maybe<GQLCheckSuiteConnection>;
  /** Comments made on the commit. */
  comments: GQLCommitCommentConnection;
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['URI'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['URI'];
  /** The datetime when this commit was committed. */
  committedDate: Scalars['DateTime'];
  /** Check if commited via GitHub web UI. */
  committedViaWeb: Scalars['Boolean'];
  /** Committership details of the commit. */
  committer?: Maybe<GQLGitActor>;
  /** The number of deletions in this commit. */
  deletions: Scalars['Int'];
  /** The deployments associated with a commit. */
  deployments?: Maybe<GQLDeploymentConnection>;
  /** The linear commit history starting from (and including) this commit, in the same order as `git log`. */
  history: GQLCommitHistoryConnection;
  id: Scalars['ID'];
  /** The Git commit message */
  message: Scalars['String'];
  /** The Git commit message body */
  messageBody: Scalars['String'];
  /** The commit message body rendered to HTML. */
  messageBodyHTML: Scalars['HTML'];
  /** The Git commit message headline */
  messageHeadline: Scalars['String'];
  /** The commit message headline rendered to HTML. */
  messageHeadlineHTML: Scalars['HTML'];
  /** The Git object ID */
  oid: Scalars['GitObjectID'];
  /** The organization this commit was made on behalf of. */
  onBehalfOf?: Maybe<GQLOrganization>;
  /** The parents of a commit. */
  parents: GQLCommitConnection;
  /** The datetime when this commit was pushed. */
  pushedDate?: Maybe<Scalars['DateTime']>;
  /** The Repository this commit belongs to */
  repository: GQLRepository;
  /** The HTTP path for this commit */
  resourcePath: Scalars['URI'];
  /** Commit signing information, if present. */
  signature?: Maybe<GQLGitSignature>;
  /** Status information for this commit */
  status?: Maybe<GQLStatus>;
  /** Check and Status rollup information for this commit. */
  statusCheckRollup?: Maybe<GQLStatusCheckRollup>;
  /** Returns a list of all submodules in this repository as of this Commit parsed from the .gitmodules file. */
  submodules: GQLSubmoduleConnection;
  /**
   * Returns a URL to download a tarball archive for a repository.
   * Note: For private repositories, these links are temporary and expire after five minutes.
   */
  tarballUrl: Scalars['URI'];
  /** Commit's root Tree */
  tree: GQLTree;
  /** The HTTP path for the tree of this commit */
  treeResourcePath: Scalars['URI'];
  /** The HTTP URL for the tree of this commit */
  treeUrl: Scalars['URI'];
  /** The HTTP URL for this commit */
  url: Scalars['URI'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<GQLSubscriptionState>;
  /**
   * Returns a URL to download a zipball archive for a repository.
   * Note: For private repositories, these links are temporary and expire after five minutes.
   */
  zipballUrl: Scalars['URI'];
};


/** Represents a Git commit. */
export type GQLCommitAssociatedPullRequestsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLPullRequestOrder>;
};


/** Represents a Git commit. */
export type GQLCommitBlameArgs = {
  path: Scalars['String'];
};


/** Represents a Git commit. */
export type GQLCommitCheckSuitesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  filterBy?: Maybe<GQLCheckSuiteFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** Represents a Git commit. */
export type GQLCommitCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** Represents a Git commit. */
export type GQLCommitDeploymentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  environments?: Maybe<Array<Scalars['String']>>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLDeploymentOrder>;
};


/** Represents a Git commit. */
export type GQLCommitHistoryArgs = {
  after?: Maybe<Scalars['String']>;
  author?: Maybe<GQLCommitAuthor>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  path?: Maybe<Scalars['String']>;
  since?: Maybe<Scalars['GitTimestamp']>;
  until?: Maybe<Scalars['GitTimestamp']>;
};


/** Represents a Git commit. */
export type GQLCommitParentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** Represents a Git commit. */
export type GQLCommitSubmodulesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** Specifies an author for filtering Git commits. */
export type GQLCommitAuthor = {
  /** Email addresses to filter by. Commits authored by any of the specified email addresses will be returned. */
  emails?: Maybe<Array<Scalars['String']>>;
  /**
   * ID of a User to filter by. If non-null, only commits authored by this user
   * will be returned. This field takes precedence over emails.
   */
  id?: Maybe<Scalars['ID']>;
};

/** Represents a comment on a given Commit. */
export type GQLCommitComment = GQLComment & GQLDeletable & GQLMinimizable & GQLNode & GQLReactable & GQLRepositoryNode & GQLUpdatable & GQLUpdatableComment & {
  __typename?: 'CommitComment';
  /** The actor who authored the comment. */
  author?: Maybe<GQLActor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: GQLCommentAuthorAssociation;
  /** Identifies the comment body. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** Identifies the commit associated with the comment, if the commit exists. */
  commit?: Maybe<GQLCommit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The actor who edited the comment. */
  editor?: Maybe<GQLActor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** Returns why the comment was minimized. */
  minimizedReason?: Maybe<Scalars['String']>;
  /** Identifies the file path associated with the comment. */
  path?: Maybe<Scalars['String']>;
  /** Identifies the line position associated with the comment. */
  position?: Maybe<Scalars['Int']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<GQLReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: GQLReactionConnection;
  /** The repository associated with this node. */
  repository: GQLRepository;
  /** The HTTP path permalink for this commit comment. */
  resourcePath: Scalars['URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL permalink for this commit comment. */
  url: Scalars['URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<GQLUserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<GQLCommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
};


/** Represents a comment on a given Commit. */
export type GQLCommitCommentReactionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  content?: Maybe<GQLReactionContent>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLReactionOrder>;
};


/** Represents a comment on a given Commit. */
export type GQLCommitCommentUserContentEditsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** The connection type for CommitComment. */
export type GQLCommitCommentConnection = {
  __typename?: 'CommitCommentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLCommitCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLCommitComment>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLCommitCommentEdge = {
  __typename?: 'CommitCommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLCommitComment>;
};

/** A thread of comments on a commit. */
export type GQLCommitCommentThread = GQLNode & GQLRepositoryNode & {
  __typename?: 'CommitCommentThread';
  /** The comments that exist in this thread. */
  comments: GQLCommitCommentConnection;
  /** The commit the comments were made on. */
  commit?: Maybe<GQLCommit>;
  id: Scalars['ID'];
  /** The file the comments were made on. */
  path?: Maybe<Scalars['String']>;
  /** The position in the diff for the commit that the comment was made on. */
  position?: Maybe<Scalars['Int']>;
  /** The repository associated with this node. */
  repository: GQLRepository;
};


/** A thread of comments on a commit. */
export type GQLCommitCommentThreadCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** The connection type for Commit. */
export type GQLCommitConnection = {
  __typename?: 'CommitConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLCommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLCommit>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Ordering options for commit contribution connections. */
export type GQLCommitContributionOrder = {
  /** The ordering direction. */
  direction: GQLOrderDirection;
  /** The field by which to order commit contributions. */
  field: GQLCommitContributionOrderField;
};

/** Properties by which commit contribution connections can be ordered. */
export enum GQLCommitContributionOrderField {
  /** Order commit contributions by how many commits they represent. */
  CommitCount = 'COMMIT_COUNT',
  /** Order commit contributions by when they were made. */
  OccurredAt = 'OCCURRED_AT'
}

/** This aggregates commits made by a user within one repository. */
export type GQLCommitContributionsByRepository = {
  __typename?: 'CommitContributionsByRepository';
  /** The commit contributions, each representing a day. */
  contributions: GQLCreatedCommitContributionConnection;
  /** The repository in which the commits were made. */
  repository: GQLRepository;
  /** The HTTP path for the user's commits to the repository in this time range. */
  resourcePath: Scalars['URI'];
  /** The HTTP URL for the user's commits to the repository in this time range. */
  url: Scalars['URI'];
};


/** This aggregates commits made by a user within one repository. */
export type GQLCommitContributionsByRepositoryContributionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLCommitContributionOrder>;
};

/** An edge in a connection. */
export type GQLCommitEdge = {
  __typename?: 'CommitEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLCommit>;
};

/** The connection type for Commit. */
export type GQLCommitHistoryConnection = {
  __typename?: 'CommitHistoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLCommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLCommit>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a 'connected' event on a given issue or pull request. */
export type GQLConnectedEvent = GQLNode & {
  __typename?: 'ConnectedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars['Boolean'];
  /** Issue or pull request that made the reference. */
  source: GQLReferencedSubject;
  /** Issue or pull request which was connected. */
  subject: GQLReferencedSubject;
};

/** A content attachment */
export type GQLContentAttachment = {
  __typename?: 'ContentAttachment';
  /** The body text of the content attachment. This parameter supports markdown. */
  body: Scalars['String'];
  /** The content reference that the content attachment is attached to. */
  contentReference: GQLContentReference;
  /** Identifies the primary key from the database. */
  databaseId: Scalars['Int'];
  id: Scalars['ID'];
  /** The title of the content attachment. */
  title: Scalars['String'];
};

/** A content reference */
export type GQLContentReference = {
  __typename?: 'ContentReference';
  /** Identifies the primary key from the database. */
  databaseId: Scalars['Int'];
  id: Scalars['ID'];
  /** The reference of the content reference. */
  reference: Scalars['String'];
};

/** Represents a contribution a user made on GitHub, such as opening an issue. */
export type GQLContribution = {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['URI'];
  /** The user who made this contribution. */
  user: GQLUser;
};

/** A calendar of contributions made on GitHub by a user. */
export type GQLContributionCalendar = {
  __typename?: 'ContributionCalendar';
  /** A list of hex color codes used in this calendar. The darker the color, the more contributions it represents. */
  colors: Array<Scalars['String']>;
  /** Determine if the color set was chosen because it's currently Halloween. */
  isHalloween: Scalars['Boolean'];
  /** A list of the months of contributions in this calendar. */
  months: Array<GQLContributionCalendarMonth>;
  /** The count of total contributions in the calendar. */
  totalContributions: Scalars['Int'];
  /** A list of the weeks of contributions in this calendar. */
  weeks: Array<GQLContributionCalendarWeek>;
};

/** Represents a single day of contributions on GitHub by a user. */
export type GQLContributionCalendarDay = {
  __typename?: 'ContributionCalendarDay';
  /** The hex color code that represents how many contributions were made on this day compared to others in the calendar. */
  color: Scalars['String'];
  /** How many contributions were made by the user on this day. */
  contributionCount: Scalars['Int'];
  /** The day this square represents. */
  date: Scalars['Date'];
  /** A number representing which day of the week this square represents, e.g., 1 is Monday. */
  weekday: Scalars['Int'];
};

/** A month of contributions in a user's contribution graph. */
export type GQLContributionCalendarMonth = {
  __typename?: 'ContributionCalendarMonth';
  /** The date of the first day of this month. */
  firstDay: Scalars['Date'];
  /** The name of the month. */
  name: Scalars['String'];
  /** How many weeks started in this month. */
  totalWeeks: Scalars['Int'];
  /** The year the month occurred in. */
  year: Scalars['Int'];
};

/** A week of contributions in a user's contribution graph. */
export type GQLContributionCalendarWeek = {
  __typename?: 'ContributionCalendarWeek';
  /** The days of contributions in this week. */
  contributionDays: Array<GQLContributionCalendarDay>;
  /** The date of the earliest square in this week. */
  firstDay: Scalars['Date'];
};

/** Ordering options for contribution connections. */
export type GQLContributionOrder = {
  /** The ordering direction. */
  direction: GQLOrderDirection;
};

/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type GQLContributionsCollection = {
  __typename?: 'ContributionsCollection';
  /** Commit contributions made by the user, grouped by repository. */
  commitContributionsByRepository: Array<GQLCommitContributionsByRepository>;
  /** A calendar of this user's contributions on GitHub. */
  contributionCalendar: GQLContributionCalendar;
  /** The years the user has been making contributions with the most recent year first. */
  contributionYears: Array<Scalars['Int']>;
  /** Determine if this collection's time span ends in the current month. */
  doesEndInCurrentMonth: Scalars['Boolean'];
  /**
   * The date of the first restricted contribution the user made in this time
   * period. Can only be non-null when the user has enabled private contribution counts.
   */
  earliestRestrictedContributionDate?: Maybe<Scalars['Date']>;
  /** The ending date and time of this collection. */
  endedAt: Scalars['DateTime'];
  /**
   * The first issue the user opened on GitHub. This will be null if that issue was
   * opened outside the collection's time range and ignoreTimeRange is false. If
   * the issue is not visible but the user has opted to show private contributions,
   * a RestrictedContribution will be returned.
   */
  firstIssueContribution?: Maybe<GQLCreatedIssueOrRestrictedContribution>;
  /**
   * The first pull request the user opened on GitHub. This will be null if that
   * pull request was opened outside the collection's time range and
   * ignoreTimeRange is not true. If the pull request is not visible but the user
   * has opted to show private contributions, a RestrictedContribution will be returned.
   */
  firstPullRequestContribution?: Maybe<GQLCreatedPullRequestOrRestrictedContribution>;
  /**
   * The first repository the user created on GitHub. This will be null if that
   * first repository was created outside the collection's time range and
   * ignoreTimeRange is false. If the repository is not visible, then a
   * RestrictedContribution is returned.
   */
  firstRepositoryContribution?: Maybe<GQLCreatedRepositoryOrRestrictedContribution>;
  /** Does the user have any more activity in the timeline that occurred prior to the collection's time range? */
  hasActivityInThePast: Scalars['Boolean'];
  /** Determine if there are any contributions in this collection. */
  hasAnyContributions: Scalars['Boolean'];
  /**
   * Determine if the user made any contributions in this time frame whose details
   * are not visible because they were made in a private repository. Can only be
   * true if the user enabled private contribution counts.
   */
  hasAnyRestrictedContributions: Scalars['Boolean'];
  /** Whether or not the collector's time span is all within the same day. */
  isSingleDay: Scalars['Boolean'];
  /** A list of issues the user opened. */
  issueContributions: GQLCreatedIssueContributionConnection;
  /** Issue contributions made by the user, grouped by repository. */
  issueContributionsByRepository: Array<GQLIssueContributionsByRepository>;
  /**
   * When the user signed up for GitHub. This will be null if that sign up date
   * falls outside the collection's time range and ignoreTimeRange is false.
   */
  joinedGitHubContribution?: Maybe<GQLJoinedGitHubContribution>;
  /**
   * The date of the most recent restricted contribution the user made in this time
   * period. Can only be non-null when the user has enabled private contribution counts.
   */
  latestRestrictedContributionDate?: Maybe<Scalars['Date']>;
  /**
   * When this collection's time range does not include any activity from the user, use this
   * to get a different collection from an earlier time range that does have activity.
   */
  mostRecentCollectionWithActivity?: Maybe<GQLContributionsCollection>;
  /**
   * Returns a different contributions collection from an earlier time range than this one
   * that does not have any contributions.
   */
  mostRecentCollectionWithoutActivity?: Maybe<GQLContributionsCollection>;
  /**
   * The issue the user opened on GitHub that received the most comments in the specified
   * time frame.
   */
  popularIssueContribution?: Maybe<GQLCreatedIssueContribution>;
  /**
   * The pull request the user opened on GitHub that received the most comments in the
   * specified time frame.
   */
  popularPullRequestContribution?: Maybe<GQLCreatedPullRequestContribution>;
  /** Pull request contributions made by the user. */
  pullRequestContributions: GQLCreatedPullRequestContributionConnection;
  /** Pull request contributions made by the user, grouped by repository. */
  pullRequestContributionsByRepository: Array<GQLPullRequestContributionsByRepository>;
  /** Pull request review contributions made by the user. */
  pullRequestReviewContributions: GQLCreatedPullRequestReviewContributionConnection;
  /** Pull request review contributions made by the user, grouped by repository. */
  pullRequestReviewContributionsByRepository: Array<GQLPullRequestReviewContributionsByRepository>;
  /** A list of repositories owned by the user that the user created in this time range. */
  repositoryContributions: GQLCreatedRepositoryContributionConnection;
  /**
   * A count of contributions made by the user that the viewer cannot access. Only
   * non-zero when the user has chosen to share their private contribution counts.
   */
  restrictedContributionsCount: Scalars['Int'];
  /** The beginning date and time of this collection. */
  startedAt: Scalars['DateTime'];
  /** How many commits were made by the user in this time span. */
  totalCommitContributions: Scalars['Int'];
  /** How many issues the user opened. */
  totalIssueContributions: Scalars['Int'];
  /** How many pull requests the user opened. */
  totalPullRequestContributions: Scalars['Int'];
  /** How many pull request reviews the user left. */
  totalPullRequestReviewContributions: Scalars['Int'];
  /** How many different repositories the user committed to. */
  totalRepositoriesWithContributedCommits: Scalars['Int'];
  /** How many different repositories the user opened issues in. */
  totalRepositoriesWithContributedIssues: Scalars['Int'];
  /** How many different repositories the user left pull request reviews in. */
  totalRepositoriesWithContributedPullRequestReviews: Scalars['Int'];
  /** How many different repositories the user opened pull requests in. */
  totalRepositoriesWithContributedPullRequests: Scalars['Int'];
  /** How many repositories the user created. */
  totalRepositoryContributions: Scalars['Int'];
  /** The user who made the contributions in this collection. */
  user: GQLUser;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type GQLContributionsCollectionCommitContributionsByRepositoryArgs = {
  maxRepositories?: Maybe<Scalars['Int']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type GQLContributionsCollectionIssueContributionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  excludeFirst?: Maybe<Scalars['Boolean']>;
  excludePopular?: Maybe<Scalars['Boolean']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLContributionOrder>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type GQLContributionsCollectionIssueContributionsByRepositoryArgs = {
  excludeFirst?: Maybe<Scalars['Boolean']>;
  excludePopular?: Maybe<Scalars['Boolean']>;
  maxRepositories?: Maybe<Scalars['Int']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type GQLContributionsCollectionPullRequestContributionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  excludeFirst?: Maybe<Scalars['Boolean']>;
  excludePopular?: Maybe<Scalars['Boolean']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLContributionOrder>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type GQLContributionsCollectionPullRequestContributionsByRepositoryArgs = {
  excludeFirst?: Maybe<Scalars['Boolean']>;
  excludePopular?: Maybe<Scalars['Boolean']>;
  maxRepositories?: Maybe<Scalars['Int']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type GQLContributionsCollectionPullRequestReviewContributionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLContributionOrder>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type GQLContributionsCollectionPullRequestReviewContributionsByRepositoryArgs = {
  maxRepositories?: Maybe<Scalars['Int']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type GQLContributionsCollectionRepositoryContributionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  excludeFirst?: Maybe<Scalars['Boolean']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLContributionOrder>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type GQLContributionsCollectionTotalIssueContributionsArgs = {
  excludeFirst?: Maybe<Scalars['Boolean']>;
  excludePopular?: Maybe<Scalars['Boolean']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type GQLContributionsCollectionTotalPullRequestContributionsArgs = {
  excludeFirst?: Maybe<Scalars['Boolean']>;
  excludePopular?: Maybe<Scalars['Boolean']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type GQLContributionsCollectionTotalRepositoriesWithContributedIssuesArgs = {
  excludeFirst?: Maybe<Scalars['Boolean']>;
  excludePopular?: Maybe<Scalars['Boolean']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type GQLContributionsCollectionTotalRepositoriesWithContributedPullRequestsArgs = {
  excludeFirst?: Maybe<Scalars['Boolean']>;
  excludePopular?: Maybe<Scalars['Boolean']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type GQLContributionsCollectionTotalRepositoryContributionsArgs = {
  excludeFirst?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated input type of ConvertProjectCardNoteToIssue */
export type GQLConvertProjectCardNoteToIssueInput = {
  /** The body of the newly created issue. */
  body?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ProjectCard ID to convert. */
  projectCardId: Scalars['ID'];
  /** The ID of the repository to create the issue in. */
  repositoryId: Scalars['ID'];
  /** The title of the newly created issue. Defaults to the card's note text. */
  title?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of ConvertProjectCardNoteToIssue */
export type GQLConvertProjectCardNoteToIssuePayload = {
  __typename?: 'ConvertProjectCardNoteToIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated ProjectCard. */
  projectCard?: Maybe<GQLProjectCard>;
};

/** Represents a 'convert_to_draft' event on a given pull request. */
export type GQLConvertToDraftEvent = GQLNode & GQLUniformResourceLocatable & {
  __typename?: 'ConvertToDraftEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: GQLPullRequest;
  /** The HTTP path for this convert to draft event. */
  resourcePath: Scalars['URI'];
  /** The HTTP URL for this convert to draft event. */
  url: Scalars['URI'];
};

/** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
export type GQLConvertedNoteToIssueEvent = GQLNode & {
  __typename?: 'ConvertedNoteToIssueEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** Project referenced by event. */
  project?: Maybe<GQLProject>;
  /** Project card referenced by this project event. */
  projectCard?: Maybe<GQLProjectCard>;
  /** Column name referenced by this project event. */
  projectColumnName: Scalars['String'];
};

/** Autogenerated input type of CreateBranchProtectionRule */
export type GQLCreateBranchProtectionRuleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews?: Maybe<Scalars['Boolean']>;
  /** Can admins overwrite branch protection. */
  isAdminEnforced?: Maybe<Scalars['Boolean']>;
  /** The glob-like pattern used to determine matching branches. */
  pattern: Scalars['String'];
  /** A list of User, Team or App IDs allowed to push to matching branches. */
  pushActorIds?: Maybe<Array<Scalars['ID']>>;
  /** The global relay id of the repository in which a new branch protection rule should be created in. */
  repositoryId: Scalars['ID'];
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: Maybe<Scalars['Int']>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: Maybe<Array<Scalars['String']>>;
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews?: Maybe<Scalars['Boolean']>;
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews?: Maybe<Scalars['Boolean']>;
  /** Are commits required to be signed. */
  requiresCommitSignatures?: Maybe<Scalars['Boolean']>;
  /** Are status checks required to update matching branches. */
  requiresStatusChecks?: Maybe<Scalars['Boolean']>;
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks?: Maybe<Scalars['Boolean']>;
  /** Is pushing to matching branches restricted. */
  restrictsPushes?: Maybe<Scalars['Boolean']>;
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals?: Maybe<Scalars['Boolean']>;
  /** A list of User or Team IDs allowed to dismiss reviews on pull requests targeting matching branches. */
  reviewDismissalActorIds?: Maybe<Array<Scalars['ID']>>;
};

/** Autogenerated return type of CreateBranchProtectionRule */
export type GQLCreateBranchProtectionRulePayload = {
  __typename?: 'CreateBranchProtectionRulePayload';
  /** The newly created BranchProtectionRule. */
  branchProtectionRule?: Maybe<GQLBranchProtectionRule>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateCheckRun */
export type GQLCreateCheckRunInput = {
  /** Possible further actions the integrator can perform, which a user may trigger. */
  actions?: Maybe<Array<GQLCheckRunAction>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The time that the check run finished. */
  completedAt?: Maybe<Scalars['DateTime']>;
  /** The final conclusion of the check. */
  conclusion?: Maybe<GQLCheckConclusionState>;
  /** The URL of the integrator's site that has the full details of the check. */
  detailsUrl?: Maybe<Scalars['URI']>;
  /** A reference for the run on the integrator's system. */
  externalId?: Maybe<Scalars['String']>;
  /** The SHA of the head commit. */
  headSha: Scalars['GitObjectID'];
  /** The name of the check. */
  name: Scalars['String'];
  /** Descriptive details about the run. */
  output?: Maybe<GQLCheckRunOutput>;
  /** The node ID of the repository. */
  repositoryId: Scalars['ID'];
  /** The time that the check run began. */
  startedAt?: Maybe<Scalars['DateTime']>;
  /** The current status. */
  status?: Maybe<GQLRequestableCheckStatusState>;
};

/** Autogenerated return type of CreateCheckRun */
export type GQLCreateCheckRunPayload = {
  __typename?: 'CreateCheckRunPayload';
  /** The newly created check run. */
  checkRun?: Maybe<GQLCheckRun>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateCheckSuite */
export type GQLCreateCheckSuiteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The SHA of the head commit. */
  headSha: Scalars['GitObjectID'];
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of CreateCheckSuite */
export type GQLCreateCheckSuitePayload = {
  __typename?: 'CreateCheckSuitePayload';
  /** The newly created check suite. */
  checkSuite?: Maybe<GQLCheckSuite>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateContentAttachment */
export type GQLCreateContentAttachmentInput = {
  /** The body of the content attachment, which may contain markdown. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The node ID of the content_reference. */
  contentReferenceId: Scalars['ID'];
  /** The title of the content attachment. */
  title: Scalars['String'];
};

/** Autogenerated return type of CreateContentAttachment */
export type GQLCreateContentAttachmentPayload = {
  __typename?: 'CreateContentAttachmentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created content attachment. */
  contentAttachment?: Maybe<GQLContentAttachment>;
};

/** Autogenerated input type of CreateDeployment */
export type GQLCreateDeploymentInput = {
  /** Attempt to automatically merge the default branch into the requested ref, defaults to true. */
  autoMerge?: Maybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Short description of the deployment. */
  description?: Maybe<Scalars['String']>;
  /** Name for the target deployment environment. */
  environment?: Maybe<Scalars['String']>;
  /** JSON payload with extra information about the deployment. */
  payload?: Maybe<Scalars['String']>;
  /** The node ID of the ref to be deployed. */
  refId: Scalars['ID'];
  /** The node ID of the repository. */
  repositoryId: Scalars['ID'];
  /**
   * The status contexts to verify against commit status checks. To bypass required
   * contexts, pass an empty array. Defaults to all unique contexts.
   */
  requiredContexts?: Maybe<Array<Scalars['String']>>;
  /** Specifies a task to execute. */
  task?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of CreateDeployment */
export type GQLCreateDeploymentPayload = {
  __typename?: 'CreateDeploymentPayload';
  /** True if the default branch has been auto-merged into the deployment ref. */
  autoMerged?: Maybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new deployment. */
  deployment?: Maybe<GQLDeployment>;
};

/** Autogenerated input type of CreateDeploymentStatus */
export type GQLCreateDeploymentStatusInput = {
  /**
   * Adds a new inactive status to all non-transient, non-production environment
   * deployments with the same repository and environment name as the created
   * status's deployment.
   */
  autoInactive?: Maybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The node ID of the deployment. */
  deploymentId: Scalars['ID'];
  /** A short description of the status. Maximum length of 140 characters. */
  description?: Maybe<Scalars['String']>;
  /** If provided, updates the environment of the deploy. Otherwise, does not modify the environment. */
  environment?: Maybe<Scalars['String']>;
  /** Sets the URL for accessing your environment. */
  environmentUrl?: Maybe<Scalars['String']>;
  /**
   * The log URL to associate with this status.       This URL should contain
   * output to keep the user updated while the task is running       or serve as
   * historical information for what happened in the deployment.
   */
  logUrl?: Maybe<Scalars['String']>;
  /** The state of the deployment. */
  state: GQLDeploymentStatusState;
};

/** Autogenerated return type of CreateDeploymentStatus */
export type GQLCreateDeploymentStatusPayload = {
  __typename?: 'CreateDeploymentStatusPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new deployment status. */
  deploymentStatus?: Maybe<GQLDeploymentStatus>;
};

/** Autogenerated input type of CreateEnterpriseOrganization */
export type GQLCreateEnterpriseOrganizationInput = {
  /** The logins for the administrators of the new organization. */
  adminLogins: Array<Scalars['String']>;
  /** The email used for sending billing receipts. */
  billingEmail: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise owning the new organization. */
  enterpriseId: Scalars['ID'];
  /** The login of the new organization. */
  login: Scalars['String'];
  /** The profile name of the new organization. */
  profileName: Scalars['String'];
};

/** Autogenerated return type of CreateEnterpriseOrganization */
export type GQLCreateEnterpriseOrganizationPayload = {
  __typename?: 'CreateEnterpriseOrganizationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise that owns the created organization. */
  enterprise?: Maybe<GQLEnterprise>;
  /** The organization that was created. */
  organization?: Maybe<GQLOrganization>;
};

/** Autogenerated input type of CreateIpAllowListEntry */
export type GQLCreateIpAllowListEntryInput = {
  /** An IP address or range of addresses in CIDR notation. */
  allowListValue: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Whether the IP allow list entry is active when an IP allow list is enabled. */
  isActive: Scalars['Boolean'];
  /** An optional name for the IP allow list entry. */
  name?: Maybe<Scalars['String']>;
  /** The ID of the owner for which to create the new IP allow list entry. */
  ownerId: Scalars['ID'];
};

/** Autogenerated return type of CreateIpAllowListEntry */
export type GQLCreateIpAllowListEntryPayload = {
  __typename?: 'CreateIpAllowListEntryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The IP allow list entry that was created. */
  ipAllowListEntry?: Maybe<GQLIpAllowListEntry>;
};

/** Autogenerated input type of CreateIssue */
export type GQLCreateIssueInput = {
  /** The Node ID for the user assignee for this issue. */
  assigneeIds?: Maybe<Array<Scalars['ID']>>;
  /** The body for the issue description. */
  body?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An array of Node IDs of labels for this issue. */
  labelIds?: Maybe<Array<Scalars['ID']>>;
  /** The Node ID of the milestone for this issue. */
  milestoneId?: Maybe<Scalars['ID']>;
  /** An array of Node IDs for projects associated with this issue. */
  projectIds?: Maybe<Array<Scalars['ID']>>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
  /** The title for the issue. */
  title: Scalars['String'];
};

/** Autogenerated return type of CreateIssue */
export type GQLCreateIssuePayload = {
  __typename?: 'CreateIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new issue. */
  issue?: Maybe<GQLIssue>;
};

/** Autogenerated input type of CreateLabel */
export type GQLCreateLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A 6 character hex code, without the leading #, identifying the color of the label. */
  color: Scalars['String'];
  /** A brief description of the label, such as its purpose. */
  description?: Maybe<Scalars['String']>;
  /** The name of the label. */
  name: Scalars['String'];
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of CreateLabel */
export type GQLCreateLabelPayload = {
  __typename?: 'CreateLabelPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new label. */
  label?: Maybe<GQLLabel>;
};

/** Autogenerated input type of CreateProject */
export type GQLCreateProjectInput = {
  /** The description of project. */
  body?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The name of project. */
  name: Scalars['String'];
  /** The owner ID to create the project under. */
  ownerId: Scalars['ID'];
  /** A list of repository IDs to create as linked repositories for the project */
  repositoryIds?: Maybe<Array<Scalars['ID']>>;
  /** The name of the GitHub-provided template. */
  template?: Maybe<GQLProjectTemplate>;
};

/** Autogenerated return type of CreateProject */
export type GQLCreateProjectPayload = {
  __typename?: 'CreateProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new project. */
  project?: Maybe<GQLProject>;
};

/** Autogenerated input type of CreatePullRequest */
export type GQLCreatePullRequestInput = {
  /**
   * The name of the branch you want your changes pulled into. This should be an existing branch
   * on the current repository. You cannot update the base branch on a pull request to point
   * to another repository.
   */
  baseRefName: Scalars['String'];
  /** The contents of the pull request. */
  body?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Indicates whether this pull request should be a draft. */
  draft?: Maybe<Scalars['Boolean']>;
  /**
   * The name of the branch where your changes are implemented. For cross-repository pull requests
   * in the same network, namespace `head_ref_name` with a user like this: `username:branch`.
   */
  headRefName: Scalars['String'];
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify?: Maybe<Scalars['Boolean']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
  /** The title of the pull request. */
  title: Scalars['String'];
};

/** Autogenerated return type of CreatePullRequest */
export type GQLCreatePullRequestPayload = {
  __typename?: 'CreatePullRequestPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new pull request. */
  pullRequest?: Maybe<GQLPullRequest>;
};

/** Autogenerated input type of CreateRef */
export type GQLCreateRefInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The fully qualified name of the new Ref (ie: `refs/heads/my_new_branch`). */
  name: Scalars['String'];
  /** The GitObjectID that the new Ref shall target. Must point to a commit. */
  oid: Scalars['GitObjectID'];
  /** The Node ID of the Repository to create the Ref in. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of CreateRef */
export type GQLCreateRefPayload = {
  __typename?: 'CreateRefPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created ref. */
  ref?: Maybe<GQLRef>;
};

/** Autogenerated input type of CreateRepository */
export type GQLCreateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A short description of the new repository. */
  description?: Maybe<Scalars['String']>;
  /** Indicates if the repository should have the issues feature enabled. */
  hasIssuesEnabled?: Maybe<Scalars['Boolean']>;
  /** Indicates if the repository should have the wiki feature enabled. */
  hasWikiEnabled?: Maybe<Scalars['Boolean']>;
  /** The URL for a web page about this repository. */
  homepageUrl?: Maybe<Scalars['URI']>;
  /** The name of the new repository. */
  name: Scalars['String'];
  /** The ID of the owner for the new repository. */
  ownerId?: Maybe<Scalars['ID']>;
  /**
   * When an organization is specified as the owner, this ID identifies the team
   * that should be granted access to the new repository.
   */
  teamId?: Maybe<Scalars['ID']>;
  /**
   * Whether this repository should be marked as a template such that anyone who
   * can access it can create new repositories with the same files and directory structure.
   */
  template?: Maybe<Scalars['Boolean']>;
  /** Indicates the repository's visibility level. */
  visibility: GQLRepositoryVisibility;
};

/** Autogenerated return type of CreateRepository */
export type GQLCreateRepositoryPayload = {
  __typename?: 'CreateRepositoryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new repository. */
  repository?: Maybe<GQLRepository>;
};

/** Autogenerated input type of CreateTeamDiscussionComment */
export type GQLCreateTeamDiscussionCommentInput = {
  /** The content of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the discussion to which the comment belongs. */
  discussionId: Scalars['ID'];
};

/** Autogenerated return type of CreateTeamDiscussionComment */
export type GQLCreateTeamDiscussionCommentPayload = {
  __typename?: 'CreateTeamDiscussionCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new comment. */
  teamDiscussionComment?: Maybe<GQLTeamDiscussionComment>;
};

/** Autogenerated input type of CreateTeamDiscussion */
export type GQLCreateTeamDiscussionInput = {
  /** The content of the discussion. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /**
   * If true, restricts the visiblity of this discussion to team members and
   * organization admins. If false or not specified, allows any organization member
   * to view this discussion.
   */
  private?: Maybe<Scalars['Boolean']>;
  /** The ID of the team to which the discussion belongs. */
  teamId: Scalars['ID'];
  /** The title of the discussion. */
  title: Scalars['String'];
};

/** Autogenerated return type of CreateTeamDiscussion */
export type GQLCreateTeamDiscussionPayload = {
  __typename?: 'CreateTeamDiscussionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new discussion. */
  teamDiscussion?: Maybe<GQLTeamDiscussion>;
};

/** Represents the contribution a user made by committing to a repository. */
export type GQLCreatedCommitContribution = GQLContribution & {
  __typename?: 'CreatedCommitContribution';
  /** How many commits were made on this day to this repository by the user. */
  commitCount: Scalars['Int'];
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The repository the user made a commit in. */
  repository: GQLRepository;
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['URI'];
  /** The user who made this contribution. */
  user: GQLUser;
};

/** The connection type for CreatedCommitContribution. */
export type GQLCreatedCommitContributionConnection = {
  __typename?: 'CreatedCommitContributionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLCreatedCommitContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLCreatedCommitContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of commits across days and repositories in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLCreatedCommitContributionEdge = {
  __typename?: 'CreatedCommitContributionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLCreatedCommitContribution>;
};

/** Represents the contribution a user made on GitHub by opening an issue. */
export type GQLCreatedIssueContribution = GQLContribution & {
  __typename?: 'CreatedIssueContribution';
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** The issue that was opened. */
  issue: GQLIssue;
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['URI'];
  /** The user who made this contribution. */
  user: GQLUser;
};

/** The connection type for CreatedIssueContribution. */
export type GQLCreatedIssueContributionConnection = {
  __typename?: 'CreatedIssueContributionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLCreatedIssueContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLCreatedIssueContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLCreatedIssueContributionEdge = {
  __typename?: 'CreatedIssueContributionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLCreatedIssueContribution>;
};

/** Represents either a issue the viewer can access or a restricted contribution. */
export type GQLCreatedIssueOrRestrictedContribution = GQLCreatedIssueContribution | GQLRestrictedContribution;

/** Represents the contribution a user made on GitHub by opening a pull request. */
export type GQLCreatedPullRequestContribution = GQLContribution & {
  __typename?: 'CreatedPullRequestContribution';
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The pull request that was opened. */
  pullRequest: GQLPullRequest;
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['URI'];
  /** The user who made this contribution. */
  user: GQLUser;
};

/** The connection type for CreatedPullRequestContribution. */
export type GQLCreatedPullRequestContributionConnection = {
  __typename?: 'CreatedPullRequestContributionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLCreatedPullRequestContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLCreatedPullRequestContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLCreatedPullRequestContributionEdge = {
  __typename?: 'CreatedPullRequestContributionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLCreatedPullRequestContribution>;
};

/** Represents either a pull request the viewer can access or a restricted contribution. */
export type GQLCreatedPullRequestOrRestrictedContribution = GQLCreatedPullRequestContribution | GQLRestrictedContribution;

/** Represents the contribution a user made by leaving a review on a pull request. */
export type GQLCreatedPullRequestReviewContribution = GQLContribution & {
  __typename?: 'CreatedPullRequestReviewContribution';
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The pull request the user reviewed. */
  pullRequest: GQLPullRequest;
  /** The review the user left on the pull request. */
  pullRequestReview: GQLPullRequestReview;
  /** The repository containing the pull request that the user reviewed. */
  repository: GQLRepository;
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['URI'];
  /** The user who made this contribution. */
  user: GQLUser;
};

/** The connection type for CreatedPullRequestReviewContribution. */
export type GQLCreatedPullRequestReviewContributionConnection = {
  __typename?: 'CreatedPullRequestReviewContributionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLCreatedPullRequestReviewContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLCreatedPullRequestReviewContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLCreatedPullRequestReviewContributionEdge = {
  __typename?: 'CreatedPullRequestReviewContributionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLCreatedPullRequestReviewContribution>;
};

/** Represents the contribution a user made on GitHub by creating a repository. */
export type GQLCreatedRepositoryContribution = GQLContribution & {
  __typename?: 'CreatedRepositoryContribution';
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The repository that was created. */
  repository: GQLRepository;
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['URI'];
  /** The user who made this contribution. */
  user: GQLUser;
};

/** The connection type for CreatedRepositoryContribution. */
export type GQLCreatedRepositoryContributionConnection = {
  __typename?: 'CreatedRepositoryContributionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLCreatedRepositoryContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLCreatedRepositoryContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLCreatedRepositoryContributionEdge = {
  __typename?: 'CreatedRepositoryContributionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLCreatedRepositoryContribution>;
};

/** Represents either a repository the viewer can access or a restricted contribution. */
export type GQLCreatedRepositoryOrRestrictedContribution = GQLCreatedRepositoryContribution | GQLRestrictedContribution;

/** Represents a mention made by one issue or pull request to another. */
export type GQLCrossReferencedEvent = GQLNode & GQLUniformResourceLocatable & {
  __typename?: 'CrossReferencedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars['Boolean'];
  /** Identifies when the reference was made. */
  referencedAt: Scalars['DateTime'];
  /** The HTTP path for this pull request. */
  resourcePath: Scalars['URI'];
  /** Issue or pull request that made the reference. */
  source: GQLReferencedSubject;
  /** Issue or pull request to which the reference was made. */
  target: GQLReferencedSubject;
  /** The HTTP URL for this pull request. */
  url: Scalars['URI'];
  /** Checks if the target will be closed when the source is merged. */
  willCloseTarget: Scalars['Boolean'];
};



/** Autogenerated input type of DeclineTopicSuggestion */
export type GQLDeclineTopicSuggestionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The name of the suggested topic. */
  name: Scalars['String'];
  /** The reason why the suggested topic is declined. */
  reason: GQLTopicSuggestionDeclineReason;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of DeclineTopicSuggestion */
export type GQLDeclineTopicSuggestionPayload = {
  __typename?: 'DeclineTopicSuggestionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The declined topic. */
  topic?: Maybe<GQLTopic>;
};

/** The possible default permissions for repositories. */
export enum GQLDefaultRepositoryPermissionField {
  /** Can read, write, and administrate repos by default */
  Admin = 'ADMIN',
  /** No access */
  None = 'NONE',
  /** Can read repos by default */
  Read = 'READ',
  /** Can read and write repos by default */
  Write = 'WRITE'
}

/** Entities that can be deleted. */
export type GQLDeletable = {
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
};

/** Autogenerated input type of DeleteBranchProtectionRule */
export type GQLDeleteBranchProtectionRuleInput = {
  /** The global relay id of the branch protection rule to be deleted. */
  branchProtectionRuleId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of DeleteBranchProtectionRule */
export type GQLDeleteBranchProtectionRulePayload = {
  __typename?: 'DeleteBranchProtectionRulePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteDeployment */
export type GQLDeleteDeploymentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the deployment to be deleted. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteDeployment */
export type GQLDeleteDeploymentPayload = {
  __typename?: 'DeleteDeploymentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteIpAllowListEntry */
export type GQLDeleteIpAllowListEntryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the IP allow list entry to delete. */
  ipAllowListEntryId: Scalars['ID'];
};

/** Autogenerated return type of DeleteIpAllowListEntry */
export type GQLDeleteIpAllowListEntryPayload = {
  __typename?: 'DeleteIpAllowListEntryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The IP allow list entry that was deleted. */
  ipAllowListEntry?: Maybe<GQLIpAllowListEntry>;
};

/** Autogenerated input type of DeleteIssueComment */
export type GQLDeleteIssueCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the comment to delete. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteIssueComment */
export type GQLDeleteIssueCommentPayload = {
  __typename?: 'DeleteIssueCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteIssue */
export type GQLDeleteIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the issue to delete. */
  issueId: Scalars['ID'];
};

/** Autogenerated return type of DeleteIssue */
export type GQLDeleteIssuePayload = {
  __typename?: 'DeleteIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The repository the issue belonged to */
  repository?: Maybe<GQLRepository>;
};

/** Autogenerated input type of DeleteLabel */
export type GQLDeleteLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the label to be deleted. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteLabel */
export type GQLDeleteLabelPayload = {
  __typename?: 'DeleteLabelPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeletePackageVersion */
export type GQLDeletePackageVersionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the package version to be deleted. */
  packageVersionId: Scalars['ID'];
};

/** Autogenerated return type of DeletePackageVersion */
export type GQLDeletePackageVersionPayload = {
  __typename?: 'DeletePackageVersionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Whether or not the operation succeeded. */
  success?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated input type of DeleteProjectCard */
export type GQLDeleteProjectCardInput = {
  /** The id of the card to delete. */
  cardId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of DeleteProjectCard */
export type GQLDeleteProjectCardPayload = {
  __typename?: 'DeleteProjectCardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The column the deleted card was in. */
  column?: Maybe<GQLProjectColumn>;
  /** The deleted card ID. */
  deletedCardId?: Maybe<Scalars['ID']>;
};

/** Autogenerated input type of DeleteProjectColumn */
export type GQLDeleteProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The id of the column to delete. */
  columnId: Scalars['ID'];
};

/** Autogenerated return type of DeleteProjectColumn */
export type GQLDeleteProjectColumnPayload = {
  __typename?: 'DeleteProjectColumnPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The deleted column ID. */
  deletedColumnId?: Maybe<Scalars['ID']>;
  /** The project the deleted column was in. */
  project?: Maybe<GQLProject>;
};

/** Autogenerated input type of DeleteProject */
export type GQLDeleteProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Project ID to update. */
  projectId: Scalars['ID'];
};

/** Autogenerated return type of DeleteProject */
export type GQLDeleteProjectPayload = {
  __typename?: 'DeleteProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The repository or organization the project was removed from. */
  owner?: Maybe<GQLProjectOwner>;
};

/** Autogenerated input type of DeletePullRequestReviewComment */
export type GQLDeletePullRequestReviewCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the comment to delete. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeletePullRequestReviewComment */
export type GQLDeletePullRequestReviewCommentPayload = {
  __typename?: 'DeletePullRequestReviewCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request review the deleted comment belonged to. */
  pullRequestReview?: Maybe<GQLPullRequestReview>;
};

/** Autogenerated input type of DeletePullRequestReview */
export type GQLDeletePullRequestReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the pull request review to delete. */
  pullRequestReviewId: Scalars['ID'];
};

/** Autogenerated return type of DeletePullRequestReview */
export type GQLDeletePullRequestReviewPayload = {
  __typename?: 'DeletePullRequestReviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The deleted pull request review. */
  pullRequestReview?: Maybe<GQLPullRequestReview>;
};

/** Autogenerated input type of DeleteRef */
export type GQLDeleteRefInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the Ref to be deleted. */
  refId: Scalars['ID'];
};

/** Autogenerated return type of DeleteRef */
export type GQLDeleteRefPayload = {
  __typename?: 'DeleteRefPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteTeamDiscussionComment */
export type GQLDeleteTeamDiscussionCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the comment to delete. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteTeamDiscussionComment */
export type GQLDeleteTeamDiscussionCommentPayload = {
  __typename?: 'DeleteTeamDiscussionCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteTeamDiscussion */
export type GQLDeleteTeamDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The discussion ID to delete. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteTeamDiscussion */
export type GQLDeleteTeamDiscussionPayload = {
  __typename?: 'DeleteTeamDiscussionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Represents a 'demilestoned' event on a given issue or pull request. */
export type GQLDemilestonedEvent = GQLNode & {
  __typename?: 'DemilestonedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Identifies the milestone title associated with the 'demilestoned' event. */
  milestoneTitle: Scalars['String'];
  /** Object referenced by event. */
  subject: GQLMilestoneItem;
};

/** A dependency manifest entry */
export type GQLDependencyGraphDependency = {
  __typename?: 'DependencyGraphDependency';
  /** Does the dependency itself have dependencies? */
  hasDependencies: Scalars['Boolean'];
  /** The dependency package manager */
  packageManager?: Maybe<Scalars['String']>;
  /** The required package name */
  packageName: Scalars['String'];
  /** The repository containing the package */
  repository?: Maybe<GQLRepository>;
  /** The dependency version requirements */
  requirements: Scalars['String'];
};

/** The connection type for DependencyGraphDependency. */
export type GQLDependencyGraphDependencyConnection = {
  __typename?: 'DependencyGraphDependencyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLDependencyGraphDependencyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLDependencyGraphDependency>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLDependencyGraphDependencyEdge = {
  __typename?: 'DependencyGraphDependencyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLDependencyGraphDependency>;
};

/** Dependency manifest for a repository */
export type GQLDependencyGraphManifest = GQLNode & {
  __typename?: 'DependencyGraphManifest';
  /** Path to view the manifest file blob */
  blobPath: Scalars['String'];
  /** A list of manifest dependencies */
  dependencies?: Maybe<GQLDependencyGraphDependencyConnection>;
  /** The number of dependencies listed in the manifest */
  dependenciesCount?: Maybe<Scalars['Int']>;
  /** Is the manifest too big to parse? */
  exceedsMaxSize: Scalars['Boolean'];
  /** Fully qualified manifest filename */
  filename: Scalars['String'];
  id: Scalars['ID'];
  /** Were we able to parse the manifest? */
  parseable: Scalars['Boolean'];
  /** The repository containing the manifest */
  repository: GQLRepository;
};


/** Dependency manifest for a repository */
export type GQLDependencyGraphManifestDependenciesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** The connection type for DependencyGraphManifest. */
export type GQLDependencyGraphManifestConnection = {
  __typename?: 'DependencyGraphManifestConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLDependencyGraphManifestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLDependencyGraphManifest>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLDependencyGraphManifestEdge = {
  __typename?: 'DependencyGraphManifestEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLDependencyGraphManifest>;
};

/** A repository deploy key. */
export type GQLDeployKey = GQLNode & {
  __typename?: 'DeployKey';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** The deploy key. */
  key: Scalars['String'];
  /** Whether or not the deploy key is read only. */
  readOnly: Scalars['Boolean'];
  /** The deploy key title. */
  title: Scalars['String'];
  /** Whether or not the deploy key has been verified. */
  verified: Scalars['Boolean'];
};

/** The connection type for DeployKey. */
export type GQLDeployKeyConnection = {
  __typename?: 'DeployKeyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLDeployKeyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLDeployKey>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLDeployKeyEdge = {
  __typename?: 'DeployKeyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLDeployKey>;
};

/** Represents a 'deployed' event on a given pull request. */
export type GQLDeployedEvent = GQLNode & {
  __typename?: 'DeployedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The deployment associated with the 'deployed' event. */
  deployment: GQLDeployment;
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: GQLPullRequest;
  /** The ref associated with the 'deployed' event. */
  ref?: Maybe<GQLRef>;
};

/** Represents triggered deployment instance. */
export type GQLDeployment = GQLNode & {
  __typename?: 'Deployment';
  /** Identifies the commit sha of the deployment. */
  commit?: Maybe<GQLCommit>;
  /** Identifies the oid of the deployment commit, even if the commit has been deleted. */
  commitOid: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the actor who triggered the deployment. */
  creator: GQLActor;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The deployment description. */
  description?: Maybe<Scalars['String']>;
  /** The latest environment to which this deployment was made. */
  environment?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The latest environment to which this deployment was made. */
  latestEnvironment?: Maybe<Scalars['String']>;
  /** The latest status of this deployment. */
  latestStatus?: Maybe<GQLDeploymentStatus>;
  /** The original environment to which this deployment was made. */
  originalEnvironment?: Maybe<Scalars['String']>;
  /** Extra information that a deployment system might need. */
  payload?: Maybe<Scalars['String']>;
  /** Identifies the Ref of the deployment, if the deployment was created by ref. */
  ref?: Maybe<GQLRef>;
  /** Identifies the repository associated with the deployment. */
  repository: GQLRepository;
  /** The current state of the deployment. */
  state?: Maybe<GQLDeploymentState>;
  /** A list of statuses associated with the deployment. */
  statuses?: Maybe<GQLDeploymentStatusConnection>;
  /** The deployment task. */
  task?: Maybe<Scalars['String']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};


/** Represents triggered deployment instance. */
export type GQLDeploymentStatusesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** The connection type for Deployment. */
export type GQLDeploymentConnection = {
  __typename?: 'DeploymentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLDeploymentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLDeployment>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLDeploymentEdge = {
  __typename?: 'DeploymentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLDeployment>;
};

/** Represents a 'deployment_environment_changed' event on a given pull request. */
export type GQLDeploymentEnvironmentChangedEvent = GQLNode & {
  __typename?: 'DeploymentEnvironmentChangedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The deployment status that updated the deployment environment. */
  deploymentStatus: GQLDeploymentStatus;
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: GQLPullRequest;
};

/** Ordering options for deployment connections */
export type GQLDeploymentOrder = {
  /** The ordering direction. */
  direction: GQLOrderDirection;
  /** The field to order deployments by. */
  field: GQLDeploymentOrderField;
};

/** Properties by which deployment connections can be ordered. */
export enum GQLDeploymentOrderField {
  /** Order collection by creation time */
  CreatedAt = 'CREATED_AT'
}

/** The possible states in which a deployment can be. */
export enum GQLDeploymentState {
  /** The pending deployment was not updated after 30 minutes. */
  Abandoned = 'ABANDONED',
  /** The deployment is currently active. */
  Active = 'ACTIVE',
  /** An inactive transient deployment. */
  Destroyed = 'DESTROYED',
  /** The deployment experienced an error. */
  Error = 'ERROR',
  /** The deployment has failed. */
  Failure = 'FAILURE',
  /** The deployment is inactive. */
  Inactive = 'INACTIVE',
  /** The deployment is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The deployment is pending. */
  Pending = 'PENDING',
  /** The deployment has queued */
  Queued = 'QUEUED'
}

/** Describes the status of a given deployment attempt. */
export type GQLDeploymentStatus = GQLNode & {
  __typename?: 'DeploymentStatus';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the actor who triggered the deployment. */
  creator: GQLActor;
  /** Identifies the deployment associated with status. */
  deployment: GQLDeployment;
  /** Identifies the description of the deployment. */
  description?: Maybe<Scalars['String']>;
  /** Identifies the environment of the deployment at the time of this deployment status */
  environment?: Maybe<Scalars['String']>;
  /** Identifies the environment URL of the deployment. */
  environmentUrl?: Maybe<Scalars['URI']>;
  id: Scalars['ID'];
  /** Identifies the log URL of the deployment. */
  logUrl?: Maybe<Scalars['URI']>;
  /** Identifies the current state of the deployment. */
  state: GQLDeploymentStatusState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** The connection type for DeploymentStatus. */
export type GQLDeploymentStatusConnection = {
  __typename?: 'DeploymentStatusConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLDeploymentStatusEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLDeploymentStatus>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLDeploymentStatusEdge = {
  __typename?: 'DeploymentStatusEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLDeploymentStatus>;
};

/** The possible states for a deployment status. */
export enum GQLDeploymentStatusState {
  /** The deployment experienced an error. */
  Error = 'ERROR',
  /** The deployment has failed. */
  Failure = 'FAILURE',
  /** The deployment is inactive. */
  Inactive = 'INACTIVE',
  /** The deployment is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The deployment is pending. */
  Pending = 'PENDING',
  /** The deployment is queued */
  Queued = 'QUEUED',
  /** The deployment was successful. */
  Success = 'SUCCESS'
}

/** The possible sides of a diff. */
export enum GQLDiffSide {
  /** The left side of the diff. */
  Left = 'LEFT',
  /** The right side of the diff. */
  Right = 'RIGHT'
}

/** Represents a 'disconnected' event on a given issue or pull request. */
export type GQLDisconnectedEvent = GQLNode & {
  __typename?: 'DisconnectedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars['Boolean'];
  /** Issue or pull request from which the issue was disconnected. */
  source: GQLReferencedSubject;
  /** Issue or pull request which was disconnected. */
  subject: GQLReferencedSubject;
};

/** Autogenerated input type of DismissPullRequestReview */
export type GQLDismissPullRequestReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The contents of the pull request review dismissal message. */
  message: Scalars['String'];
  /** The Node ID of the pull request review to modify. */
  pullRequestReviewId: Scalars['ID'];
};

/** Autogenerated return type of DismissPullRequestReview */
export type GQLDismissPullRequestReviewPayload = {
  __typename?: 'DismissPullRequestReviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The dismissed pull request review. */
  pullRequestReview?: Maybe<GQLPullRequestReview>;
};

/** Specifies a review comment to be left with a Pull Request Review. */
export type GQLDraftPullRequestReviewComment = {
  /** Body of the comment to leave. */
  body: Scalars['String'];
  /** Path to the file being commented on. */
  path: Scalars['String'];
  /** Position in the file to leave a comment on. */
  position: Scalars['Int'];
};

/** Specifies a review comment thread to be left with a Pull Request Review. */
export type GQLDraftPullRequestReviewThread = {
  /** Body of the comment to leave. */
  body: Scalars['String'];
  /** The line of the blob to which the thread refers. The end of the line range for multi-line comments. */
  line: Scalars['Int'];
  /** Path to the file being commented on. */
  path: Scalars['String'];
  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */
  side?: Maybe<GQLDiffSide>;
  /** The first line of the range to which the comment refers. */
  startLine?: Maybe<Scalars['Int']>;
  /** The side of the diff on which the start line resides. */
  startSide?: Maybe<GQLDiffSide>;
};

/** An account to manage multiple organizations with consolidated policy and billing. */
export type GQLEnterprise = GQLNode & {
  __typename?: 'Enterprise';
  /** A URL pointing to the enterprise's public avatar. */
  avatarUrl: Scalars['URI'];
  /** Enterprise billing information visible to enterprise billing managers. */
  billingInfo?: Maybe<GQLEnterpriseBillingInfo>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The description of the enterprise. */
  description?: Maybe<Scalars['String']>;
  /** The description of the enterprise as HTML. */
  descriptionHTML: Scalars['HTML'];
  id: Scalars['ID'];
  /** The location of the enterprise. */
  location?: Maybe<Scalars['String']>;
  /** A list of users who are members of this enterprise. */
  members: GQLEnterpriseMemberConnection;
  /** The name of the enterprise. */
  name: Scalars['String'];
  /** A list of organizations that belong to this enterprise. */
  organizations: GQLOrganizationConnection;
  /** Enterprise information only visible to enterprise owners. */
  ownerInfo?: Maybe<GQLEnterpriseOwnerInfo>;
  /** The HTTP path for this enterprise. */
  resourcePath: Scalars['URI'];
  /** The URL-friendly identifier for the enterprise. */
  slug: Scalars['String'];
  /** The HTTP URL for this enterprise. */
  url: Scalars['URI'];
  /** A list of user accounts on this enterprise. */
  userAccounts: GQLEnterpriseUserAccountConnection;
  /** Is the current viewer an admin of this enterprise? */
  viewerIsAdmin: Scalars['Boolean'];
  /** The URL of the enterprise website. */
  websiteUrl?: Maybe<Scalars['URI']>;
};


/** An account to manage multiple organizations with consolidated policy and billing. */
export type GQLEnterpriseAvatarUrlArgs = {
  size?: Maybe<Scalars['Int']>;
};


/** An account to manage multiple organizations with consolidated policy and billing. */
export type GQLEnterpriseMembersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  deployment?: Maybe<GQLEnterpriseUserDeployment>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLEnterpriseMemberOrder>;
  organizationLogins?: Maybe<Array<Scalars['String']>>;
  query?: Maybe<Scalars['String']>;
  role?: Maybe<GQLEnterpriseUserAccountMembershipRole>;
};


/** An account to manage multiple organizations with consolidated policy and billing. */
export type GQLEnterpriseOrganizationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLOrganizationOrder>;
  query?: Maybe<Scalars['String']>;
};


/** An account to manage multiple organizations with consolidated policy and billing. */
export type GQLEnterpriseUserAccountsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** The connection type for User. */
export type GQLEnterpriseAdministratorConnection = {
  __typename?: 'EnterpriseAdministratorConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLEnterpriseAdministratorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLUser>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** A User who is an administrator of an enterprise. */
export type GQLEnterpriseAdministratorEdge = {
  __typename?: 'EnterpriseAdministratorEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLUser>;
  /** The role of the administrator. */
  role: GQLEnterpriseAdministratorRole;
};

/** An invitation for a user to become an owner or billing manager of an enterprise. */
export type GQLEnterpriseAdministratorInvitation = GQLNode & {
  __typename?: 'EnterpriseAdministratorInvitation';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The email of the person who was invited to the enterprise. */
  email?: Maybe<Scalars['String']>;
  /** The enterprise the invitation is for. */
  enterprise: GQLEnterprise;
  id: Scalars['ID'];
  /** The user who was invited to the enterprise. */
  invitee?: Maybe<GQLUser>;
  /** The user who created the invitation. */
  inviter?: Maybe<GQLUser>;
  /** The invitee's pending role in the enterprise (owner or billing_manager). */
  role: GQLEnterpriseAdministratorRole;
};

/** The connection type for EnterpriseAdministratorInvitation. */
export type GQLEnterpriseAdministratorInvitationConnection = {
  __typename?: 'EnterpriseAdministratorInvitationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLEnterpriseAdministratorInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLEnterpriseAdministratorInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLEnterpriseAdministratorInvitationEdge = {
  __typename?: 'EnterpriseAdministratorInvitationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLEnterpriseAdministratorInvitation>;
};

/** Ordering options for enterprise administrator invitation connections */
export type GQLEnterpriseAdministratorInvitationOrder = {
  /** The ordering direction. */
  direction: GQLOrderDirection;
  /** The field to order enterprise administrator invitations by. */
  field: GQLEnterpriseAdministratorInvitationOrderField;
};

/** Properties by which enterprise administrator invitation connections can be ordered. */
export enum GQLEnterpriseAdministratorInvitationOrderField {
  /** Order enterprise administrator member invitations by creation time */
  CreatedAt = 'CREATED_AT'
}

/** The possible administrator roles in an enterprise account. */
export enum GQLEnterpriseAdministratorRole {
  /** Represents a billing manager of the enterprise account. */
  BillingManager = 'BILLING_MANAGER',
  /** Represents an owner of the enterprise account. */
  Owner = 'OWNER'
}

/** Metadata for an audit entry containing enterprise account information. */
export type GQLEnterpriseAuditEntryData = {
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']>;
};

/** Enterprise billing information visible to enterprise billing managers and owners. */
export type GQLEnterpriseBillingInfo = {
  __typename?: 'EnterpriseBillingInfo';
  /** The number of licenseable users/emails across the enterprise. */
  allLicensableUsersCount: Scalars['Int'];
  /** The number of data packs used by all organizations owned by the enterprise. */
  assetPacks: Scalars['Int'];
  /**
   * The number of available seats across all owned organizations based on the unique number of billable users.
   * @deprecated `availableSeats` will be replaced with `totalAvailableLicenses` to provide more clarity on the value being returned Use EnterpriseBillingInfo.totalAvailableLicenses instead. Removal on 2020-01-01 UTC.
   */
  availableSeats: Scalars['Int'];
  /** The bandwidth quota in GB for all organizations owned by the enterprise. */
  bandwidthQuota: Scalars['Float'];
  /** The bandwidth usage in GB for all organizations owned by the enterprise. */
  bandwidthUsage: Scalars['Float'];
  /** The bandwidth usage as a percentage of the bandwidth quota. */
  bandwidthUsagePercentage: Scalars['Int'];
  /**
   * The total seats across all organizations owned by the enterprise.
   * @deprecated `seats` will be replaced with `totalLicenses` to provide more clarity on the value being returned Use EnterpriseBillingInfo.totalLicenses instead. Removal on 2020-01-01 UTC.
   */
  seats: Scalars['Int'];
  /** The storage quota in GB for all organizations owned by the enterprise. */
  storageQuota: Scalars['Float'];
  /** The storage usage in GB for all organizations owned by the enterprise. */
  storageUsage: Scalars['Float'];
  /** The storage usage as a percentage of the storage quota. */
  storageUsagePercentage: Scalars['Int'];
  /** The number of available licenses across all owned organizations based on the unique number of billable users. */
  totalAvailableLicenses: Scalars['Int'];
  /** The total number of licenses allocated. */
  totalLicenses: Scalars['Int'];
};

/** The possible values for the enterprise default repository permission setting. */
export enum GQLEnterpriseDefaultRepositoryPermissionSettingValue {
  /** Organization members will be able to clone, pull, push, and add new collaborators to all organization repositories. */
  Admin = 'ADMIN',
  /** Organization members will only be able to clone and pull public repositories. */
  None = 'NONE',
  /** Organizations in the enterprise choose default repository permissions for their members. */
  NoPolicy = 'NO_POLICY',
  /** Organization members will be able to clone and pull all organization repositories. */
  Read = 'READ',
  /** Organization members will be able to clone, pull, and push all organization repositories. */
  Write = 'WRITE'
}

/** The possible values for an enabled/disabled enterprise setting. */
export enum GQLEnterpriseEnabledDisabledSettingValue {
  /** The setting is disabled for organizations in the enterprise. */
  Disabled = 'DISABLED',
  /** The setting is enabled for organizations in the enterprise. */
  Enabled = 'ENABLED',
  /** There is no policy set for organizations in the enterprise. */
  NoPolicy = 'NO_POLICY'
}

/** The possible values for an enabled/no policy enterprise setting. */
export enum GQLEnterpriseEnabledSettingValue {
  /** The setting is enabled for organizations in the enterprise. */
  Enabled = 'ENABLED',
  /** There is no policy set for organizations in the enterprise. */
  NoPolicy = 'NO_POLICY'
}

/** An identity provider configured to provision identities for an enterprise. */
export type GQLEnterpriseIdentityProvider = GQLNode & {
  __typename?: 'EnterpriseIdentityProvider';
  /** The digest algorithm used to sign SAML requests for the identity provider. */
  digestMethod?: Maybe<GQLSamlDigestAlgorithm>;
  /** The enterprise this identity provider belongs to. */
  enterprise?: Maybe<GQLEnterprise>;
  /** ExternalIdentities provisioned by this identity provider. */
  externalIdentities: GQLExternalIdentityConnection;
  id: Scalars['ID'];
  /** The x509 certificate used by the identity provider to sign assertions and responses. */
  idpCertificate?: Maybe<Scalars['X509Certificate']>;
  /** The Issuer Entity ID for the SAML identity provider. */
  issuer?: Maybe<Scalars['String']>;
  /** Recovery codes that can be used by admins to access the enterprise if the identity provider is unavailable. */
  recoveryCodes?: Maybe<Array<Scalars['String']>>;
  /** The signature algorithm used to sign SAML requests for the identity provider. */
  signatureMethod?: Maybe<GQLSamlSignatureAlgorithm>;
  /** The URL endpoint for the identity provider's SAML SSO. */
  ssoUrl?: Maybe<Scalars['URI']>;
};


/** An identity provider configured to provision identities for an enterprise. */
export type GQLEnterpriseIdentityProviderExternalIdentitiesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** An object that is a member of an enterprise. */
export type GQLEnterpriseMember = GQLEnterpriseUserAccount | GQLUser;

/** The connection type for EnterpriseMember. */
export type GQLEnterpriseMemberConnection = {
  __typename?: 'EnterpriseMemberConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLEnterpriseMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLEnterpriseMember>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** A User who is a member of an enterprise through one or more organizations. */
export type GQLEnterpriseMemberEdge = {
  __typename?: 'EnterpriseMemberEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** Whether the user does not have a license for the enterprise. */
  isUnlicensed: Scalars['Boolean'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLEnterpriseMember>;
};

/** Ordering options for enterprise member connections. */
export type GQLEnterpriseMemberOrder = {
  /** The ordering direction. */
  direction: GQLOrderDirection;
  /** The field to order enterprise members by. */
  field: GQLEnterpriseMemberOrderField;
};

/** Properties by which enterprise member connections can be ordered. */
export enum GQLEnterpriseMemberOrderField {
  /** Order enterprise members by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order enterprise members by login */
  Login = 'LOGIN'
}

/** The possible values for the enterprise members can create repositories setting. */
export enum GQLEnterpriseMembersCanCreateRepositoriesSettingValue {
  /** Members will be able to create public and private repositories. */
  All = 'ALL',
  /** Members will not be able to create public or private repositories. */
  Disabled = 'DISABLED',
  /** Organization administrators choose whether to allow members to create repositories. */
  NoPolicy = 'NO_POLICY',
  /** Members will be able to create only private repositories. */
  Private = 'PRIVATE',
  /** Members will be able to create only public repositories. */
  Public = 'PUBLIC'
}

/** The possible values for the members can make purchases setting. */
export enum GQLEnterpriseMembersCanMakePurchasesSettingValue {
  /** The setting is disabled for organizations in the enterprise. */
  Disabled = 'DISABLED',
  /** The setting is enabled for organizations in the enterprise. */
  Enabled = 'ENABLED'
}

/** The connection type for Organization. */
export type GQLEnterpriseOrganizationMembershipConnection = {
  __typename?: 'EnterpriseOrganizationMembershipConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLEnterpriseOrganizationMembershipEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLOrganization>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An enterprise organization that a user is a member of. */
export type GQLEnterpriseOrganizationMembershipEdge = {
  __typename?: 'EnterpriseOrganizationMembershipEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLOrganization>;
  /** The role of the user in the enterprise membership. */
  role: GQLEnterpriseUserAccountMembershipRole;
};

/** The connection type for User. */
export type GQLEnterpriseOutsideCollaboratorConnection = {
  __typename?: 'EnterpriseOutsideCollaboratorConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLEnterpriseOutsideCollaboratorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLUser>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** A User who is an outside collaborator of an enterprise through one or more organizations. */
export type GQLEnterpriseOutsideCollaboratorEdge = {
  __typename?: 'EnterpriseOutsideCollaboratorEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** Whether the outside collaborator does not have a license for the enterprise. */
  isUnlicensed: Scalars['Boolean'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLUser>;
  /** The enterprise organization repositories this user is a member of. */
  repositories: GQLEnterpriseRepositoryInfoConnection;
};


/** A User who is an outside collaborator of an enterprise through one or more organizations. */
export type GQLEnterpriseOutsideCollaboratorEdgeRepositoriesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLRepositoryOrder>;
};

/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfo = {
  __typename?: 'EnterpriseOwnerInfo';
  /** A list of enterprise organizations configured with the provided action execution capabilities setting value. */
  actionExecutionCapabilitySettingOrganizations: GQLOrganizationConnection;
  /** A list of all of the administrators for this enterprise. */
  admins: GQLEnterpriseAdministratorConnection;
  /** A list of users in the enterprise who currently have two-factor authentication disabled. */
  affiliatedUsersWithTwoFactorDisabled: GQLUserConnection;
  /** Whether or not affiliated users with two-factor authentication disabled exist in the enterprise. */
  affiliatedUsersWithTwoFactorDisabledExist: Scalars['Boolean'];
  /** The setting value for whether private repository forking is enabled for repositories in organizations in this enterprise. */
  allowPrivateRepositoryForkingSetting: GQLEnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided private repository forking setting value. */
  allowPrivateRepositoryForkingSettingOrganizations: GQLOrganizationConnection;
  /** The setting value for base repository permissions for organizations in this enterprise. */
  defaultRepositoryPermissionSetting: GQLEnterpriseDefaultRepositoryPermissionSettingValue;
  /** A list of enterprise organizations configured with the provided default repository permission. */
  defaultRepositoryPermissionSettingOrganizations: GQLOrganizationConnection;
  /** Enterprise Server installations owned by the enterprise. */
  enterpriseServerInstallations: GQLEnterpriseServerInstallationConnection;
  /** The setting value for whether the enterprise has an IP allow list enabled. */
  ipAllowListEnabledSetting: GQLIpAllowListEnabledSettingValue;
  /** The IP addresses that are allowed to access resources owned by the enterprise. */
  ipAllowListEntries: GQLIpAllowListEntryConnection;
  /** Whether or not the default repository permission is currently being updated. */
  isUpdatingDefaultRepositoryPermission: Scalars['Boolean'];
  /** Whether the two-factor authentication requirement is currently being enforced. */
  isUpdatingTwoFactorRequirement: Scalars['Boolean'];
  /**
   * The setting value for whether organization members with admin permissions on a
   * repository can change repository visibility.
   */
  membersCanChangeRepositoryVisibilitySetting: GQLEnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided can change repository visibility setting value. */
  membersCanChangeRepositoryVisibilitySettingOrganizations: GQLOrganizationConnection;
  /** The setting value for whether members of organizations in the enterprise can create internal repositories. */
  membersCanCreateInternalRepositoriesSetting?: Maybe<Scalars['Boolean']>;
  /** The setting value for whether members of organizations in the enterprise can create private repositories. */
  membersCanCreatePrivateRepositoriesSetting?: Maybe<Scalars['Boolean']>;
  /** The setting value for whether members of organizations in the enterprise can create public repositories. */
  membersCanCreatePublicRepositoriesSetting?: Maybe<Scalars['Boolean']>;
  /** The setting value for whether members of organizations in the enterprise can create repositories. */
  membersCanCreateRepositoriesSetting?: Maybe<GQLEnterpriseMembersCanCreateRepositoriesSettingValue>;
  /** A list of enterprise organizations configured with the provided repository creation setting value. */
  membersCanCreateRepositoriesSettingOrganizations: GQLOrganizationConnection;
  /** The setting value for whether members with admin permissions for repositories can delete issues. */
  membersCanDeleteIssuesSetting: GQLEnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can delete issues setting value. */
  membersCanDeleteIssuesSettingOrganizations: GQLOrganizationConnection;
  /** The setting value for whether members with admin permissions for repositories can delete or transfer repositories. */
  membersCanDeleteRepositoriesSetting: GQLEnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can delete repositories setting value. */
  membersCanDeleteRepositoriesSettingOrganizations: GQLOrganizationConnection;
  /** The setting value for whether members of organizations in the enterprise can invite outside collaborators. */
  membersCanInviteCollaboratorsSetting: GQLEnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can invite collaborators setting value. */
  membersCanInviteCollaboratorsSettingOrganizations: GQLOrganizationConnection;
  /** Indicates whether members of this enterprise's organizations can purchase additional services for those organizations. */
  membersCanMakePurchasesSetting: GQLEnterpriseMembersCanMakePurchasesSettingValue;
  /** The setting value for whether members with admin permissions for repositories can update protected branches. */
  membersCanUpdateProtectedBranchesSetting: GQLEnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can update protected branches setting value. */
  membersCanUpdateProtectedBranchesSettingOrganizations: GQLOrganizationConnection;
  /** The setting value for whether members can view dependency insights. */
  membersCanViewDependencyInsightsSetting: GQLEnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can view dependency insights setting value. */
  membersCanViewDependencyInsightsSettingOrganizations: GQLOrganizationConnection;
  /** The setting value for whether organization projects are enabled for organizations in this enterprise. */
  organizationProjectsSetting: GQLEnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided organization projects setting value. */
  organizationProjectsSettingOrganizations: GQLOrganizationConnection;
  /** A list of outside collaborators across the repositories in the enterprise. */
  outsideCollaborators: GQLEnterpriseOutsideCollaboratorConnection;
  /** A list of pending administrator invitations for the enterprise. */
  pendingAdminInvitations: GQLEnterpriseAdministratorInvitationConnection;
  /** A list of pending collaborator invitations across the repositories in the enterprise. */
  pendingCollaboratorInvitations: GQLRepositoryInvitationConnection;
  /**
   * A list of pending collaborators across the repositories in the enterprise.
   * @deprecated Repository invitations can now be associated with an email, not only an invitee. Use the `pendingCollaboratorInvitations` field instead. Removal on 2020-10-01 UTC.
   */
  pendingCollaborators: GQLEnterprisePendingCollaboratorConnection;
  /** A list of pending member invitations for organizations in the enterprise. */
  pendingMemberInvitations: GQLEnterprisePendingMemberInvitationConnection;
  /** The setting value for whether repository projects are enabled in this enterprise. */
  repositoryProjectsSetting: GQLEnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided repository projects setting value. */
  repositoryProjectsSettingOrganizations: GQLOrganizationConnection;
  /** The SAML Identity Provider for the enterprise. */
  samlIdentityProvider?: Maybe<GQLEnterpriseIdentityProvider>;
  /** A list of enterprise organizations configured with the SAML single sign-on setting value. */
  samlIdentityProviderSettingOrganizations: GQLOrganizationConnection;
  /** The setting value for whether team discussions are enabled for organizations in this enterprise. */
  teamDiscussionsSetting: GQLEnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided team discussions setting value. */
  teamDiscussionsSettingOrganizations: GQLOrganizationConnection;
  /** The setting value for whether the enterprise requires two-factor authentication for its organizations and users. */
  twoFactorRequiredSetting: GQLEnterpriseEnabledSettingValue;
  /** A list of enterprise organizations configured with the two-factor authentication setting value. */
  twoFactorRequiredSettingOrganizations: GQLOrganizationConnection;
};


/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfoActionExecutionCapabilitySettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLOrganizationOrder>;
};


/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfoAdminsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLEnterpriseMemberOrder>;
  query?: Maybe<Scalars['String']>;
  role?: Maybe<GQLEnterpriseAdministratorRole>;
};


/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfoAffiliatedUsersWithTwoFactorDisabledArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfoAllowPrivateRepositoryForkingSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLOrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfoDefaultRepositoryPermissionSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLOrganizationOrder>;
  value: GQLDefaultRepositoryPermissionField;
};


/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfoEnterpriseServerInstallationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  connectedOnly?: Maybe<Scalars['Boolean']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLEnterpriseServerInstallationOrder>;
};


/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfoIpAllowListEntriesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLIpAllowListEntryOrder>;
};


/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfoMembersCanChangeRepositoryVisibilitySettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLOrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfoMembersCanCreateRepositoriesSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLOrganizationOrder>;
  value: GQLOrganizationMembersCanCreateRepositoriesSettingValue;
};


/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfoMembersCanDeleteIssuesSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLOrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfoMembersCanDeleteRepositoriesSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLOrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfoMembersCanInviteCollaboratorsSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLOrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfoMembersCanUpdateProtectedBranchesSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLOrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfoMembersCanViewDependencyInsightsSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLOrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfoOrganizationProjectsSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLOrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfoOutsideCollaboratorsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  login?: Maybe<Scalars['String']>;
  orderBy?: Maybe<GQLEnterpriseMemberOrder>;
  query?: Maybe<Scalars['String']>;
  visibility?: Maybe<GQLRepositoryVisibility>;
};


/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfoPendingAdminInvitationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLEnterpriseAdministratorInvitationOrder>;
  query?: Maybe<Scalars['String']>;
  role?: Maybe<GQLEnterpriseAdministratorRole>;
};


/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfoPendingCollaboratorInvitationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLRepositoryInvitationOrder>;
  query?: Maybe<Scalars['String']>;
};


/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfoPendingCollaboratorsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLRepositoryInvitationOrder>;
  query?: Maybe<Scalars['String']>;
};


/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfoPendingMemberInvitationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  query?: Maybe<Scalars['String']>;
};


/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfoRepositoryProjectsSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLOrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfoSamlIdentityProviderSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLOrganizationOrder>;
  value: GQLIdentityProviderConfigurationState;
};


/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfoTeamDiscussionsSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLOrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type GQLEnterpriseOwnerInfoTwoFactorRequiredSettingOrganizationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLOrganizationOrder>;
  value: Scalars['Boolean'];
};

/** The connection type for User. */
export type GQLEnterprisePendingCollaboratorConnection = {
  __typename?: 'EnterprisePendingCollaboratorConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLEnterprisePendingCollaboratorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLUser>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** A user with an invitation to be a collaborator on a repository owned by an organization in an enterprise. */
export type GQLEnterprisePendingCollaboratorEdge = {
  __typename?: 'EnterprisePendingCollaboratorEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** Whether the invited collaborator does not have a license for the enterprise. */
  isUnlicensed: Scalars['Boolean'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLUser>;
  /** The enterprise organization repositories this user is a member of. */
  repositories: GQLEnterpriseRepositoryInfoConnection;
};


/** A user with an invitation to be a collaborator on a repository owned by an organization in an enterprise. */
export type GQLEnterprisePendingCollaboratorEdgeRepositoriesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLRepositoryOrder>;
};

/** The connection type for OrganizationInvitation. */
export type GQLEnterprisePendingMemberInvitationConnection = {
  __typename?: 'EnterprisePendingMemberInvitationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLEnterprisePendingMemberInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLOrganizationInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
  /** Identifies the total count of unique users in the connection. */
  totalUniqueUserCount: Scalars['Int'];
};

/** An invitation to be a member in an enterprise organization. */
export type GQLEnterprisePendingMemberInvitationEdge = {
  __typename?: 'EnterprisePendingMemberInvitationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** Whether the invitation has a license for the enterprise. */
  isUnlicensed: Scalars['Boolean'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLOrganizationInvitation>;
};

/** A subset of repository information queryable from an enterprise. */
export type GQLEnterpriseRepositoryInfo = GQLNode & {
  __typename?: 'EnterpriseRepositoryInfo';
  id: Scalars['ID'];
  /** Identifies if the repository is private. */
  isPrivate: Scalars['Boolean'];
  /** The repository's name. */
  name: Scalars['String'];
  /** The repository's name with owner. */
  nameWithOwner: Scalars['String'];
};

/** The connection type for EnterpriseRepositoryInfo. */
export type GQLEnterpriseRepositoryInfoConnection = {
  __typename?: 'EnterpriseRepositoryInfoConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLEnterpriseRepositoryInfoEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLEnterpriseRepositoryInfo>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLEnterpriseRepositoryInfoEdge = {
  __typename?: 'EnterpriseRepositoryInfoEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLEnterpriseRepositoryInfo>;
};

/** An Enterprise Server installation. */
export type GQLEnterpriseServerInstallation = GQLNode & {
  __typename?: 'EnterpriseServerInstallation';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The customer name to which the Enterprise Server installation belongs. */
  customerName: Scalars['String'];
  /** The host name of the Enterprise Server installation. */
  hostName: Scalars['String'];
  id: Scalars['ID'];
  /** Whether or not the installation is connected to an Enterprise Server installation via GitHub Connect. */
  isConnected: Scalars['Boolean'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** User accounts on this Enterprise Server installation. */
  userAccounts: GQLEnterpriseServerUserAccountConnection;
  /** User accounts uploads for the Enterprise Server installation. */
  userAccountsUploads: GQLEnterpriseServerUserAccountsUploadConnection;
};


/** An Enterprise Server installation. */
export type GQLEnterpriseServerInstallationUserAccountsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLEnterpriseServerUserAccountOrder>;
};


/** An Enterprise Server installation. */
export type GQLEnterpriseServerInstallationUserAccountsUploadsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLEnterpriseServerUserAccountsUploadOrder>;
};

/** The connection type for EnterpriseServerInstallation. */
export type GQLEnterpriseServerInstallationConnection = {
  __typename?: 'EnterpriseServerInstallationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLEnterpriseServerInstallationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLEnterpriseServerInstallation>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLEnterpriseServerInstallationEdge = {
  __typename?: 'EnterpriseServerInstallationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLEnterpriseServerInstallation>;
};

/** Ordering options for Enterprise Server installation connections. */
export type GQLEnterpriseServerInstallationOrder = {
  /** The ordering direction. */
  direction: GQLOrderDirection;
  /** The field to order Enterprise Server installations by. */
  field: GQLEnterpriseServerInstallationOrderField;
};

/** Properties by which Enterprise Server installation connections can be ordered. */
export enum GQLEnterpriseServerInstallationOrderField {
  /** Order Enterprise Server installations by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order Enterprise Server installations by customer name */
  CustomerName = 'CUSTOMER_NAME',
  /** Order Enterprise Server installations by host name */
  HostName = 'HOST_NAME'
}

/** A user account on an Enterprise Server installation. */
export type GQLEnterpriseServerUserAccount = GQLNode & {
  __typename?: 'EnterpriseServerUserAccount';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** User emails belonging to this user account. */
  emails: GQLEnterpriseServerUserAccountEmailConnection;
  /** The Enterprise Server installation on which this user account exists. */
  enterpriseServerInstallation: GQLEnterpriseServerInstallation;
  id: Scalars['ID'];
  /** Whether the user account is a site administrator on the Enterprise Server installation. */
  isSiteAdmin: Scalars['Boolean'];
  /** The login of the user account on the Enterprise Server installation. */
  login: Scalars['String'];
  /** The profile name of the user account on the Enterprise Server installation. */
  profileName?: Maybe<Scalars['String']>;
  /** The date and time when the user account was created on the Enterprise Server installation. */
  remoteCreatedAt: Scalars['DateTime'];
  /** The ID of the user account on the Enterprise Server installation. */
  remoteUserId: Scalars['Int'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};


/** A user account on an Enterprise Server installation. */
export type GQLEnterpriseServerUserAccountEmailsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLEnterpriseServerUserAccountEmailOrder>;
};

/** The connection type for EnterpriseServerUserAccount. */
export type GQLEnterpriseServerUserAccountConnection = {
  __typename?: 'EnterpriseServerUserAccountConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLEnterpriseServerUserAccountEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLEnterpriseServerUserAccount>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLEnterpriseServerUserAccountEdge = {
  __typename?: 'EnterpriseServerUserAccountEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLEnterpriseServerUserAccount>;
};

/** An email belonging to a user account on an Enterprise Server installation. */
export type GQLEnterpriseServerUserAccountEmail = GQLNode & {
  __typename?: 'EnterpriseServerUserAccountEmail';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The email address. */
  email: Scalars['String'];
  id: Scalars['ID'];
  /** Indicates whether this is the primary email of the associated user account. */
  isPrimary: Scalars['Boolean'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The user account to which the email belongs. */
  userAccount: GQLEnterpriseServerUserAccount;
};

/** The connection type for EnterpriseServerUserAccountEmail. */
export type GQLEnterpriseServerUserAccountEmailConnection = {
  __typename?: 'EnterpriseServerUserAccountEmailConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLEnterpriseServerUserAccountEmailEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLEnterpriseServerUserAccountEmail>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLEnterpriseServerUserAccountEmailEdge = {
  __typename?: 'EnterpriseServerUserAccountEmailEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLEnterpriseServerUserAccountEmail>;
};

/** Ordering options for Enterprise Server user account email connections. */
export type GQLEnterpriseServerUserAccountEmailOrder = {
  /** The ordering direction. */
  direction: GQLOrderDirection;
  /** The field to order emails by. */
  field: GQLEnterpriseServerUserAccountEmailOrderField;
};

/** Properties by which Enterprise Server user account email connections can be ordered. */
export enum GQLEnterpriseServerUserAccountEmailOrderField {
  /** Order emails by email */
  Email = 'EMAIL'
}

/** Ordering options for Enterprise Server user account connections. */
export type GQLEnterpriseServerUserAccountOrder = {
  /** The ordering direction. */
  direction: GQLOrderDirection;
  /** The field to order user accounts by. */
  field: GQLEnterpriseServerUserAccountOrderField;
};

/** Properties by which Enterprise Server user account connections can be ordered. */
export enum GQLEnterpriseServerUserAccountOrderField {
  /** Order user accounts by login */
  Login = 'LOGIN',
  /** Order user accounts by creation time on the Enterprise Server installation */
  RemoteCreatedAt = 'REMOTE_CREATED_AT'
}

/** A user accounts upload from an Enterprise Server installation. */
export type GQLEnterpriseServerUserAccountsUpload = GQLNode & {
  __typename?: 'EnterpriseServerUserAccountsUpload';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The enterprise to which this upload belongs. */
  enterprise: GQLEnterprise;
  /** The Enterprise Server installation for which this upload was generated. */
  enterpriseServerInstallation: GQLEnterpriseServerInstallation;
  id: Scalars['ID'];
  /** The name of the file uploaded. */
  name: Scalars['String'];
  /** The synchronization state of the upload */
  syncState: GQLEnterpriseServerUserAccountsUploadSyncState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** The connection type for EnterpriseServerUserAccountsUpload. */
export type GQLEnterpriseServerUserAccountsUploadConnection = {
  __typename?: 'EnterpriseServerUserAccountsUploadConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLEnterpriseServerUserAccountsUploadEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLEnterpriseServerUserAccountsUpload>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLEnterpriseServerUserAccountsUploadEdge = {
  __typename?: 'EnterpriseServerUserAccountsUploadEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLEnterpriseServerUserAccountsUpload>;
};

/** Ordering options for Enterprise Server user accounts upload connections. */
export type GQLEnterpriseServerUserAccountsUploadOrder = {
  /** The ordering direction. */
  direction: GQLOrderDirection;
  /** The field to order user accounts uploads by. */
  field: GQLEnterpriseServerUserAccountsUploadOrderField;
};

/** Properties by which Enterprise Server user accounts upload connections can be ordered. */
export enum GQLEnterpriseServerUserAccountsUploadOrderField {
  /** Order user accounts uploads by creation time */
  CreatedAt = 'CREATED_AT'
}

/** Synchronization state of the Enterprise Server user accounts upload */
export enum GQLEnterpriseServerUserAccountsUploadSyncState {
  /** The synchronization of the upload failed. */
  Failure = 'FAILURE',
  /** The synchronization of the upload is pending. */
  Pending = 'PENDING',
  /** The synchronization of the upload succeeded. */
  Success = 'SUCCESS'
}

/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
export type GQLEnterpriseUserAccount = GQLActor & GQLNode & {
  __typename?: 'EnterpriseUserAccount';
  /** A URL pointing to the enterprise user account's public avatar. */
  avatarUrl: Scalars['URI'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The enterprise in which this user account exists. */
  enterprise: GQLEnterprise;
  id: Scalars['ID'];
  /** An identifier for the enterprise user account, a login or email address */
  login: Scalars['String'];
  /** The name of the enterprise user account */
  name?: Maybe<Scalars['String']>;
  /** A list of enterprise organizations this user is a member of. */
  organizations: GQLEnterpriseOrganizationMembershipConnection;
  /** The HTTP path for this user. */
  resourcePath: Scalars['URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this user. */
  url: Scalars['URI'];
  /** The user within the enterprise. */
  user?: Maybe<GQLUser>;
};


/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
export type GQLEnterpriseUserAccountAvatarUrlArgs = {
  size?: Maybe<Scalars['Int']>;
};


/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
export type GQLEnterpriseUserAccountOrganizationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLOrganizationOrder>;
  query?: Maybe<Scalars['String']>;
  role?: Maybe<GQLEnterpriseUserAccountMembershipRole>;
};

/** The connection type for EnterpriseUserAccount. */
export type GQLEnterpriseUserAccountConnection = {
  __typename?: 'EnterpriseUserAccountConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLEnterpriseUserAccountEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLEnterpriseUserAccount>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLEnterpriseUserAccountEdge = {
  __typename?: 'EnterpriseUserAccountEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLEnterpriseUserAccount>;
};

/** The possible roles for enterprise membership. */
export enum GQLEnterpriseUserAccountMembershipRole {
  /** The user is a member of the enterprise membership. */
  Member = 'MEMBER',
  /** The user is an owner of the enterprise membership. */
  Owner = 'OWNER'
}

/** The possible GitHub Enterprise deployments where this user can exist. */
export enum GQLEnterpriseUserDeployment {
  /** The user is part of a GitHub Enterprise Cloud deployment. */
  Cloud = 'CLOUD',
  /** The user is part of a GitHub Enterprise Server deployment. */
  Server = 'SERVER'
}

/** An external identity provisioned by SAML SSO or SCIM. */
export type GQLExternalIdentity = GQLNode & {
  __typename?: 'ExternalIdentity';
  /** The GUID for this identity */
  guid: Scalars['String'];
  id: Scalars['ID'];
  /** Organization invitation for this SCIM-provisioned external identity */
  organizationInvitation?: Maybe<GQLOrganizationInvitation>;
  /** SAML Identity attributes */
  samlIdentity?: Maybe<GQLExternalIdentitySamlAttributes>;
  /** SCIM Identity attributes */
  scimIdentity?: Maybe<GQLExternalIdentityScimAttributes>;
  /** User linked to this external identity. Will be NULL if this identity has not been claimed by an organization member. */
  user?: Maybe<GQLUser>;
};

/** The connection type for ExternalIdentity. */
export type GQLExternalIdentityConnection = {
  __typename?: 'ExternalIdentityConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLExternalIdentityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLExternalIdentity>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLExternalIdentityEdge = {
  __typename?: 'ExternalIdentityEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLExternalIdentity>;
};

/** SAML attributes for the External Identity */
export type GQLExternalIdentitySamlAttributes = {
  __typename?: 'ExternalIdentitySamlAttributes';
  /** The NameID of the SAML identity */
  nameId?: Maybe<Scalars['String']>;
};

/** SCIM attributes for the External Identity */
export type GQLExternalIdentityScimAttributes = {
  __typename?: 'ExternalIdentityScimAttributes';
  /** The userName of the SCIM identity */
  username?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of FollowUser */
export type GQLFollowUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** ID of the user to follow. */
  userId: Scalars['ID'];
};

/** Autogenerated return type of FollowUser */
export type GQLFollowUserPayload = {
  __typename?: 'FollowUserPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The user that was followed. */
  user?: Maybe<GQLUser>;
};

/** The connection type for User. */
export type GQLFollowerConnection = {
  __typename?: 'FollowerConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLUserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLUser>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** The connection type for User. */
export type GQLFollowingConnection = {
  __typename?: 'FollowingConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLUserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLUser>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** A funding platform link for a repository. */
export type GQLFundingLink = {
  __typename?: 'FundingLink';
  /** The funding platform this link is for. */
  platform: GQLFundingPlatform;
  /** The configured URL for this funding link. */
  url: Scalars['URI'];
};

/** The possible funding platforms for repository funding links. */
export enum GQLFundingPlatform {
  /** Community Bridge funding platform. */
  CommunityBridge = 'COMMUNITY_BRIDGE',
  /** Custom funding platform. */
  Custom = 'CUSTOM',
  /** GitHub funding platform. */
  Github = 'GITHUB',
  /** IssueHunt funding platform. */
  Issuehunt = 'ISSUEHUNT',
  /** Ko-fi funding platform. */
  KoFi = 'KO_FI',
  /** Liberapay funding platform. */
  Liberapay = 'LIBERAPAY',
  /** Open Collective funding platform. */
  OpenCollective = 'OPEN_COLLECTIVE',
  /** Otechie funding platform. */
  Otechie = 'OTECHIE',
  /** Patreon funding platform. */
  Patreon = 'PATREON',
  /** Tidelift funding platform. */
  Tidelift = 'TIDELIFT'
}

/** A generic hovercard context with a message and icon */
export type GQLGenericHovercardContext = GQLHovercardContext & {
  __typename?: 'GenericHovercardContext';
  /** A string describing this context */
  message: Scalars['String'];
  /** An octicon to accompany this context */
  octicon: Scalars['String'];
};

/** A Gist. */
export type GQLGist = GQLNode & GQLStarrable & GQLUniformResourceLocatable & {
  __typename?: 'Gist';
  /** A list of comments associated with the gist */
  comments: GQLGistCommentConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The gist description. */
  description?: Maybe<Scalars['String']>;
  /** The files in this gist. */
  files?: Maybe<Array<Maybe<GQLGistFile>>>;
  /** A list of forks associated with the gist */
  forks: GQLGistConnection;
  id: Scalars['ID'];
  /** Identifies if the gist is a fork. */
  isFork: Scalars['Boolean'];
  /** Whether the gist is public or not. */
  isPublic: Scalars['Boolean'];
  /** The gist name. */
  name: Scalars['String'];
  /** The gist owner. */
  owner?: Maybe<GQLRepositoryOwner>;
  /** Identifies when the gist was last pushed to. */
  pushedAt?: Maybe<Scalars['DateTime']>;
  /** The HTML path to this resource. */
  resourcePath: Scalars['URI'];
  /** A list of users who have starred this starrable. */
  stargazers: GQLStargazerConnection;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this Gist. */
  url: Scalars['URI'];
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean'];
};


/** A Gist. */
export type GQLGistCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A Gist. */
export type GQLGistFilesArgs = {
  limit?: Maybe<Scalars['Int']>;
  oid?: Maybe<Scalars['GitObjectID']>;
};


/** A Gist. */
export type GQLGistForksArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLGistOrder>;
};


/** A Gist. */
export type GQLGistStargazersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLStarOrder>;
};

/** Represents a comment on an Gist. */
export type GQLGistComment = GQLComment & GQLDeletable & GQLMinimizable & GQLNode & GQLUpdatable & GQLUpdatableComment & {
  __typename?: 'GistComment';
  /** The actor who authored the comment. */
  author?: Maybe<GQLActor>;
  /** Author's association with the gist. */
  authorAssociation: GQLCommentAuthorAssociation;
  /** Identifies the comment body. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The actor who edited the comment. */
  editor?: Maybe<GQLActor>;
  /** The associated gist. */
  gist: GQLGist;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** Returns why the comment was minimized. */
  minimizedReason?: Maybe<Scalars['String']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<GQLUserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<GQLCommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
};


/** Represents a comment on an Gist. */
export type GQLGistCommentUserContentEditsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** The connection type for GistComment. */
export type GQLGistCommentConnection = {
  __typename?: 'GistCommentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLGistCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLGistComment>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLGistCommentEdge = {
  __typename?: 'GistCommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLGistComment>;
};

/** The connection type for Gist. */
export type GQLGistConnection = {
  __typename?: 'GistConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLGistEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLGist>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLGistEdge = {
  __typename?: 'GistEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLGist>;
};

/** A file in a gist. */
export type GQLGistFile = {
  __typename?: 'GistFile';
  /** The file name encoded to remove characters that are invalid in URL paths. */
  encodedName?: Maybe<Scalars['String']>;
  /** The gist file encoding. */
  encoding?: Maybe<Scalars['String']>;
  /** The file extension from the file name. */
  extension?: Maybe<Scalars['String']>;
  /** Indicates if this file is an image. */
  isImage: Scalars['Boolean'];
  /** Whether the file's contents were truncated. */
  isTruncated: Scalars['Boolean'];
  /** The programming language this file is written in. */
  language?: Maybe<GQLLanguage>;
  /** The gist file name. */
  name?: Maybe<Scalars['String']>;
  /** The gist file size in bytes. */
  size?: Maybe<Scalars['Int']>;
  /** UTF8 text data or null if the file is binary */
  text?: Maybe<Scalars['String']>;
};


/** A file in a gist. */
export type GQLGistFileTextArgs = {
  truncate?: Maybe<Scalars['Int']>;
};

/** Ordering options for gist connections */
export type GQLGistOrder = {
  /** The ordering direction. */
  direction: GQLOrderDirection;
  /** The field to order repositories by. */
  field: GQLGistOrderField;
};

/** Properties by which gist connections can be ordered. */
export enum GQLGistOrderField {
  /** Order gists by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order gists by push time */
  PushedAt = 'PUSHED_AT',
  /** Order gists by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** The privacy of a Gist */
export enum GQLGistPrivacy {
  /** Gists that are public and secret */
  All = 'ALL',
  /** Public */
  Public = 'PUBLIC',
  /** Secret */
  Secret = 'SECRET'
}

/** Represents an actor in a Git commit (ie. an author or committer). */
export type GQLGitActor = {
  __typename?: 'GitActor';
  /** A URL pointing to the author's public avatar. */
  avatarUrl: Scalars['URI'];
  /** The timestamp of the Git action (authoring or committing). */
  date?: Maybe<Scalars['GitTimestamp']>;
  /** The email in the Git commit. */
  email?: Maybe<Scalars['String']>;
  /** The name in the Git commit. */
  name?: Maybe<Scalars['String']>;
  /** The GitHub user corresponding to the email field. Null if no such user exists. */
  user?: Maybe<GQLUser>;
};


/** Represents an actor in a Git commit (ie. an author or committer). */
export type GQLGitActorAvatarUrlArgs = {
  size?: Maybe<Scalars['Int']>;
};

/** Represents information about the GitHub instance. */
export type GQLGitHubMetadata = {
  __typename?: 'GitHubMetadata';
  /** Returns a String that's a SHA of `github-services` */
  gitHubServicesSha: Scalars['GitObjectID'];
  /** IP addresses that users connect to for git operations */
  gitIpAddresses?: Maybe<Array<Scalars['String']>>;
  /** IP addresses that service hooks are sent from */
  hookIpAddresses?: Maybe<Array<Scalars['String']>>;
  /** IP addresses that the importer connects from */
  importerIpAddresses?: Maybe<Array<Scalars['String']>>;
  /** Whether or not users are verified */
  isPasswordAuthenticationVerifiable: Scalars['Boolean'];
  /** IP addresses for GitHub Pages' A records */
  pagesIpAddresses?: Maybe<Array<Scalars['String']>>;
};

/** Represents a Git object. */
export type GQLGitObject = {
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String'];
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['URI'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['URI'];
  id: Scalars['ID'];
  /** The Git object ID */
  oid: Scalars['GitObjectID'];
  /** The Repository the Git object belongs to */
  repository: GQLRepository;
};




/** Information about a signature (GPG or S/MIME) on a Commit or Tag. */
export type GQLGitSignature = {
  /** Email used to sign this object. */
  email: Scalars['String'];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean'];
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String'];
  /** ASCII-armored signature header from object. */
  signature: Scalars['String'];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<GQLUser>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: GQLGitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean'];
};

/** The state of a Git signature. */
export enum GQLGitSignatureState {
  /** The signing certificate or its chain could not be verified */
  BadCert = 'BAD_CERT',
  /** Invalid email used for signing */
  BadEmail = 'BAD_EMAIL',
  /** Signing key expired */
  ExpiredKey = 'EXPIRED_KEY',
  /** Internal error - the GPG verification service misbehaved */
  GpgverifyError = 'GPGVERIFY_ERROR',
  /** Internal error - the GPG verification service is unavailable at the moment */
  GpgverifyUnavailable = 'GPGVERIFY_UNAVAILABLE',
  /** Invalid signature */
  Invalid = 'INVALID',
  /** Malformed signature */
  MalformedSig = 'MALFORMED_SIG',
  /** The usage flags for the key that signed this don't allow signing */
  NotSigningKey = 'NOT_SIGNING_KEY',
  /** Email used for signing not known to GitHub */
  NoUser = 'NO_USER',
  /** Valid siganture, though certificate revocation check failed */
  OcspError = 'OCSP_ERROR',
  /** Valid signature, pending certificate revocation checking */
  OcspPending = 'OCSP_PENDING',
  /** One or more certificates in chain has been revoked */
  OcspRevoked = 'OCSP_REVOKED',
  /** Key used for signing not known to GitHub */
  UnknownKey = 'UNKNOWN_KEY',
  /** Unknown signature type */
  UnknownSigType = 'UNKNOWN_SIG_TYPE',
  /** Unsigned */
  Unsigned = 'UNSIGNED',
  /** Email used for signing unverified on GitHub */
  UnverifiedEmail = 'UNVERIFIED_EMAIL',
  /** Valid signature and verified by GitHub */
  Valid = 'VALID'
}


/** Represents a GPG signature on a Commit or Tag. */
export type GQLGpgSignature = GQLGitSignature & {
  __typename?: 'GpgSignature';
  /** Email used to sign this object. */
  email: Scalars['String'];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean'];
  /** Hex-encoded ID of the key that signed this object. */
  keyId?: Maybe<Scalars['String']>;
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String'];
  /** ASCII-armored signature header from object. */
  signature: Scalars['String'];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<GQLUser>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: GQLGitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean'];
};


/** Represents a 'head_ref_deleted' event on a given pull request. */
export type GQLHeadRefDeletedEvent = GQLNode & {
  __typename?: 'HeadRefDeletedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the Ref associated with the `head_ref_deleted` event. */
  headRef?: Maybe<GQLRef>;
  /** Identifies the name of the Ref associated with the `head_ref_deleted` event. */
  headRefName: Scalars['String'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: GQLPullRequest;
};

/** Represents a 'head_ref_force_pushed' event on a given pull request. */
export type GQLHeadRefForcePushedEvent = GQLNode & {
  __typename?: 'HeadRefForcePushedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the after commit SHA for the 'head_ref_force_pushed' event. */
  afterCommit?: Maybe<GQLCommit>;
  /** Identifies the before commit SHA for the 'head_ref_force_pushed' event. */
  beforeCommit?: Maybe<GQLCommit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: GQLPullRequest;
  /** Identifies the fully qualified ref name for the 'head_ref_force_pushed' event. */
  ref?: Maybe<GQLRef>;
};

/** Represents a 'head_ref_restored' event on a given pull request. */
export type GQLHeadRefRestoredEvent = GQLNode & {
  __typename?: 'HeadRefRestoredEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: GQLPullRequest;
};

/** Detail needed to display a hovercard for a user */
export type GQLHovercard = {
  __typename?: 'Hovercard';
  /** Each of the contexts for this hovercard */
  contexts: Array<GQLHovercardContext>;
};

/** An individual line of a hovercard */
export type GQLHovercardContext = {
  /** A string describing this context */
  message: Scalars['String'];
  /** An octicon to accompany this context */
  octicon: Scalars['String'];
};

/** The possible states in which authentication can be configured with an identity provider. */
export enum GQLIdentityProviderConfigurationState {
  /** Authentication with an identity provider is configured but not enforced. */
  Configured = 'CONFIGURED',
  /** Authentication with an identity provider is configured and enforced. */
  Enforced = 'ENFORCED',
  /** Authentication with an identity provider is not configured. */
  Unconfigured = 'UNCONFIGURED'
}

/** Autogenerated input type of ImportProject */
export type GQLImportProjectInput = {
  /** The description of Project. */
  body?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A list of columns containing issues and pull requests. */
  columnImports: Array<GQLProjectColumnImport>;
  /** The name of Project. */
  name: Scalars['String'];
  /** The name of the Organization or User to create the Project under. */
  ownerName: Scalars['String'];
  /** Whether the Project is public or not. */
  public?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated return type of ImportProject */
export type GQLImportProjectPayload = {
  __typename?: 'ImportProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new Project! */
  project?: Maybe<GQLProject>;
};

/** Autogenerated input type of InviteEnterpriseAdmin */
export type GQLInviteEnterpriseAdminInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The email of the person to invite as an administrator. */
  email?: Maybe<Scalars['String']>;
  /** The ID of the enterprise to which you want to invite an administrator. */
  enterpriseId: Scalars['ID'];
  /** The login of a user to invite as an administrator. */
  invitee?: Maybe<Scalars['String']>;
  /** The role of the administrator. */
  role?: Maybe<GQLEnterpriseAdministratorRole>;
};

/** Autogenerated return type of InviteEnterpriseAdmin */
export type GQLInviteEnterpriseAdminPayload = {
  __typename?: 'InviteEnterpriseAdminPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The created enterprise administrator invitation. */
  invitation?: Maybe<GQLEnterpriseAdministratorInvitation>;
};

/** The possible values for the IP allow list enabled setting. */
export enum GQLIpAllowListEnabledSettingValue {
  /** The setting is disabled for the owner. */
  Disabled = 'DISABLED',
  /** The setting is enabled for the owner. */
  Enabled = 'ENABLED'
}

/** An IP address or range of addresses that is allowed to access an owner's resources. */
export type GQLIpAllowListEntry = GQLNode & {
  __typename?: 'IpAllowListEntry';
  /** A single IP address or range of IP addresses in CIDR notation. */
  allowListValue: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Whether the entry is currently active. */
  isActive: Scalars['Boolean'];
  /** The name of the IP allow list entry. */
  name?: Maybe<Scalars['String']>;
  /** The owner of the IP allow list entry. */
  owner: GQLIpAllowListOwner;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** The connection type for IpAllowListEntry. */
export type GQLIpAllowListEntryConnection = {
  __typename?: 'IpAllowListEntryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLIpAllowListEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLIpAllowListEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLIpAllowListEntryEdge = {
  __typename?: 'IpAllowListEntryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLIpAllowListEntry>;
};

/** Ordering options for IP allow list entry connections. */
export type GQLIpAllowListEntryOrder = {
  /** The ordering direction. */
  direction: GQLOrderDirection;
  /** The field to order IP allow list entries by. */
  field: GQLIpAllowListEntryOrderField;
};

/** Properties by which IP allow list entry connections can be ordered. */
export enum GQLIpAllowListEntryOrderField {
  /** Order IP allow list entries by the allow list value. */
  AllowListValue = 'ALLOW_LIST_VALUE',
  /** Order IP allow list entries by creation time. */
  CreatedAt = 'CREATED_AT'
}

/** Types that can own an IP allow list. */
export type GQLIpAllowListOwner = GQLEnterprise | GQLOrganization;

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type GQLIssue = GQLAssignable & GQLClosable & GQLComment & GQLLabelable & GQLLockable & GQLNode & GQLReactable & GQLRepositoryNode & GQLSubscribable & GQLUniformResourceLocatable & GQLUpdatable & GQLUpdatableComment & {
  __typename?: 'Issue';
  /** Reason that the conversation was locked. */
  activeLockReason?: Maybe<GQLLockReason>;
  /** A list of Users assigned to this object. */
  assignees: GQLUserConnection;
  /** The actor who authored the comment. */
  author?: Maybe<GQLActor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: GQLCommentAuthorAssociation;
  /** Identifies the body of the issue. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML'];
  /** Identifies the body of the issue rendered to text. */
  bodyText: Scalars['String'];
  /** `true` if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']>;
  /** A list of comments associated with the Issue. */
  comments: GQLIssueCommentConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The actor who edited the comment. */
  editor?: Maybe<GQLActor>;
  /** The hovercard information for this issue */
  hovercard: GQLHovercard;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** A list of labels associated with the object. */
  labels?: Maybe<GQLLabelConnection>;
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** `true` if the object is locked */
  locked: Scalars['Boolean'];
  /** Identifies the milestone associated with the issue. */
  milestone?: Maybe<GQLMilestone>;
  /** Identifies the issue number. */
  number: Scalars['Int'];
  /** A list of Users that are participating in the Issue conversation. */
  participants: GQLUserConnection;
  /** List of project cards associated with this issue. */
  projectCards: GQLProjectCardConnection;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<GQLReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: GQLReactionConnection;
  /** The repository associated with this node. */
  repository: GQLRepository;
  /** The HTTP path for this issue */
  resourcePath: Scalars['URI'];
  /** Identifies the state of the issue. */
  state: GQLIssueState;
  /**
   * A list of events, comments, commits, etc. associated with the issue.
   * @deprecated `timeline` will be removed Use Issue.timelineItems instead. Removal on 2020-10-01 UTC.
   */
  timeline: GQLIssueTimelineConnection;
  /** A list of events, comments, commits, etc. associated with the issue. */
  timelineItems: GQLIssueTimelineItemsConnection;
  /** Identifies the issue title. */
  title: Scalars['String'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this issue */
  url: Scalars['URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<GQLUserContentEditConnection>;
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<GQLCommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<GQLSubscriptionState>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type GQLIssueAssigneesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type GQLIssueCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type GQLIssueHovercardArgs = {
  includeNotificationContexts?: Maybe<Scalars['Boolean']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type GQLIssueLabelsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLLabelOrder>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type GQLIssueParticipantsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type GQLIssueProjectCardsArgs = {
  after?: Maybe<Scalars['String']>;
  archivedStates?: Maybe<Array<Maybe<GQLProjectCardArchivedState>>>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type GQLIssueReactionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  content?: Maybe<GQLReactionContent>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLReactionOrder>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type GQLIssueTimelineArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  since?: Maybe<Scalars['DateTime']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type GQLIssueTimelineItemsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  itemTypes?: Maybe<Array<GQLIssueTimelineItemsItemType>>;
  last?: Maybe<Scalars['Int']>;
  since?: Maybe<Scalars['DateTime']>;
  skip?: Maybe<Scalars['Int']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type GQLIssueUserContentEditsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** Represents a comment on an Issue. */
export type GQLIssueComment = GQLComment & GQLDeletable & GQLMinimizable & GQLNode & GQLReactable & GQLRepositoryNode & GQLUpdatable & GQLUpdatableComment & {
  __typename?: 'IssueComment';
  /** The actor who authored the comment. */
  author?: Maybe<GQLActor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: GQLCommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The actor who edited the comment. */
  editor?: Maybe<GQLActor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean'];
  /** Identifies the issue associated with the comment. */
  issue: GQLIssue;
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** Returns why the comment was minimized. */
  minimizedReason?: Maybe<Scalars['String']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /**
   * Returns the pull request associated with the comment, if this comment was made on a
   * pull request.
   */
  pullRequest?: Maybe<GQLPullRequest>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<GQLReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: GQLReactionConnection;
  /** The repository associated with this node. */
  repository: GQLRepository;
  /** The HTTP path for this issue comment */
  resourcePath: Scalars['URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this issue comment */
  url: Scalars['URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<GQLUserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<GQLCommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
};


/** Represents a comment on an Issue. */
export type GQLIssueCommentReactionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  content?: Maybe<GQLReactionContent>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLReactionOrder>;
};


/** Represents a comment on an Issue. */
export type GQLIssueCommentUserContentEditsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** The connection type for IssueComment. */
export type GQLIssueCommentConnection = {
  __typename?: 'IssueCommentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLIssueCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLIssueComment>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLIssueCommentEdge = {
  __typename?: 'IssueCommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLIssueComment>;
};

/** The connection type for Issue. */
export type GQLIssueConnection = {
  __typename?: 'IssueConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLIssueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLIssue>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** This aggregates issues opened by a user within one repository. */
export type GQLIssueContributionsByRepository = {
  __typename?: 'IssueContributionsByRepository';
  /** The issue contributions. */
  contributions: GQLCreatedIssueContributionConnection;
  /** The repository in which the issues were opened. */
  repository: GQLRepository;
};


/** This aggregates issues opened by a user within one repository. */
export type GQLIssueContributionsByRepositoryContributionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLContributionOrder>;
};

/** An edge in a connection. */
export type GQLIssueEdge = {
  __typename?: 'IssueEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLIssue>;
};

/** Ways in which to filter lists of issues. */
export type GQLIssueFilters = {
  /**
   * List issues assigned to given name. Pass in `null` for issues with no assigned
   * user, and `*` for issues assigned to any user.
   */
  assignee?: Maybe<Scalars['String']>;
  /** List issues created by given name. */
  createdBy?: Maybe<Scalars['String']>;
  /** List issues where the list of label names exist on the issue. */
  labels?: Maybe<Array<Scalars['String']>>;
  /** List issues where the given name is mentioned in the issue. */
  mentioned?: Maybe<Scalars['String']>;
  /**
   * List issues by given milestone argument. If an string representation of an
   * integer is passed, it should refer to a milestone by its number field. Pass in
   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.
   */
  milestone?: Maybe<Scalars['String']>;
  /** List issues that have been updated at or after the given date. */
  since?: Maybe<Scalars['DateTime']>;
  /** List issues filtered by the list of states given. */
  states?: Maybe<Array<GQLIssueState>>;
  /** List issues subscribed to by viewer. */
  viewerSubscribed?: Maybe<Scalars['Boolean']>;
};

/** Used for return value of Repository.issueOrPullRequest. */
export type GQLIssueOrPullRequest = GQLIssue | GQLPullRequest;

/** Ways in which lists of issues can be ordered upon return. */
export type GQLIssueOrder = {
  /** The direction in which to order issues by the specified field. */
  direction: GQLOrderDirection;
  /** The field in which to order issues by. */
  field: GQLIssueOrderField;
};

/** Properties by which issue connections can be ordered. */
export enum GQLIssueOrderField {
  /** Order issues by comment count */
  Comments = 'COMMENTS',
  /** Order issues by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order issues by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** The possible states of an issue. */
export enum GQLIssueState {
  /** An issue that has been closed */
  Closed = 'CLOSED',
  /** An issue that is still open */
  Open = 'OPEN'
}

/** The connection type for IssueTimelineItem. */
export type GQLIssueTimelineConnection = {
  __typename?: 'IssueTimelineConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLIssueTimelineItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLIssueTimelineItem>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An item in an issue timeline */
export type GQLIssueTimelineItem = GQLAssignedEvent | GQLClosedEvent | GQLCommit | GQLCrossReferencedEvent | GQLDemilestonedEvent | GQLIssueComment | GQLLabeledEvent | GQLLockedEvent | GQLMilestonedEvent | GQLReferencedEvent | GQLRenamedTitleEvent | GQLReopenedEvent | GQLSubscribedEvent | GQLTransferredEvent | GQLUnassignedEvent | GQLUnlabeledEvent | GQLUnlockedEvent | GQLUnsubscribedEvent | GQLUserBlockedEvent;

/** An edge in a connection. */
export type GQLIssueTimelineItemEdge = {
  __typename?: 'IssueTimelineItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLIssueTimelineItem>;
};

/** An item in an issue timeline */
export type GQLIssueTimelineItems = GQLAddedToProjectEvent | GQLAssignedEvent | GQLClosedEvent | GQLCommentDeletedEvent | GQLConnectedEvent | GQLConvertedNoteToIssueEvent | GQLCrossReferencedEvent | GQLDemilestonedEvent | GQLDisconnectedEvent | GQLIssueComment | GQLLabeledEvent | GQLLockedEvent | GQLMarkedAsDuplicateEvent | GQLMentionedEvent | GQLMilestonedEvent | GQLMovedColumnsInProjectEvent | GQLPinnedEvent | GQLReferencedEvent | GQLRemovedFromProjectEvent | GQLRenamedTitleEvent | GQLReopenedEvent | GQLSubscribedEvent | GQLTransferredEvent | GQLUnassignedEvent | GQLUnlabeledEvent | GQLUnlockedEvent | GQLUnmarkedAsDuplicateEvent | GQLUnpinnedEvent | GQLUnsubscribedEvent | GQLUserBlockedEvent;

/** The connection type for IssueTimelineItems. */
export type GQLIssueTimelineItemsConnection = {
  __typename?: 'IssueTimelineItemsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLIssueTimelineItemsEdge>>>;
  /** Identifies the count of items after applying `before` and `after` filters. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLIssueTimelineItems>>>;
  /** Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
  /** Identifies the date and time when the timeline was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** An edge in a connection. */
export type GQLIssueTimelineItemsEdge = {
  __typename?: 'IssueTimelineItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLIssueTimelineItems>;
};

/** The possible item types found in a timeline. */
export enum GQLIssueTimelineItemsItemType {
  /** Represents a 'added_to_project' event on a given issue or pull request. */
  AddedToProjectEvent = 'ADDED_TO_PROJECT_EVENT',
  /** Represents an 'assigned' event on any assignable object. */
  AssignedEvent = 'ASSIGNED_EVENT',
  /** Represents a 'closed' event on any `Closable`. */
  ClosedEvent = 'CLOSED_EVENT',
  /** Represents a 'comment_deleted' event on a given issue or pull request. */
  CommentDeletedEvent = 'COMMENT_DELETED_EVENT',
  /** Represents a 'connected' event on a given issue or pull request. */
  ConnectedEvent = 'CONNECTED_EVENT',
  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
  ConvertedNoteToIssueEvent = 'CONVERTED_NOTE_TO_ISSUE_EVENT',
  /** Represents a mention made by one issue or pull request to another. */
  CrossReferencedEvent = 'CROSS_REFERENCED_EVENT',
  /** Represents a 'demilestoned' event on a given issue or pull request. */
  DemilestonedEvent = 'DEMILESTONED_EVENT',
  /** Represents a 'disconnected' event on a given issue or pull request. */
  DisconnectedEvent = 'DISCONNECTED_EVENT',
  /** Represents a comment on an Issue. */
  IssueComment = 'ISSUE_COMMENT',
  /** Represents a 'labeled' event on a given issue or pull request. */
  LabeledEvent = 'LABELED_EVENT',
  /** Represents a 'locked' event on a given issue or pull request. */
  LockedEvent = 'LOCKED_EVENT',
  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
  MarkedAsDuplicateEvent = 'MARKED_AS_DUPLICATE_EVENT',
  /** Represents a 'mentioned' event on a given issue or pull request. */
  MentionedEvent = 'MENTIONED_EVENT',
  /** Represents a 'milestoned' event on a given issue or pull request. */
  MilestonedEvent = 'MILESTONED_EVENT',
  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
  MovedColumnsInProjectEvent = 'MOVED_COLUMNS_IN_PROJECT_EVENT',
  /** Represents a 'pinned' event on a given issue or pull request. */
  PinnedEvent = 'PINNED_EVENT',
  /** Represents a 'referenced' event on a given `ReferencedSubject`. */
  ReferencedEvent = 'REFERENCED_EVENT',
  /** Represents a 'removed_from_project' event on a given issue or pull request. */
  RemovedFromProjectEvent = 'REMOVED_FROM_PROJECT_EVENT',
  /** Represents a 'renamed' event on a given issue or pull request */
  RenamedTitleEvent = 'RENAMED_TITLE_EVENT',
  /** Represents a 'reopened' event on any `Closable`. */
  ReopenedEvent = 'REOPENED_EVENT',
  /** Represents a 'subscribed' event on a given `Subscribable`. */
  SubscribedEvent = 'SUBSCRIBED_EVENT',
  /** Represents a 'transferred' event on a given issue or pull request. */
  TransferredEvent = 'TRANSFERRED_EVENT',
  /** Represents an 'unassigned' event on any assignable object. */
  UnassignedEvent = 'UNASSIGNED_EVENT',
  /** Represents an 'unlabeled' event on a given issue or pull request. */
  UnlabeledEvent = 'UNLABELED_EVENT',
  /** Represents an 'unlocked' event on a given issue or pull request. */
  UnlockedEvent = 'UNLOCKED_EVENT',
  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
  UnmarkedAsDuplicateEvent = 'UNMARKED_AS_DUPLICATE_EVENT',
  /** Represents an 'unpinned' event on a given issue or pull request. */
  UnpinnedEvent = 'UNPINNED_EVENT',
  /** Represents an 'unsubscribed' event on a given `Subscribable`. */
  UnsubscribedEvent = 'UNSUBSCRIBED_EVENT',
  /** Represents a 'user_blocked' event on a given user. */
  UserBlockedEvent = 'USER_BLOCKED_EVENT'
}

/** Represents a user signing up for a GitHub account. */
export type GQLJoinedGitHubContribution = GQLContribution & {
  __typename?: 'JoinedGitHubContribution';
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['URI'];
  /** The user who made this contribution. */
  user: GQLUser;
};

/** A label for categorizing Issues or Milestones with a given Repository. */
export type GQLLabel = GQLNode & {
  __typename?: 'Label';
  /** Identifies the label color. */
  color: Scalars['String'];
  /** Identifies the date and time when the label was created. */
  createdAt?: Maybe<Scalars['DateTime']>;
  /** A brief description of this label. */
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** Indicates whether or not this is a default label. */
  isDefault: Scalars['Boolean'];
  /** A list of issues associated with this label. */
  issues: GQLIssueConnection;
  /** Identifies the label name. */
  name: Scalars['String'];
  /** A list of pull requests associated with this label. */
  pullRequests: GQLPullRequestConnection;
  /** The repository associated with this label. */
  repository: GQLRepository;
  /** The HTTP path for this label. */
  resourcePath: Scalars['URI'];
  /** Identifies the date and time when the label was last updated. */
  updatedAt?: Maybe<Scalars['DateTime']>;
  /** The HTTP URL for this label. */
  url: Scalars['URI'];
};


/** A label for categorizing Issues or Milestones with a given Repository. */
export type GQLLabelIssuesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  filterBy?: Maybe<GQLIssueFilters>;
  first?: Maybe<Scalars['Int']>;
  labels?: Maybe<Array<Scalars['String']>>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLIssueOrder>;
  states?: Maybe<Array<GQLIssueState>>;
};


/** A label for categorizing Issues or Milestones with a given Repository. */
export type GQLLabelPullRequestsArgs = {
  after?: Maybe<Scalars['String']>;
  baseRefName?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  headRefName?: Maybe<Scalars['String']>;
  labels?: Maybe<Array<Scalars['String']>>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLIssueOrder>;
  states?: Maybe<Array<GQLPullRequestState>>;
};

/** The connection type for Label. */
export type GQLLabelConnection = {
  __typename?: 'LabelConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLLabelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLLabel>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLLabelEdge = {
  __typename?: 'LabelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLLabel>;
};

/** Ways in which lists of labels can be ordered upon return. */
export type GQLLabelOrder = {
  /** The direction in which to order labels by the specified field. */
  direction: GQLOrderDirection;
  /** The field in which to order labels by. */
  field: GQLLabelOrderField;
};

/** Properties by which label connections can be ordered. */
export enum GQLLabelOrderField {
  /** Order labels by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order labels by name */
  Name = 'NAME'
}

/** An object that can have labels assigned to it. */
export type GQLLabelable = {
  /** A list of labels associated with the object. */
  labels?: Maybe<GQLLabelConnection>;
};


/** An object that can have labels assigned to it. */
export type GQLLabelableLabelsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLLabelOrder>;
};

/** Represents a 'labeled' event on a given issue or pull request. */
export type GQLLabeledEvent = GQLNode & {
  __typename?: 'LabeledEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Identifies the label associated with the 'labeled' event. */
  label: GQLLabel;
  /** Identifies the `Labelable` associated with the event. */
  labelable: GQLLabelable;
};

/** Represents a given language found in repositories. */
export type GQLLanguage = GQLNode & {
  __typename?: 'Language';
  /** The color defined for the current language. */
  color?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The name of the current language. */
  name: Scalars['String'];
};

/** A list of languages associated with the parent. */
export type GQLLanguageConnection = {
  __typename?: 'LanguageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLLanguageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLLanguage>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
  /** The total size in bytes of files written in that language. */
  totalSize: Scalars['Int'];
};

/** Represents the language of a repository. */
export type GQLLanguageEdge = {
  __typename?: 'LanguageEdge';
  cursor: Scalars['String'];
  node: GQLLanguage;
  /** The number of bytes of code written in the language. */
  size: Scalars['Int'];
};

/** Ordering options for language connections. */
export type GQLLanguageOrder = {
  /** The ordering direction. */
  direction: GQLOrderDirection;
  /** The field to order languages by. */
  field: GQLLanguageOrderField;
};

/** Properties by which language connections can be ordered. */
export enum GQLLanguageOrderField {
  /** Order languages by the size of all files containing the language */
  Size = 'SIZE'
}

/** A repository's open source license */
export type GQLLicense = GQLNode & {
  __typename?: 'License';
  /** The full text of the license */
  body: Scalars['String'];
  /** The conditions set by the license */
  conditions: Array<Maybe<GQLLicenseRule>>;
  /** A human-readable description of the license */
  description?: Maybe<Scalars['String']>;
  /** Whether the license should be featured */
  featured: Scalars['Boolean'];
  /** Whether the license should be displayed in license pickers */
  hidden: Scalars['Boolean'];
  id: Scalars['ID'];
  /** Instructions on how to implement the license */
  implementation?: Maybe<Scalars['String']>;
  /** The lowercased SPDX ID of the license */
  key: Scalars['String'];
  /** The limitations set by the license */
  limitations: Array<Maybe<GQLLicenseRule>>;
  /** The license full name specified by <https://spdx.org/licenses> */
  name: Scalars['String'];
  /** Customary short name if applicable (e.g, GPLv3) */
  nickname?: Maybe<Scalars['String']>;
  /** The permissions set by the license */
  permissions: Array<Maybe<GQLLicenseRule>>;
  /** Whether the license is a pseudo-license placeholder (e.g., other, no-license) */
  pseudoLicense: Scalars['Boolean'];
  /** Short identifier specified by <https://spdx.org/licenses> */
  spdxId?: Maybe<Scalars['String']>;
  /** URL to the license on <https://choosealicense.com> */
  url?: Maybe<Scalars['URI']>;
};

/** Describes a License's conditions, permissions, and limitations */
export type GQLLicenseRule = {
  __typename?: 'LicenseRule';
  /** A description of the rule */
  description: Scalars['String'];
  /** The machine-readable rule key */
  key: Scalars['String'];
  /** The human-readable rule label */
  label: Scalars['String'];
};

/** Autogenerated input type of LinkRepositoryToProject */
export type GQLLinkRepositoryToProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the Project to link to a Repository */
  projectId: Scalars['ID'];
  /** The ID of the Repository to link to a Project. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of LinkRepositoryToProject */
export type GQLLinkRepositoryToProjectPayload = {
  __typename?: 'LinkRepositoryToProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The linked Project. */
  project?: Maybe<GQLProject>;
  /** The linked Repository. */
  repository?: Maybe<GQLRepository>;
};

/** Autogenerated input type of LockLockable */
export type GQLLockLockableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A reason for why the issue or pull request will be locked. */
  lockReason?: Maybe<GQLLockReason>;
  /** ID of the issue or pull request to be locked. */
  lockableId: Scalars['ID'];
};

/** Autogenerated return type of LockLockable */
export type GQLLockLockablePayload = {
  __typename?: 'LockLockablePayload';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The item that was locked. */
  lockedRecord?: Maybe<GQLLockable>;
};

/** The possible reasons that an issue or pull request was locked. */
export enum GQLLockReason {
  /** The issue or pull request was locked because the conversation was off-topic. */
  OffTopic = 'OFF_TOPIC',
  /** The issue or pull request was locked because the conversation was resolved. */
  Resolved = 'RESOLVED',
  /** The issue or pull request was locked because the conversation was spam. */
  Spam = 'SPAM',
  /** The issue or pull request was locked because the conversation was too heated. */
  TooHeated = 'TOO_HEATED'
}

/** An object that can be locked. */
export type GQLLockable = {
  /** Reason that the conversation was locked. */
  activeLockReason?: Maybe<GQLLockReason>;
  /** `true` if the object is locked */
  locked: Scalars['Boolean'];
};

/** Represents a 'locked' event on a given issue or pull request. */
export type GQLLockedEvent = GQLNode & {
  __typename?: 'LockedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Reason that the conversation was locked (optional). */
  lockReason?: Maybe<GQLLockReason>;
  /** Object that was locked. */
  lockable: GQLLockable;
};

/** A placeholder user for attribution of imported data on GitHub. */
export type GQLMannequin = GQLActor & GQLNode & GQLUniformResourceLocatable & {
  __typename?: 'Mannequin';
  /** A URL pointing to the GitHub App's public avatar. */
  avatarUrl: Scalars['URI'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The mannequin's email on the source instance. */
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The username of the actor. */
  login: Scalars['String'];
  /** The HTML path to this resource. */
  resourcePath: Scalars['URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The URL to this resource. */
  url: Scalars['URI'];
};


/** A placeholder user for attribution of imported data on GitHub. */
export type GQLMannequinAvatarUrlArgs = {
  size?: Maybe<Scalars['Int']>;
};

/** Autogenerated input type of MarkPullRequestReadyForReview */
export type GQLMarkPullRequestReadyForReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** ID of the pull request to be marked as ready for review. */
  pullRequestId: Scalars['ID'];
};

/** Autogenerated return type of MarkPullRequestReadyForReview */
export type GQLMarkPullRequestReadyForReviewPayload = {
  __typename?: 'MarkPullRequestReadyForReviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request that is ready for review. */
  pullRequest?: Maybe<GQLPullRequest>;
};

/** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
export type GQLMarkedAsDuplicateEvent = GQLNode & {
  __typename?: 'MarkedAsDuplicateEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
};

/** A public description of a Marketplace category. */
export type GQLMarketplaceCategory = GQLNode & {
  __typename?: 'MarketplaceCategory';
  /** The category's description. */
  description?: Maybe<Scalars['String']>;
  /** The technical description of how apps listed in this category work with GitHub. */
  howItWorks?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The category's name. */
  name: Scalars['String'];
  /** How many Marketplace listings have this as their primary category. */
  primaryListingCount: Scalars['Int'];
  /** The HTTP path for this Marketplace category. */
  resourcePath: Scalars['URI'];
  /** How many Marketplace listings have this as their secondary category. */
  secondaryListingCount: Scalars['Int'];
  /** The short name of the category used in its URL. */
  slug: Scalars['String'];
  /** The HTTP URL for this Marketplace category. */
  url: Scalars['URI'];
};

/** A listing in the GitHub integration marketplace. */
export type GQLMarketplaceListing = GQLNode & {
  __typename?: 'MarketplaceListing';
  /** The GitHub App this listing represents. */
  app?: Maybe<GQLApp>;
  /** URL to the listing owner's company site. */
  companyUrl?: Maybe<Scalars['URI']>;
  /** The HTTP path for configuring access to the listing's integration or OAuth app */
  configurationResourcePath: Scalars['URI'];
  /** The HTTP URL for configuring access to the listing's integration or OAuth app */
  configurationUrl: Scalars['URI'];
  /** URL to the listing's documentation. */
  documentationUrl?: Maybe<Scalars['URI']>;
  /** The listing's detailed description. */
  extendedDescription?: Maybe<Scalars['String']>;
  /** The listing's detailed description rendered to HTML. */
  extendedDescriptionHTML: Scalars['HTML'];
  /** The listing's introductory description. */
  fullDescription: Scalars['String'];
  /** The listing's introductory description rendered to HTML. */
  fullDescriptionHTML: Scalars['HTML'];
  /** Does this listing have any plans with a free trial? */
  hasPublishedFreeTrialPlans: Scalars['Boolean'];
  /** Does this listing have a terms of service link? */
  hasTermsOfService: Scalars['Boolean'];
  /** A technical description of how this app works with GitHub. */
  howItWorks?: Maybe<Scalars['String']>;
  /** The listing's technical description rendered to HTML. */
  howItWorksHTML: Scalars['HTML'];
  id: Scalars['ID'];
  /** URL to install the product to the viewer's account or organization. */
  installationUrl?: Maybe<Scalars['URI']>;
  /** Whether this listing's app has been installed for the current viewer */
  installedForViewer: Scalars['Boolean'];
  /** Whether this listing has been removed from the Marketplace. */
  isArchived: Scalars['Boolean'];
  /**
   * Whether this listing is still an editable draft that has not been submitted
   * for review and is not publicly visible in the Marketplace.
   */
  isDraft: Scalars['Boolean'];
  /** Whether the product this listing represents is available as part of a paid plan. */
  isPaid: Scalars['Boolean'];
  /** Whether this listing has been approved for display in the Marketplace. */
  isPublic: Scalars['Boolean'];
  /** Whether this listing has been rejected by GitHub for display in the Marketplace. */
  isRejected: Scalars['Boolean'];
  /** Whether this listing has been approved for unverified display in the Marketplace. */
  isUnverified: Scalars['Boolean'];
  /** Whether this draft listing has been submitted for review for approval to be unverified in the Marketplace. */
  isUnverifiedPending: Scalars['Boolean'];
  /** Whether this draft listing has been submitted for review from GitHub for approval to be verified in the Marketplace. */
  isVerificationPendingFromDraft: Scalars['Boolean'];
  /** Whether this unverified listing has been submitted for review from GitHub for approval to be verified in the Marketplace. */
  isVerificationPendingFromUnverified: Scalars['Boolean'];
  /** Whether this listing has been approved for verified display in the Marketplace. */
  isVerified: Scalars['Boolean'];
  /** The hex color code, without the leading '#', for the logo background. */
  logoBackgroundColor: Scalars['String'];
  /** URL for the listing's logo image. */
  logoUrl?: Maybe<Scalars['URI']>;
  /** The listing's full name. */
  name: Scalars['String'];
  /** The listing's very short description without a trailing period or ampersands. */
  normalizedShortDescription: Scalars['String'];
  /** URL to the listing's detailed pricing. */
  pricingUrl?: Maybe<Scalars['URI']>;
  /** The category that best describes the listing. */
  primaryCategory: GQLMarketplaceCategory;
  /** URL to the listing's privacy policy, may return an empty string for listings that do not require a privacy policy URL. */
  privacyPolicyUrl: Scalars['URI'];
  /** The HTTP path for the Marketplace listing. */
  resourcePath: Scalars['URI'];
  /** The URLs for the listing's screenshots. */
  screenshotUrls: Array<Maybe<Scalars['String']>>;
  /** An alternate category that describes the listing. */
  secondaryCategory?: Maybe<GQLMarketplaceCategory>;
  /** The listing's very short description. */
  shortDescription: Scalars['String'];
  /** The short name of the listing used in its URL. */
  slug: Scalars['String'];
  /** URL to the listing's status page. */
  statusUrl?: Maybe<Scalars['URI']>;
  /** An email address for support for this listing's app. */
  supportEmail?: Maybe<Scalars['String']>;
  /**
   * Either a URL or an email address for support for this listing's app, may
   * return an empty string for listings that do not require a support URL.
   */
  supportUrl: Scalars['URI'];
  /** URL to the listing's terms of service. */
  termsOfServiceUrl?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the Marketplace listing. */
  url: Scalars['URI'];
  /** Can the current viewer add plans for this Marketplace listing. */
  viewerCanAddPlans: Scalars['Boolean'];
  /** Can the current viewer approve this Marketplace listing. */
  viewerCanApprove: Scalars['Boolean'];
  /** Can the current viewer delist this Marketplace listing. */
  viewerCanDelist: Scalars['Boolean'];
  /** Can the current viewer edit this Marketplace listing. */
  viewerCanEdit: Scalars['Boolean'];
  /**
   * Can the current viewer edit the primary and secondary category of this
   * Marketplace listing.
   */
  viewerCanEditCategories: Scalars['Boolean'];
  /** Can the current viewer edit the plans for this Marketplace listing. */
  viewerCanEditPlans: Scalars['Boolean'];
  /**
   * Can the current viewer return this Marketplace listing to draft state
   * so it becomes editable again.
   */
  viewerCanRedraft: Scalars['Boolean'];
  /**
   * Can the current viewer reject this Marketplace listing by returning it to
   * an editable draft state or rejecting it entirely.
   */
  viewerCanReject: Scalars['Boolean'];
  /**
   * Can the current viewer request this listing be reviewed for display in
   * the Marketplace as verified.
   */
  viewerCanRequestApproval: Scalars['Boolean'];
  /** Indicates whether the current user has an active subscription to this Marketplace listing. */
  viewerHasPurchased: Scalars['Boolean'];
  /**
   * Indicates if the current user has purchased a subscription to this Marketplace listing
   * for all of the organizations the user owns.
   */
  viewerHasPurchasedForAllOrganizations: Scalars['Boolean'];
  /** Does the current viewer role allow them to administer this Marketplace listing. */
  viewerIsListingAdmin: Scalars['Boolean'];
};


/** A listing in the GitHub integration marketplace. */
export type GQLMarketplaceListingLogoUrlArgs = {
  size?: Maybe<Scalars['Int']>;
};

/** Look up Marketplace Listings */
export type GQLMarketplaceListingConnection = {
  __typename?: 'MarketplaceListingConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLMarketplaceListingEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLMarketplaceListing>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLMarketplaceListingEdge = {
  __typename?: 'MarketplaceListingEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLMarketplaceListing>;
};

/** Entities that have members who can set status messages. */
export type GQLMemberStatusable = {
  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
  memberStatuses: GQLUserStatusConnection;
};


/** Entities that have members who can set status messages. */
export type GQLMemberStatusableMemberStatusesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLUserStatusOrder>;
};

/** Audit log entry for a members_can_delete_repos.clear event. */
export type GQLMembersCanDeleteReposClearAuditEntry = GQLAuditEntry & GQLEnterpriseAuditEntryData & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'MembersCanDeleteReposClearAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a members_can_delete_repos.disable event. */
export type GQLMembersCanDeleteReposDisableAuditEntry = GQLAuditEntry & GQLEnterpriseAuditEntryData & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'MembersCanDeleteReposDisableAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a members_can_delete_repos.enable event. */
export type GQLMembersCanDeleteReposEnableAuditEntry = GQLAuditEntry & GQLEnterpriseAuditEntryData & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'MembersCanDeleteReposEnableAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Represents a 'mentioned' event on a given issue or pull request. */
export type GQLMentionedEvent = GQLNode & {
  __typename?: 'MentionedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
};

/** Autogenerated input type of MergeBranch */
export type GQLMergeBranchInput = {
  /** The name of the base branch that the provided head will be merged into. */
  base: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Message to use for the merge commit. If omitted, a default will be used. */
  commitMessage?: Maybe<Scalars['String']>;
  /** The head to merge into the base branch. This can be a branch name or a commit GitObjectID. */
  head: Scalars['String'];
  /** The Node ID of the Repository containing the base branch that will be modified. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of MergeBranch */
export type GQLMergeBranchPayload = {
  __typename?: 'MergeBranchPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The resulting merge Commit. */
  mergeCommit?: Maybe<GQLCommit>;
};

/** Autogenerated input type of MergePullRequest */
export type GQLMergePullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Commit body to use for the merge commit; if omitted, a default message will be used */
  commitBody?: Maybe<Scalars['String']>;
  /** Commit headline to use for the merge commit; if omitted, a default message will be used. */
  commitHeadline?: Maybe<Scalars['String']>;
  /** OID that the pull request head ref must match to allow merge; if omitted, no check is performed. */
  expectedHeadOid?: Maybe<Scalars['GitObjectID']>;
  /** The merge method to use. If omitted, defaults to 'MERGE' */
  mergeMethod?: Maybe<GQLPullRequestMergeMethod>;
  /** ID of the pull request to be merged. */
  pullRequestId: Scalars['ID'];
};

/** Autogenerated return type of MergePullRequest */
export type GQLMergePullRequestPayload = {
  __typename?: 'MergePullRequestPayload';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request that was merged. */
  pullRequest?: Maybe<GQLPullRequest>;
};

/** Detailed status information about a pull request merge. */
export enum GQLMergeStateStatus {
  /** The head ref is out of date. */
  Behind = 'BEHIND',
  /** The merge is blocked. */
  Blocked = 'BLOCKED',
  /** Mergeable and passing commit status. */
  Clean = 'CLEAN',
  /** The merge commit cannot be cleanly created. */
  Dirty = 'DIRTY',
  /** The merge is blocked due to the pull request being a draft. */
  Draft = 'DRAFT',
  /** Mergeable with passing commit status and pre-receive hooks. */
  HasHooks = 'HAS_HOOKS',
  /** The state cannot currently be determined. */
  Unknown = 'UNKNOWN',
  /** Mergeable with non-passing commit status. */
  Unstable = 'UNSTABLE'
}

/** Whether or not a PullRequest can be merged. */
export enum GQLMergeableState {
  /** The pull request cannot be merged due to merge conflicts. */
  Conflicting = 'CONFLICTING',
  /** The pull request can be merged. */
  Mergeable = 'MERGEABLE',
  /** The mergeability of the pull request is still being calculated. */
  Unknown = 'UNKNOWN'
}

/** Represents a 'merged' event on a given pull request. */
export type GQLMergedEvent = GQLNode & GQLUniformResourceLocatable & {
  __typename?: 'MergedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the commit associated with the `merge` event. */
  commit?: Maybe<GQLCommit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Identifies the Ref associated with the `merge` event. */
  mergeRef?: Maybe<GQLRef>;
  /** Identifies the name of the Ref associated with the `merge` event. */
  mergeRefName: Scalars['String'];
  /** PullRequest referenced by event. */
  pullRequest: GQLPullRequest;
  /** The HTTP path for this merged event. */
  resourcePath: Scalars['URI'];
  /** The HTTP URL for this merged event. */
  url: Scalars['URI'];
};

/** Represents a Milestone object on a given repository. */
export type GQLMilestone = GQLClosable & GQLNode & GQLUniformResourceLocatable & {
  __typename?: 'Milestone';
  /** `true` if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the actor who created the milestone. */
  creator?: Maybe<GQLActor>;
  /** Identifies the description of the milestone. */
  description?: Maybe<Scalars['String']>;
  /** Identifies the due date of the milestone. */
  dueOn?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  /** Just for debugging on review-lab */
  issuePrioritiesDebug: Scalars['String'];
  /** A list of issues associated with the milestone. */
  issues: GQLIssueConnection;
  /** Identifies the number of the milestone. */
  number: Scalars['Int'];
  /** A list of pull requests associated with the milestone. */
  pullRequests: GQLPullRequestConnection;
  /** The repository associated with this milestone. */
  repository: GQLRepository;
  /** The HTTP path for this milestone */
  resourcePath: Scalars['URI'];
  /** Identifies the state of the milestone. */
  state: GQLMilestoneState;
  /** Identifies the title of the milestone. */
  title: Scalars['String'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this milestone */
  url: Scalars['URI'];
};


/** Represents a Milestone object on a given repository. */
export type GQLMilestoneIssuesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  filterBy?: Maybe<GQLIssueFilters>;
  first?: Maybe<Scalars['Int']>;
  labels?: Maybe<Array<Scalars['String']>>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLIssueOrder>;
  states?: Maybe<Array<GQLIssueState>>;
};


/** Represents a Milestone object on a given repository. */
export type GQLMilestonePullRequestsArgs = {
  after?: Maybe<Scalars['String']>;
  baseRefName?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  headRefName?: Maybe<Scalars['String']>;
  labels?: Maybe<Array<Scalars['String']>>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLIssueOrder>;
  states?: Maybe<Array<GQLPullRequestState>>;
};

/** The connection type for Milestone. */
export type GQLMilestoneConnection = {
  __typename?: 'MilestoneConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLMilestoneEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLMilestone>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLMilestoneEdge = {
  __typename?: 'MilestoneEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLMilestone>;
};

/** Types that can be inside a Milestone. */
export type GQLMilestoneItem = GQLIssue | GQLPullRequest;

/** Ordering options for milestone connections. */
export type GQLMilestoneOrder = {
  /** The ordering direction. */
  direction: GQLOrderDirection;
  /** The field to order milestones by. */
  field: GQLMilestoneOrderField;
};

/** Properties by which milestone connections can be ordered. */
export enum GQLMilestoneOrderField {
  /** Order milestones by when they were created. */
  CreatedAt = 'CREATED_AT',
  /** Order milestones by when they are due. */
  DueDate = 'DUE_DATE',
  /** Order milestones by their number. */
  Number = 'NUMBER',
  /** Order milestones by when they were last updated. */
  UpdatedAt = 'UPDATED_AT'
}

/** The possible states of a milestone. */
export enum GQLMilestoneState {
  /** A milestone that has been closed. */
  Closed = 'CLOSED',
  /** A milestone that is still open. */
  Open = 'OPEN'
}

/** Represents a 'milestoned' event on a given issue or pull request. */
export type GQLMilestonedEvent = GQLNode & {
  __typename?: 'MilestonedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Identifies the milestone title associated with the 'milestoned' event. */
  milestoneTitle: Scalars['String'];
  /** Object referenced by event. */
  subject: GQLMilestoneItem;
};

/** Entities that can be minimized. */
export type GQLMinimizable = {
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean'];
  /** Returns why the comment was minimized. */
  minimizedReason?: Maybe<Scalars['String']>;
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean'];
};

/** Autogenerated input type of MinimizeComment */
export type GQLMinimizeCommentInput = {
  /** The classification of comment */
  classifier: GQLReportedContentClassifiers;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'];
};

/** Autogenerated return type of MinimizeComment */
export type GQLMinimizeCommentPayload = {
  __typename?: 'MinimizeCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The comment that was minimized. */
  minimizedComment?: Maybe<GQLMinimizable>;
};

/** Autogenerated input type of MoveProjectCard */
export type GQLMoveProjectCardInput = {
  /** Place the new card after the card with this id. Pass null to place it at the top. */
  afterCardId?: Maybe<Scalars['ID']>;
  /** The id of the card to move. */
  cardId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The id of the column to move it into. */
  columnId: Scalars['ID'];
};

/** Autogenerated return type of MoveProjectCard */
export type GQLMoveProjectCardPayload = {
  __typename?: 'MoveProjectCardPayload';
  /** The new edge of the moved card. */
  cardEdge?: Maybe<GQLProjectCardEdge>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of MoveProjectColumn */
export type GQLMoveProjectColumnInput = {
  /** Place the new column after the column with this id. Pass null to place it at the front. */
  afterColumnId?: Maybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The id of the column to move. */
  columnId: Scalars['ID'];
};

/** Autogenerated return type of MoveProjectColumn */
export type GQLMoveProjectColumnPayload = {
  __typename?: 'MoveProjectColumnPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new edge of the moved column. */
  columnEdge?: Maybe<GQLProjectColumnEdge>;
};

/** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
export type GQLMovedColumnsInProjectEvent = GQLNode & {
  __typename?: 'MovedColumnsInProjectEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** Column name the issue or pull request was moved from. */
  previousProjectColumnName: Scalars['String'];
  /** Project referenced by event. */
  project?: Maybe<GQLProject>;
  /** Project card referenced by this project event. */
  projectCard?: Maybe<GQLProjectCard>;
  /** Column name the issue or pull request was moved to. */
  projectColumnName: Scalars['String'];
};

/** The root query for implementing GraphQL mutations. */
export type GQLMutation = {
  __typename?: 'Mutation';
  /** Accepts a pending invitation for a user to become an administrator of an enterprise. */
  acceptEnterpriseAdministratorInvitation?: Maybe<GQLAcceptEnterpriseAdministratorInvitationPayload>;
  /** Applies a suggested topic to the repository. */
  acceptTopicSuggestion?: Maybe<GQLAcceptTopicSuggestionPayload>;
  /** Adds assignees to an assignable object. */
  addAssigneesToAssignable?: Maybe<GQLAddAssigneesToAssignablePayload>;
  /** Adds a comment to an Issue or Pull Request. */
  addComment?: Maybe<GQLAddCommentPayload>;
  /** Adds labels to a labelable object. */
  addLabelsToLabelable?: Maybe<GQLAddLabelsToLabelablePayload>;
  /** Adds a card to a ProjectColumn. Either `contentId` or `note` must be provided but **not** both. */
  addProjectCard?: Maybe<GQLAddProjectCardPayload>;
  /** Adds a column to a Project. */
  addProjectColumn?: Maybe<GQLAddProjectColumnPayload>;
  /** Adds a review to a Pull Request. */
  addPullRequestReview?: Maybe<GQLAddPullRequestReviewPayload>;
  /** Adds a comment to a review. */
  addPullRequestReviewComment?: Maybe<GQLAddPullRequestReviewCommentPayload>;
  /** Adds a new thread to a pending Pull Request Review. */
  addPullRequestReviewThread?: Maybe<GQLAddPullRequestReviewThreadPayload>;
  /** Adds a reaction to a subject. */
  addReaction?: Maybe<GQLAddReactionPayload>;
  /** Adds a star to a Starrable. */
  addStar?: Maybe<GQLAddStarPayload>;
  /** Marks a repository as archived. */
  archiveRepository?: Maybe<GQLArchiveRepositoryPayload>;
  /** Cancels a pending invitation for an administrator to join an enterprise. */
  cancelEnterpriseAdminInvitation?: Maybe<GQLCancelEnterpriseAdminInvitationPayload>;
  /** Update your status on GitHub. */
  changeUserStatus?: Maybe<GQLChangeUserStatusPayload>;
  /** Clears all labels from a labelable object. */
  clearLabelsFromLabelable?: Maybe<GQLClearLabelsFromLabelablePayload>;
  /** Creates a new project by cloning configuration from an existing project. */
  cloneProject?: Maybe<GQLCloneProjectPayload>;
  /** Create a new repository with the same files and directory structure as a template repository. */
  cloneTemplateRepository?: Maybe<GQLCloneTemplateRepositoryPayload>;
  /** Close an issue. */
  closeIssue?: Maybe<GQLCloseIssuePayload>;
  /** Close a pull request. */
  closePullRequest?: Maybe<GQLClosePullRequestPayload>;
  /** Convert a project note card to one associated with a newly created issue. */
  convertProjectCardNoteToIssue?: Maybe<GQLConvertProjectCardNoteToIssuePayload>;
  /** Create a new branch protection rule */
  createBranchProtectionRule?: Maybe<GQLCreateBranchProtectionRulePayload>;
  /** Create a check run. */
  createCheckRun?: Maybe<GQLCreateCheckRunPayload>;
  /** Create a check suite */
  createCheckSuite?: Maybe<GQLCreateCheckSuitePayload>;
  /** Create a content attachment. */
  createContentAttachment?: Maybe<GQLCreateContentAttachmentPayload>;
  /** Creates a new deployment event. */
  createDeployment?: Maybe<GQLCreateDeploymentPayload>;
  /** Create a deployment status. */
  createDeploymentStatus?: Maybe<GQLCreateDeploymentStatusPayload>;
  /** Creates an organization as part of an enterprise account. */
  createEnterpriseOrganization?: Maybe<GQLCreateEnterpriseOrganizationPayload>;
  /** Creates a new IP allow list entry. */
  createIpAllowListEntry?: Maybe<GQLCreateIpAllowListEntryPayload>;
  /** Creates a new issue. */
  createIssue?: Maybe<GQLCreateIssuePayload>;
  /** Creates a new label. */
  createLabel?: Maybe<GQLCreateLabelPayload>;
  /** Creates a new project. */
  createProject?: Maybe<GQLCreateProjectPayload>;
  /** Create a new pull request */
  createPullRequest?: Maybe<GQLCreatePullRequestPayload>;
  /** Create a new Git Ref. */
  createRef?: Maybe<GQLCreateRefPayload>;
  /** Create a new repository. */
  createRepository?: Maybe<GQLCreateRepositoryPayload>;
  /** Creates a new team discussion. */
  createTeamDiscussion?: Maybe<GQLCreateTeamDiscussionPayload>;
  /** Creates a new team discussion comment. */
  createTeamDiscussionComment?: Maybe<GQLCreateTeamDiscussionCommentPayload>;
  /** Rejects a suggested topic for the repository. */
  declineTopicSuggestion?: Maybe<GQLDeclineTopicSuggestionPayload>;
  /** Delete a branch protection rule */
  deleteBranchProtectionRule?: Maybe<GQLDeleteBranchProtectionRulePayload>;
  /** Deletes a deployment. */
  deleteDeployment?: Maybe<GQLDeleteDeploymentPayload>;
  /** Deletes an IP allow list entry. */
  deleteIpAllowListEntry?: Maybe<GQLDeleteIpAllowListEntryPayload>;
  /** Deletes an Issue object. */
  deleteIssue?: Maybe<GQLDeleteIssuePayload>;
  /** Deletes an IssueComment object. */
  deleteIssueComment?: Maybe<GQLDeleteIssueCommentPayload>;
  /** Deletes a label. */
  deleteLabel?: Maybe<GQLDeleteLabelPayload>;
  /** Delete a package version. */
  deletePackageVersion?: Maybe<GQLDeletePackageVersionPayload>;
  /** Deletes a project. */
  deleteProject?: Maybe<GQLDeleteProjectPayload>;
  /** Deletes a project card. */
  deleteProjectCard?: Maybe<GQLDeleteProjectCardPayload>;
  /** Deletes a project column. */
  deleteProjectColumn?: Maybe<GQLDeleteProjectColumnPayload>;
  /** Deletes a pull request review. */
  deletePullRequestReview?: Maybe<GQLDeletePullRequestReviewPayload>;
  /** Deletes a pull request review comment. */
  deletePullRequestReviewComment?: Maybe<GQLDeletePullRequestReviewCommentPayload>;
  /** Delete a Git Ref. */
  deleteRef?: Maybe<GQLDeleteRefPayload>;
  /** Deletes a team discussion. */
  deleteTeamDiscussion?: Maybe<GQLDeleteTeamDiscussionPayload>;
  /** Deletes a team discussion comment. */
  deleteTeamDiscussionComment?: Maybe<GQLDeleteTeamDiscussionCommentPayload>;
  /** Dismisses an approved or rejected pull request review. */
  dismissPullRequestReview?: Maybe<GQLDismissPullRequestReviewPayload>;
  /** Follow a user. */
  followUser?: Maybe<GQLFollowUserPayload>;
  /** Creates a new project by importing columns and a list of issues/PRs. */
  importProject?: Maybe<GQLImportProjectPayload>;
  /** Invite someone to become an administrator of the enterprise. */
  inviteEnterpriseAdmin?: Maybe<GQLInviteEnterpriseAdminPayload>;
  /** Creates a repository link for a project. */
  linkRepositoryToProject?: Maybe<GQLLinkRepositoryToProjectPayload>;
  /** Lock a lockable object */
  lockLockable?: Maybe<GQLLockLockablePayload>;
  /** Marks a pull request ready for review. */
  markPullRequestReadyForReview?: Maybe<GQLMarkPullRequestReadyForReviewPayload>;
  /** Merge a head into a branch. */
  mergeBranch?: Maybe<GQLMergeBranchPayload>;
  /** Merge a pull request. */
  mergePullRequest?: Maybe<GQLMergePullRequestPayload>;
  /** Minimizes a comment on an Issue, Commit, Pull Request, or Gist */
  minimizeComment?: Maybe<GQLMinimizeCommentPayload>;
  /** Moves a project card to another place. */
  moveProjectCard?: Maybe<GQLMoveProjectCardPayload>;
  /** Moves a project column to another place. */
  moveProjectColumn?: Maybe<GQLMoveProjectColumnPayload>;
  /** Pin an issue to a repository */
  pinIssue?: Maybe<GQLPinIssuePayload>;
  /** Regenerates the identity provider recovery codes for an enterprise */
  regenerateEnterpriseIdentityProviderRecoveryCodes?: Maybe<GQLRegenerateEnterpriseIdentityProviderRecoveryCodesPayload>;
  /** Removes assignees from an assignable object. */
  removeAssigneesFromAssignable?: Maybe<GQLRemoveAssigneesFromAssignablePayload>;
  /** Removes an administrator from the enterprise. */
  removeEnterpriseAdmin?: Maybe<GQLRemoveEnterpriseAdminPayload>;
  /** Removes the identity provider from an enterprise */
  removeEnterpriseIdentityProvider?: Maybe<GQLRemoveEnterpriseIdentityProviderPayload>;
  /** Removes an organization from the enterprise */
  removeEnterpriseOrganization?: Maybe<GQLRemoveEnterpriseOrganizationPayload>;
  /** Removes labels from a Labelable object. */
  removeLabelsFromLabelable?: Maybe<GQLRemoveLabelsFromLabelablePayload>;
  /** Removes outside collaborator from all repositories in an organization. */
  removeOutsideCollaborator?: Maybe<GQLRemoveOutsideCollaboratorPayload>;
  /** Removes a reaction from a subject. */
  removeReaction?: Maybe<GQLRemoveReactionPayload>;
  /** Removes a star from a Starrable. */
  removeStar?: Maybe<GQLRemoveStarPayload>;
  /** Reopen a issue. */
  reopenIssue?: Maybe<GQLReopenIssuePayload>;
  /** Reopen a pull request. */
  reopenPullRequest?: Maybe<GQLReopenPullRequestPayload>;
  /** Set review requests on a pull request. */
  requestReviews?: Maybe<GQLRequestReviewsPayload>;
  /** Rerequests an existing check suite. */
  rerequestCheckSuite?: Maybe<GQLRerequestCheckSuitePayload>;
  /** Marks a review thread as resolved. */
  resolveReviewThread?: Maybe<GQLResolveReviewThreadPayload>;
  /** Creates or updates the identity provider for an enterprise. */
  setEnterpriseIdentityProvider?: Maybe<GQLSetEnterpriseIdentityProviderPayload>;
  /** Submits a pending pull request review. */
  submitPullRequestReview?: Maybe<GQLSubmitPullRequestReviewPayload>;
  /** Transfer an issue to a different repository */
  transferIssue?: Maybe<GQLTransferIssuePayload>;
  /** Unarchives a repository. */
  unarchiveRepository?: Maybe<GQLUnarchiveRepositoryPayload>;
  /** Unfollow a user. */
  unfollowUser?: Maybe<GQLUnfollowUserPayload>;
  /** Deletes a repository link from a project. */
  unlinkRepositoryFromProject?: Maybe<GQLUnlinkRepositoryFromProjectPayload>;
  /** Unlock a lockable object */
  unlockLockable?: Maybe<GQLUnlockLockablePayload>;
  /** Unmark an issue as a duplicate of another issue. */
  unmarkIssueAsDuplicate?: Maybe<GQLUnmarkIssueAsDuplicatePayload>;
  /** Unminimizes a comment on an Issue, Commit, Pull Request, or Gist */
  unminimizeComment?: Maybe<GQLUnminimizeCommentPayload>;
  /** Unpin a pinned issue from a repository */
  unpinIssue?: Maybe<GQLUnpinIssuePayload>;
  /** Marks a review thread as unresolved. */
  unresolveReviewThread?: Maybe<GQLUnresolveReviewThreadPayload>;
  /** Create a new branch protection rule */
  updateBranchProtectionRule?: Maybe<GQLUpdateBranchProtectionRulePayload>;
  /** Update a check run */
  updateCheckRun?: Maybe<GQLUpdateCheckRunPayload>;
  /** Modifies the settings of an existing check suite */
  updateCheckSuitePreferences?: Maybe<GQLUpdateCheckSuitePreferencesPayload>;
  /** Sets the action execution capability setting for an enterprise. */
  updateEnterpriseActionExecutionCapabilitySetting?: Maybe<GQLUpdateEnterpriseActionExecutionCapabilitySettingPayload>;
  /** Updates the role of an enterprise administrator. */
  updateEnterpriseAdministratorRole?: Maybe<GQLUpdateEnterpriseAdministratorRolePayload>;
  /** Sets whether private repository forks are enabled for an enterprise. */
  updateEnterpriseAllowPrivateRepositoryForkingSetting?: Maybe<GQLUpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload>;
  /** Sets the default repository permission for organizations in an enterprise. */
  updateEnterpriseDefaultRepositoryPermissionSetting?: Maybe<GQLUpdateEnterpriseDefaultRepositoryPermissionSettingPayload>;
  /** Sets whether organization members with admin permissions on a repository can change repository visibility. */
  updateEnterpriseMembersCanChangeRepositoryVisibilitySetting?: Maybe<GQLUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload>;
  /** Sets the members can create repositories setting for an enterprise. */
  updateEnterpriseMembersCanCreateRepositoriesSetting?: Maybe<GQLUpdateEnterpriseMembersCanCreateRepositoriesSettingPayload>;
  /** Sets the members can delete issues setting for an enterprise. */
  updateEnterpriseMembersCanDeleteIssuesSetting?: Maybe<GQLUpdateEnterpriseMembersCanDeleteIssuesSettingPayload>;
  /** Sets the members can delete repositories setting for an enterprise. */
  updateEnterpriseMembersCanDeleteRepositoriesSetting?: Maybe<GQLUpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload>;
  /** Sets whether members can invite collaborators are enabled for an enterprise. */
  updateEnterpriseMembersCanInviteCollaboratorsSetting?: Maybe<GQLUpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload>;
  /** Sets whether or not an organization admin can make purchases. */
  updateEnterpriseMembersCanMakePurchasesSetting?: Maybe<GQLUpdateEnterpriseMembersCanMakePurchasesSettingPayload>;
  /** Sets the members can update protected branches setting for an enterprise. */
  updateEnterpriseMembersCanUpdateProtectedBranchesSetting?: Maybe<GQLUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload>;
  /** Sets the members can view dependency insights for an enterprise. */
  updateEnterpriseMembersCanViewDependencyInsightsSetting?: Maybe<GQLUpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload>;
  /** Sets whether organization projects are enabled for an enterprise. */
  updateEnterpriseOrganizationProjectsSetting?: Maybe<GQLUpdateEnterpriseOrganizationProjectsSettingPayload>;
  /** Updates an enterprise's profile. */
  updateEnterpriseProfile?: Maybe<GQLUpdateEnterpriseProfilePayload>;
  /** Sets whether repository projects are enabled for a enterprise. */
  updateEnterpriseRepositoryProjectsSetting?: Maybe<GQLUpdateEnterpriseRepositoryProjectsSettingPayload>;
  /** Sets whether team discussions are enabled for an enterprise. */
  updateEnterpriseTeamDiscussionsSetting?: Maybe<GQLUpdateEnterpriseTeamDiscussionsSettingPayload>;
  /** Sets whether two factor authentication is required for all users in an enterprise. */
  updateEnterpriseTwoFactorAuthenticationRequiredSetting?: Maybe<GQLUpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload>;
  /** Sets whether an IP allow list is enabled on an owner. */
  updateIpAllowListEnabledSetting?: Maybe<GQLUpdateIpAllowListEnabledSettingPayload>;
  /** Updates an IP allow list entry. */
  updateIpAllowListEntry?: Maybe<GQLUpdateIpAllowListEntryPayload>;
  /** Updates an Issue. */
  updateIssue?: Maybe<GQLUpdateIssuePayload>;
  /** Updates an IssueComment object. */
  updateIssueComment?: Maybe<GQLUpdateIssueCommentPayload>;
  /** Updates an existing label. */
  updateLabel?: Maybe<GQLUpdateLabelPayload>;
  /** Updates an existing project. */
  updateProject?: Maybe<GQLUpdateProjectPayload>;
  /** Updates an existing project card. */
  updateProjectCard?: Maybe<GQLUpdateProjectCardPayload>;
  /** Updates an existing project column. */
  updateProjectColumn?: Maybe<GQLUpdateProjectColumnPayload>;
  /** Update a pull request */
  updatePullRequest?: Maybe<GQLUpdatePullRequestPayload>;
  /** Updates the body of a pull request review. */
  updatePullRequestReview?: Maybe<GQLUpdatePullRequestReviewPayload>;
  /** Updates a pull request review comment. */
  updatePullRequestReviewComment?: Maybe<GQLUpdatePullRequestReviewCommentPayload>;
  /** Update a Git Ref. */
  updateRef?: Maybe<GQLUpdateRefPayload>;
  /**
   * Creates, updates and/or deletes multiple refs in a repository.
   * 
   * This mutation takes a list of `RefUpdate`s and performs these updates
   * on the repository. All updates are performed atomically, meaning that
   * if one of them is rejected, no other ref will be modified.
   * 
   * `RefUpdate.beforeOid` specifies that the given reference needs to point
   * to the given value before performing any updates. A value of
   * `0000000000000000000000000000000000000000` can be used to verify that
   * the references should not exist.
   * 
   * `RefUpdate.afterOid` specifies the value that the given reference
   * will point to after performing all updates. A value of
   * `0000000000000000000000000000000000000000` can be used to delete a
   * reference.
   * 
   * If `RefUpdate.force` is set to `true`, a non-fast-forward updates
   * for the given reference will be allowed.
   */
  updateRefs?: Maybe<GQLUpdateRefsPayload>;
  /** Update information about a repository. */
  updateRepository?: Maybe<GQLUpdateRepositoryPayload>;
  /** Updates the state for subscribable subjects. */
  updateSubscription?: Maybe<GQLUpdateSubscriptionPayload>;
  /** Updates a team discussion. */
  updateTeamDiscussion?: Maybe<GQLUpdateTeamDiscussionPayload>;
  /** Updates a discussion comment. */
  updateTeamDiscussionComment?: Maybe<GQLUpdateTeamDiscussionCommentPayload>;
  /** Updates team review assignment. */
  updateTeamReviewAssignment?: Maybe<GQLUpdateTeamReviewAssignmentPayload>;
  /** Replaces the repository's topics with the given topics. */
  updateTopics?: Maybe<GQLUpdateTopicsPayload>;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationAcceptEnterpriseAdministratorInvitationArgs = {
  input: GQLAcceptEnterpriseAdministratorInvitationInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationAcceptTopicSuggestionArgs = {
  input: GQLAcceptTopicSuggestionInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationAddAssigneesToAssignableArgs = {
  input: GQLAddAssigneesToAssignableInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationAddCommentArgs = {
  input: GQLAddCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationAddLabelsToLabelableArgs = {
  input: GQLAddLabelsToLabelableInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationAddProjectCardArgs = {
  input: GQLAddProjectCardInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationAddProjectColumnArgs = {
  input: GQLAddProjectColumnInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationAddPullRequestReviewArgs = {
  input: GQLAddPullRequestReviewInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationAddPullRequestReviewCommentArgs = {
  input: GQLAddPullRequestReviewCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationAddPullRequestReviewThreadArgs = {
  input: GQLAddPullRequestReviewThreadInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationAddReactionArgs = {
  input: GQLAddReactionInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationAddStarArgs = {
  input: GQLAddStarInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationArchiveRepositoryArgs = {
  input: GQLArchiveRepositoryInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationCancelEnterpriseAdminInvitationArgs = {
  input: GQLCancelEnterpriseAdminInvitationInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationChangeUserStatusArgs = {
  input: GQLChangeUserStatusInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationClearLabelsFromLabelableArgs = {
  input: GQLClearLabelsFromLabelableInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationCloneProjectArgs = {
  input: GQLCloneProjectInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationCloneTemplateRepositoryArgs = {
  input: GQLCloneTemplateRepositoryInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationCloseIssueArgs = {
  input: GQLCloseIssueInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationClosePullRequestArgs = {
  input: GQLClosePullRequestInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationConvertProjectCardNoteToIssueArgs = {
  input: GQLConvertProjectCardNoteToIssueInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationCreateBranchProtectionRuleArgs = {
  input: GQLCreateBranchProtectionRuleInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationCreateCheckRunArgs = {
  input: GQLCreateCheckRunInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationCreateCheckSuiteArgs = {
  input: GQLCreateCheckSuiteInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationCreateContentAttachmentArgs = {
  input: GQLCreateContentAttachmentInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationCreateDeploymentArgs = {
  input: GQLCreateDeploymentInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationCreateDeploymentStatusArgs = {
  input: GQLCreateDeploymentStatusInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationCreateEnterpriseOrganizationArgs = {
  input: GQLCreateEnterpriseOrganizationInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationCreateIpAllowListEntryArgs = {
  input: GQLCreateIpAllowListEntryInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationCreateIssueArgs = {
  input: GQLCreateIssueInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationCreateLabelArgs = {
  input: GQLCreateLabelInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationCreateProjectArgs = {
  input: GQLCreateProjectInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationCreatePullRequestArgs = {
  input: GQLCreatePullRequestInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationCreateRefArgs = {
  input: GQLCreateRefInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationCreateRepositoryArgs = {
  input: GQLCreateRepositoryInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationCreateTeamDiscussionArgs = {
  input: GQLCreateTeamDiscussionInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationCreateTeamDiscussionCommentArgs = {
  input: GQLCreateTeamDiscussionCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationDeclineTopicSuggestionArgs = {
  input: GQLDeclineTopicSuggestionInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationDeleteBranchProtectionRuleArgs = {
  input: GQLDeleteBranchProtectionRuleInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationDeleteDeploymentArgs = {
  input: GQLDeleteDeploymentInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationDeleteIpAllowListEntryArgs = {
  input: GQLDeleteIpAllowListEntryInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationDeleteIssueArgs = {
  input: GQLDeleteIssueInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationDeleteIssueCommentArgs = {
  input: GQLDeleteIssueCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationDeleteLabelArgs = {
  input: GQLDeleteLabelInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationDeletePackageVersionArgs = {
  input: GQLDeletePackageVersionInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationDeleteProjectArgs = {
  input: GQLDeleteProjectInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationDeleteProjectCardArgs = {
  input: GQLDeleteProjectCardInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationDeleteProjectColumnArgs = {
  input: GQLDeleteProjectColumnInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationDeletePullRequestReviewArgs = {
  input: GQLDeletePullRequestReviewInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationDeletePullRequestReviewCommentArgs = {
  input: GQLDeletePullRequestReviewCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationDeleteRefArgs = {
  input: GQLDeleteRefInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationDeleteTeamDiscussionArgs = {
  input: GQLDeleteTeamDiscussionInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationDeleteTeamDiscussionCommentArgs = {
  input: GQLDeleteTeamDiscussionCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationDismissPullRequestReviewArgs = {
  input: GQLDismissPullRequestReviewInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationFollowUserArgs = {
  input: GQLFollowUserInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationImportProjectArgs = {
  input: GQLImportProjectInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationInviteEnterpriseAdminArgs = {
  input: GQLInviteEnterpriseAdminInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationLinkRepositoryToProjectArgs = {
  input: GQLLinkRepositoryToProjectInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationLockLockableArgs = {
  input: GQLLockLockableInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationMarkPullRequestReadyForReviewArgs = {
  input: GQLMarkPullRequestReadyForReviewInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationMergeBranchArgs = {
  input: GQLMergeBranchInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationMergePullRequestArgs = {
  input: GQLMergePullRequestInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationMinimizeCommentArgs = {
  input: GQLMinimizeCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationMoveProjectCardArgs = {
  input: GQLMoveProjectCardInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationMoveProjectColumnArgs = {
  input: GQLMoveProjectColumnInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationPinIssueArgs = {
  input: GQLPinIssueInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationRegenerateEnterpriseIdentityProviderRecoveryCodesArgs = {
  input: GQLRegenerateEnterpriseIdentityProviderRecoveryCodesInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationRemoveAssigneesFromAssignableArgs = {
  input: GQLRemoveAssigneesFromAssignableInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationRemoveEnterpriseAdminArgs = {
  input: GQLRemoveEnterpriseAdminInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationRemoveEnterpriseIdentityProviderArgs = {
  input: GQLRemoveEnterpriseIdentityProviderInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationRemoveEnterpriseOrganizationArgs = {
  input: GQLRemoveEnterpriseOrganizationInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationRemoveLabelsFromLabelableArgs = {
  input: GQLRemoveLabelsFromLabelableInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationRemoveOutsideCollaboratorArgs = {
  input: GQLRemoveOutsideCollaboratorInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationRemoveReactionArgs = {
  input: GQLRemoveReactionInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationRemoveStarArgs = {
  input: GQLRemoveStarInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationReopenIssueArgs = {
  input: GQLReopenIssueInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationReopenPullRequestArgs = {
  input: GQLReopenPullRequestInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationRequestReviewsArgs = {
  input: GQLRequestReviewsInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationRerequestCheckSuiteArgs = {
  input: GQLRerequestCheckSuiteInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationResolveReviewThreadArgs = {
  input: GQLResolveReviewThreadInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationSetEnterpriseIdentityProviderArgs = {
  input: GQLSetEnterpriseIdentityProviderInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationSubmitPullRequestReviewArgs = {
  input: GQLSubmitPullRequestReviewInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationTransferIssueArgs = {
  input: GQLTransferIssueInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUnarchiveRepositoryArgs = {
  input: GQLUnarchiveRepositoryInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUnfollowUserArgs = {
  input: GQLUnfollowUserInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUnlinkRepositoryFromProjectArgs = {
  input: GQLUnlinkRepositoryFromProjectInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUnlockLockableArgs = {
  input: GQLUnlockLockableInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUnmarkIssueAsDuplicateArgs = {
  input: GQLUnmarkIssueAsDuplicateInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUnminimizeCommentArgs = {
  input: GQLUnminimizeCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUnpinIssueArgs = {
  input: GQLUnpinIssueInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUnresolveReviewThreadArgs = {
  input: GQLUnresolveReviewThreadInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateBranchProtectionRuleArgs = {
  input: GQLUpdateBranchProtectionRuleInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateCheckRunArgs = {
  input: GQLUpdateCheckRunInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateCheckSuitePreferencesArgs = {
  input: GQLUpdateCheckSuitePreferencesInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateEnterpriseActionExecutionCapabilitySettingArgs = {
  input: GQLUpdateEnterpriseActionExecutionCapabilitySettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateEnterpriseAdministratorRoleArgs = {
  input: GQLUpdateEnterpriseAdministratorRoleInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateEnterpriseAllowPrivateRepositoryForkingSettingArgs = {
  input: GQLUpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateEnterpriseDefaultRepositoryPermissionSettingArgs = {
  input: GQLUpdateEnterpriseDefaultRepositoryPermissionSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingArgs = {
  input: GQLUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateEnterpriseMembersCanCreateRepositoriesSettingArgs = {
  input: GQLUpdateEnterpriseMembersCanCreateRepositoriesSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateEnterpriseMembersCanDeleteIssuesSettingArgs = {
  input: GQLUpdateEnterpriseMembersCanDeleteIssuesSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateEnterpriseMembersCanDeleteRepositoriesSettingArgs = {
  input: GQLUpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateEnterpriseMembersCanInviteCollaboratorsSettingArgs = {
  input: GQLUpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateEnterpriseMembersCanMakePurchasesSettingArgs = {
  input: GQLUpdateEnterpriseMembersCanMakePurchasesSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingArgs = {
  input: GQLUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateEnterpriseMembersCanViewDependencyInsightsSettingArgs = {
  input: GQLUpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateEnterpriseOrganizationProjectsSettingArgs = {
  input: GQLUpdateEnterpriseOrganizationProjectsSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateEnterpriseProfileArgs = {
  input: GQLUpdateEnterpriseProfileInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateEnterpriseRepositoryProjectsSettingArgs = {
  input: GQLUpdateEnterpriseRepositoryProjectsSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateEnterpriseTeamDiscussionsSettingArgs = {
  input: GQLUpdateEnterpriseTeamDiscussionsSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateEnterpriseTwoFactorAuthenticationRequiredSettingArgs = {
  input: GQLUpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateIpAllowListEnabledSettingArgs = {
  input: GQLUpdateIpAllowListEnabledSettingInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateIpAllowListEntryArgs = {
  input: GQLUpdateIpAllowListEntryInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateIssueArgs = {
  input: GQLUpdateIssueInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateIssueCommentArgs = {
  input: GQLUpdateIssueCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateLabelArgs = {
  input: GQLUpdateLabelInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateProjectArgs = {
  input: GQLUpdateProjectInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateProjectCardArgs = {
  input: GQLUpdateProjectCardInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateProjectColumnArgs = {
  input: GQLUpdateProjectColumnInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdatePullRequestArgs = {
  input: GQLUpdatePullRequestInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdatePullRequestReviewArgs = {
  input: GQLUpdatePullRequestReviewInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdatePullRequestReviewCommentArgs = {
  input: GQLUpdatePullRequestReviewCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateRefArgs = {
  input: GQLUpdateRefInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateRefsArgs = {
  input: GQLUpdateRefsInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateRepositoryArgs = {
  input: GQLUpdateRepositoryInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateSubscriptionArgs = {
  input: GQLUpdateSubscriptionInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateTeamDiscussionArgs = {
  input: GQLUpdateTeamDiscussionInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateTeamDiscussionCommentArgs = {
  input: GQLUpdateTeamDiscussionCommentInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateTeamReviewAssignmentArgs = {
  input: GQLUpdateTeamReviewAssignmentInput;
};


/** The root query for implementing GraphQL mutations. */
export type GQLMutationUpdateTopicsArgs = {
  input: GQLUpdateTopicsInput;
};

/** An object with an ID. */
export type GQLNode = {
  /** ID of the object. */
  id: Scalars['ID'];
};

/** Metadata for an audit entry with action oauth_application.* */
export type GQLOauthApplicationAuditEntryData = {
  /** The name of the OAuth Application. */
  oauthApplicationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the OAuth Application */
  oauthApplicationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the OAuth Application */
  oauthApplicationUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a oauth_application.create event. */
export type GQLOauthApplicationCreateAuditEntry = GQLAuditEntry & GQLNode & GQLOauthApplicationAuditEntryData & GQLOrganizationAuditEntryData & {
  __typename?: 'OauthApplicationCreateAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The application URL of the OAuth Application. */
  applicationUrl?: Maybe<Scalars['URI']>;
  /** The callback URL of the OAuth Application. */
  callbackUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The name of the OAuth Application. */
  oauthApplicationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the OAuth Application */
  oauthApplicationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the OAuth Application */
  oauthApplicationUrl?: Maybe<Scalars['URI']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The rate limit of the OAuth Application. */
  rateLimit?: Maybe<Scalars['Int']>;
  /** The state of the OAuth Application. */
  state?: Maybe<GQLOauthApplicationCreateAuditEntryState>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** The state of an OAuth Application when it was created. */
export enum GQLOauthApplicationCreateAuditEntryState {
  /** The OAuth Application was active and allowed to have OAuth Accesses. */
  Active = 'ACTIVE',
  /** The OAuth Application was in the process of being deleted. */
  PendingDeletion = 'PENDING_DELETION',
  /** The OAuth Application was suspended from generating OAuth Accesses due to abuse or security concerns. */
  Suspended = 'SUSPENDED'
}

/** The corresponding operation type for the action */
export enum GQLOperationType {
  /** An existing resource was accessed */
  Access = 'ACCESS',
  /** A resource performed an authentication event */
  Authentication = 'AUTHENTICATION',
  /** A new resource was created */
  Create = 'CREATE',
  /** An existing resource was modified */
  Modify = 'MODIFY',
  /** An existing resource was removed */
  Remove = 'REMOVE',
  /** An existing resource was restored */
  Restore = 'RESTORE',
  /** An existing resource was transferred between multiple resources */
  Transfer = 'TRANSFER'
}

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum GQLOrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/** Audit log entry for a org.add_billing_manager */
export type GQLOrgAddBillingManagerAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgAddBillingManagerAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The email address used to invite a billing manager for the organization. */
  invitationEmail?: Maybe<Scalars['String']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a org.add_member */
export type GQLOrgAddMemberAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgAddMemberAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The permission level of the member added to the organization. */
  permission?: Maybe<GQLOrgAddMemberAuditEntryPermission>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** The permissions available to members on an Organization. */
export enum GQLOrgAddMemberAuditEntryPermission {
  /** Can read, clone, push, and add collaborators to repositories. */
  Admin = 'ADMIN',
  /** Can read and clone repositories. */
  Read = 'READ'
}

/** Audit log entry for a org.block_user */
export type GQLOrgBlockUserAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgBlockUserAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The blocked user. */
  blockedUser?: Maybe<GQLUser>;
  /** The username of the blocked user. */
  blockedUserName?: Maybe<Scalars['String']>;
  /** The HTTP path for the blocked user. */
  blockedUserResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the blocked user. */
  blockedUserUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a org.config.disable_collaborators_only event. */
export type GQLOrgConfigDisableCollaboratorsOnlyAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgConfigDisableCollaboratorsOnlyAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a org.config.enable_collaborators_only event. */
export type GQLOrgConfigEnableCollaboratorsOnlyAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgConfigEnableCollaboratorsOnlyAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a org.create event. */
export type GQLOrgCreateAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgCreateAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The billing plan for the Organization. */
  billingPlan?: Maybe<GQLOrgCreateAuditEntryBillingPlan>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** The billing plans available for organizations. */
export enum GQLOrgCreateAuditEntryBillingPlan {
  /** Team Plan */
  Business = 'BUSINESS',
  /** Enterprise Cloud Plan */
  BusinessPlus = 'BUSINESS_PLUS',
  /** Free Plan */
  Free = 'FREE',
  /** Tiered Per Seat Plan */
  TieredPerSeat = 'TIERED_PER_SEAT',
  /** Legacy Unlimited Plan */
  Unlimited = 'UNLIMITED'
}

/** Audit log entry for a org.disable_oauth_app_restrictions event. */
export type GQLOrgDisableOauthAppRestrictionsAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgDisableOauthAppRestrictionsAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a org.disable_saml event. */
export type GQLOrgDisableSamlAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgDisableSamlAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  /** The SAML provider's digest algorithm URL. */
  digestMethodUrl?: Maybe<Scalars['URI']>;
  id: Scalars['ID'];
  /** The SAML provider's issuer URL. */
  issuerUrl?: Maybe<Scalars['URI']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The SAML provider's signature algorithm URL. */
  signatureMethodUrl?: Maybe<Scalars['URI']>;
  /** The SAML provider's single sign-on URL. */
  singleSignOnUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a org.disable_two_factor_requirement event. */
export type GQLOrgDisableTwoFactorRequirementAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgDisableTwoFactorRequirementAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a org.enable_oauth_app_restrictions event. */
export type GQLOrgEnableOauthAppRestrictionsAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgEnableOauthAppRestrictionsAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a org.enable_saml event. */
export type GQLOrgEnableSamlAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgEnableSamlAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  /** The SAML provider's digest algorithm URL. */
  digestMethodUrl?: Maybe<Scalars['URI']>;
  id: Scalars['ID'];
  /** The SAML provider's issuer URL. */
  issuerUrl?: Maybe<Scalars['URI']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The SAML provider's signature algorithm URL. */
  signatureMethodUrl?: Maybe<Scalars['URI']>;
  /** The SAML provider's single sign-on URL. */
  singleSignOnUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a org.enable_two_factor_requirement event. */
export type GQLOrgEnableTwoFactorRequirementAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgEnableTwoFactorRequirementAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a org.invite_member event. */
export type GQLOrgInviteMemberAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgInviteMemberAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  /** The email address of the organization invitation. */
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The organization invitation. */
  organizationInvitation?: Maybe<GQLOrganizationInvitation>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a org.invite_to_business event. */
export type GQLOrgInviteToBusinessAuditEntry = GQLAuditEntry & GQLEnterpriseAuditEntryData & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgInviteToBusinessAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a org.oauth_app_access_approved event. */
export type GQLOrgOauthAppAccessApprovedAuditEntry = GQLAuditEntry & GQLNode & GQLOauthApplicationAuditEntryData & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgOauthAppAccessApprovedAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The name of the OAuth Application. */
  oauthApplicationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the OAuth Application */
  oauthApplicationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the OAuth Application */
  oauthApplicationUrl?: Maybe<Scalars['URI']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a org.oauth_app_access_denied event. */
export type GQLOrgOauthAppAccessDeniedAuditEntry = GQLAuditEntry & GQLNode & GQLOauthApplicationAuditEntryData & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgOauthAppAccessDeniedAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The name of the OAuth Application. */
  oauthApplicationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the OAuth Application */
  oauthApplicationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the OAuth Application */
  oauthApplicationUrl?: Maybe<Scalars['URI']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a org.oauth_app_access_requested event. */
export type GQLOrgOauthAppAccessRequestedAuditEntry = GQLAuditEntry & GQLNode & GQLOauthApplicationAuditEntryData & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgOauthAppAccessRequestedAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The name of the OAuth Application. */
  oauthApplicationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the OAuth Application */
  oauthApplicationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the OAuth Application */
  oauthApplicationUrl?: Maybe<Scalars['URI']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a org.remove_billing_manager event. */
export type GQLOrgRemoveBillingManagerAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgRemoveBillingManagerAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The reason for the billing manager being removed. */
  reason?: Maybe<GQLOrgRemoveBillingManagerAuditEntryReason>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** The reason a billing manager was removed from an Organization. */
export enum GQLOrgRemoveBillingManagerAuditEntryReason {
  /** SAML external identity missing */
  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',
  /** SAML SSO enforcement requires an external identity */
  SamlSsoEnforcementRequiresExternalIdentity = 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY',
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE'
}

/** Audit log entry for a org.remove_member event. */
export type GQLOrgRemoveMemberAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgRemoveMemberAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The types of membership the member has with the organization. */
  membershipTypes?: Maybe<Array<GQLOrgRemoveMemberAuditEntryMembershipType>>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The reason for the member being removed. */
  reason?: Maybe<GQLOrgRemoveMemberAuditEntryReason>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** The type of membership a user has with an Organization. */
export enum GQLOrgRemoveMemberAuditEntryMembershipType {
  /**
   * Organization administrators have full access and can change several settings,
   * including the names of repositories that belong to the Organization and Owners
   * team membership. In addition, organization admins can delete the organization
   * and all of its repositories.
   */
  Admin = 'ADMIN',
  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */
  BillingManager = 'BILLING_MANAGER',
  /** A direct member is a user that is a member of the Organization. */
  DirectMember = 'DIRECT_MEMBER',
  /**
   * An outside collaborator is a person who isn't explicitly a member of the
   * Organization, but who has Read, Write, or Admin permissions to one or more
   * repositories in the organization.
   */
  OutsideCollaborator = 'OUTSIDE_COLLABORATOR',
  /**
   * An unaffiliated collaborator is a person who is not a member of the
   * Organization and does not have access to any repositories in the Organization.
   */
  Unaffiliated = 'UNAFFILIATED'
}

/** The reason a member was removed from an Organization. */
export enum GQLOrgRemoveMemberAuditEntryReason {
  /** SAML external identity missing */
  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',
  /** SAML SSO enforcement requires an external identity */
  SamlSsoEnforcementRequiresExternalIdentity = 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY',
  /** User was removed from organization during account recovery */
  TwoFactorAccountRecovery = 'TWO_FACTOR_ACCOUNT_RECOVERY',
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE',
  /** User account has been deleted */
  UserAccountDeleted = 'USER_ACCOUNT_DELETED'
}

/** Audit log entry for a org.remove_outside_collaborator event. */
export type GQLOrgRemoveOutsideCollaboratorAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgRemoveOutsideCollaboratorAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The types of membership the outside collaborator has with the organization. */
  membershipTypes?: Maybe<Array<GQLOrgRemoveOutsideCollaboratorAuditEntryMembershipType>>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The reason for the outside collaborator being removed from the Organization. */
  reason?: Maybe<GQLOrgRemoveOutsideCollaboratorAuditEntryReason>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** The type of membership a user has with an Organization. */
export enum GQLOrgRemoveOutsideCollaboratorAuditEntryMembershipType {
  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */
  BillingManager = 'BILLING_MANAGER',
  /**
   * An outside collaborator is a person who isn't explicitly a member of the
   * Organization, but who has Read, Write, or Admin permissions to one or more
   * repositories in the organization.
   */
  OutsideCollaborator = 'OUTSIDE_COLLABORATOR',
  /**
   * An unaffiliated collaborator is a person who is not a member of the
   * Organization and does not have access to any repositories in the organization.
   */
  Unaffiliated = 'UNAFFILIATED'
}

/** The reason an outside collaborator was removed from an Organization. */
export enum GQLOrgRemoveOutsideCollaboratorAuditEntryReason {
  /** SAML external identity missing */
  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE'
}

/** Audit log entry for a org.restore_member event. */
export type GQLOrgRestoreMemberAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgRestoreMemberAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The number of custom email routings for the restored member. */
  restoredCustomEmailRoutingsCount?: Maybe<Scalars['Int']>;
  /** The number of issue assignemnts for the restored member. */
  restoredIssueAssignmentsCount?: Maybe<Scalars['Int']>;
  /** Restored organization membership objects. */
  restoredMemberships?: Maybe<Array<GQLOrgRestoreMemberAuditEntryMembership>>;
  /** The number of restored memberships. */
  restoredMembershipsCount?: Maybe<Scalars['Int']>;
  /** The number of repositories of the restored member. */
  restoredRepositoriesCount?: Maybe<Scalars['Int']>;
  /** The number of starred repositories for the restored member. */
  restoredRepositoryStarsCount?: Maybe<Scalars['Int']>;
  /** The number of watched repositories for the restored member. */
  restoredRepositoryWatchesCount?: Maybe<Scalars['Int']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Types of memberships that can be restored for an Organization member. */
export type GQLOrgRestoreMemberAuditEntryMembership = GQLOrgRestoreMemberMembershipOrganizationAuditEntryData | GQLOrgRestoreMemberMembershipRepositoryAuditEntryData | GQLOrgRestoreMemberMembershipTeamAuditEntryData;

/** Metadata for an organization membership for org.restore_member actions */
export type GQLOrgRestoreMemberMembershipOrganizationAuditEntryData = GQLOrganizationAuditEntryData & {
  __typename?: 'OrgRestoreMemberMembershipOrganizationAuditEntryData';
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
};

/** Metadata for a repository membership for org.restore_member actions */
export type GQLOrgRestoreMemberMembershipRepositoryAuditEntryData = GQLRepositoryAuditEntryData & {
  __typename?: 'OrgRestoreMemberMembershipRepositoryAuditEntryData';
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
};

/** Metadata for a team membership for org.restore_member actions */
export type GQLOrgRestoreMemberMembershipTeamAuditEntryData = GQLTeamAuditEntryData & {
  __typename?: 'OrgRestoreMemberMembershipTeamAuditEntryData';
  /** The team associated with the action */
  team?: Maybe<GQLTeam>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a org.unblock_user */
export type GQLOrgUnblockUserAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgUnblockUserAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The user being unblocked by the organization. */
  blockedUser?: Maybe<GQLUser>;
  /** The username of the blocked user. */
  blockedUserName?: Maybe<Scalars['String']>;
  /** The HTTP path for the blocked user. */
  blockedUserResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the blocked user. */
  blockedUserUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a org.update_default_repository_permission */
export type GQLOrgUpdateDefaultRepositoryPermissionAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgUpdateDefaultRepositoryPermissionAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The new default repository permission level for the organization. */
  permission?: Maybe<GQLOrgUpdateDefaultRepositoryPermissionAuditEntryPermission>;
  /** The former default repository permission level for the organization. */
  permissionWas?: Maybe<GQLOrgUpdateDefaultRepositoryPermissionAuditEntryPermission>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** The default permission a repository can have in an Organization. */
export enum GQLOrgUpdateDefaultRepositoryPermissionAuditEntryPermission {
  /** Can read, clone, push, and add collaborators to repositories. */
  Admin = 'ADMIN',
  /** No default permission value. */
  None = 'NONE',
  /** Can read and clone repositories. */
  Read = 'READ',
  /** Can read, clone and push to repositories. */
  Write = 'WRITE'
}

/** Audit log entry for a org.update_member event. */
export type GQLOrgUpdateMemberAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgUpdateMemberAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The new member permission level for the organization. */
  permission?: Maybe<GQLOrgUpdateMemberAuditEntryPermission>;
  /** The former member permission level for the organization. */
  permissionWas?: Maybe<GQLOrgUpdateMemberAuditEntryPermission>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** The permissions available to members on an Organization. */
export enum GQLOrgUpdateMemberAuditEntryPermission {
  /** Can read, clone, push, and add collaborators to repositories. */
  Admin = 'ADMIN',
  /** Can read and clone repositories. */
  Read = 'READ'
}

/** Audit log entry for a org.update_member_repository_creation_permission event. */
export type GQLOrgUpdateMemberRepositoryCreationPermissionAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgUpdateMemberRepositoryCreationPermissionAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** Can members create repositories in the organization. */
  canCreateRepositories?: Maybe<Scalars['Boolean']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
  /** The permission for visibility level of repositories for this organization. */
  visibility?: Maybe<GQLOrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility>;
};

/** The permissions available for repository creation on an Organization. */
export enum GQLOrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility {
  /** All organization members are restricted from creating any repositories. */
  All = 'ALL',
  /** All organization members are restricted from creating public repositories. */
  Public = 'PUBLIC'
}

/** Audit log entry for a org.update_member_repository_invitation_permission event. */
export type GQLOrgUpdateMemberRepositoryInvitationPermissionAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'OrgUpdateMemberRepositoryInvitationPermissionAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** Can outside collaborators be invited to repositories in the organization. */
  canInviteOutsideCollaboratorsToRepositories?: Maybe<Scalars['Boolean']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type GQLOrganization = GQLActor & GQLMemberStatusable & GQLNode & GQLPackageOwner & GQLProfileOwner & GQLProjectOwner & GQLRegistryPackageOwner & GQLRegistryPackageSearch & GQLRepositoryOwner & GQLSponsorable & GQLUniformResourceLocatable & {
  __typename?: 'Organization';
  /** Determine if this repository owner has any items that can be pinned to their profile. */
  anyPinnableItems: Scalars['Boolean'];
  /** Audit log entries of the organization */
  auditLog: GQLOrganizationAuditEntryConnection;
  /** A URL pointing to the organization's public avatar. */
  avatarUrl: Scalars['URI'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The organization's public profile description. */
  description?: Maybe<Scalars['String']>;
  /** The organization's public profile description rendered to HTML. */
  descriptionHTML?: Maybe<Scalars['String']>;
  /** The organization's public email. */
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The setting value for whether the organization has an IP allow list enabled. */
  ipAllowListEnabledSetting: GQLIpAllowListEnabledSettingValue;
  /** The IP addresses that are allowed to access resources owned by the organization. */
  ipAllowListEntries: GQLIpAllowListEntryConnection;
  /** Whether the organization has verified its profile email and website. */
  isVerified: Scalars['Boolean'];
  /**
   * Showcases a selection of repositories and gists that the profile owner has
   * either curated or that have been selected automatically based on popularity.
   */
  itemShowcase: GQLProfileItemShowcase;
  /** The organization's public profile location. */
  location?: Maybe<Scalars['String']>;
  /** The organization's login name. */
  login: Scalars['String'];
  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
  memberStatuses: GQLUserStatusConnection;
  /** A list of users who are members of this organization. */
  membersWithRole: GQLOrganizationMemberConnection;
  /** The organization's public profile name. */
  name?: Maybe<Scalars['String']>;
  /** The HTTP path creating a new team */
  newTeamResourcePath: Scalars['URI'];
  /** The HTTP URL creating a new team */
  newTeamUrl: Scalars['URI'];
  /** The billing email for the organization. */
  organizationBillingEmail?: Maybe<Scalars['String']>;
  /** A list of packages under the owner. */
  packages: GQLPackageConnection;
  /** A list of users who have been invited to join this organization. */
  pendingMembers: GQLUserConnection;
  /** A list of repositories and gists this profile owner can pin to their profile. */
  pinnableItems: GQLPinnableItemConnection;
  /** A list of repositories and gists this profile owner has pinned to their profile */
  pinnedItems: GQLPinnableItemConnection;
  /** Returns how many more items this profile owner can pin to their profile. */
  pinnedItemsRemaining: Scalars['Int'];
  /** Find project by number. */
  project?: Maybe<GQLProject>;
  /** A list of projects under the owner. */
  projects: GQLProjectConnection;
  /** The HTTP path listing organization's projects */
  projectsResourcePath: Scalars['URI'];
  /** The HTTP URL listing organization's projects */
  projectsUrl: Scalars['URI'];
  /**
   * A list of registry packages under the owner.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageOwner` object instead. Removal on 2020-04-01 UTC.
   */
  registryPackages: GQLRegistryPackageConnection;
  /**
   * A list of registry packages for a particular search query.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageSearch` object instead. Removal on 2020-04-01 UTC.
   */
  registryPackagesForQuery: GQLRegistryPackageConnection;
  /** A list of repositories that the user owns. */
  repositories: GQLRepositoryConnection;
  /** Find Repository. */
  repository?: Maybe<GQLRepository>;
  /**
   * When true the organization requires all members, billing managers, and outside
   * collaborators to enable two-factor authentication.
   */
  requiresTwoFactorAuthentication?: Maybe<Scalars['Boolean']>;
  /** The HTTP path for this organization. */
  resourcePath: Scalars['URI'];
  /** The Organization's SAML identity providers */
  samlIdentityProvider?: Maybe<GQLOrganizationIdentityProvider>;
  /** The GitHub Sponsors listing for this user. */
  sponsorsListing?: Maybe<GQLSponsorsListing>;
  /** This object's sponsorships as the maintainer. */
  sponsorshipsAsMaintainer: GQLSponsorshipConnection;
  /** This object's sponsorships as the sponsor. */
  sponsorshipsAsSponsor: GQLSponsorshipConnection;
  /** Find an organization's team by its slug. */
  team?: Maybe<GQLTeam>;
  /** A list of teams in this organization. */
  teams: GQLTeamConnection;
  /** The HTTP path listing organization's teams */
  teamsResourcePath: Scalars['URI'];
  /** The HTTP URL listing organization's teams */
  teamsUrl: Scalars['URI'];
  /** The organization's Twitter username. */
  twitterUsername?: Maybe<Scalars['String']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this organization. */
  url: Scalars['URI'];
  /** Organization is adminable by the viewer. */
  viewerCanAdminister: Scalars['Boolean'];
  /** Can the viewer pin repositories and gists to the profile? */
  viewerCanChangePinnedItems: Scalars['Boolean'];
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean'];
  /** Viewer can create repositories on this organization */
  viewerCanCreateRepositories: Scalars['Boolean'];
  /** Viewer can create teams on this organization. */
  viewerCanCreateTeams: Scalars['Boolean'];
  /** Viewer is an active member of this organization. */
  viewerIsAMember: Scalars['Boolean'];
  /** The organization's public profile URL. */
  websiteUrl?: Maybe<Scalars['URI']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type GQLOrganizationAnyPinnableItemsArgs = {
  type?: Maybe<GQLPinnableItemType>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type GQLOrganizationAuditLogArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLAuditLogOrder>;
  query?: Maybe<Scalars['String']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type GQLOrganizationAvatarUrlArgs = {
  size?: Maybe<Scalars['Int']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type GQLOrganizationIpAllowListEntriesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLIpAllowListEntryOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type GQLOrganizationMemberStatusesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLUserStatusOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type GQLOrganizationMembersWithRoleArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type GQLOrganizationPackagesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  names?: Maybe<Array<Maybe<Scalars['String']>>>;
  orderBy?: Maybe<GQLPackageOrder>;
  repositoryId?: Maybe<Scalars['ID']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type GQLOrganizationPendingMembersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type GQLOrganizationPinnableItemsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  types?: Maybe<Array<GQLPinnableItemType>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type GQLOrganizationPinnedItemsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  types?: Maybe<Array<GQLPinnableItemType>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type GQLOrganizationProjectArgs = {
  number: Scalars['Int'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type GQLOrganizationProjectsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLProjectOrder>;
  search?: Maybe<Scalars['String']>;
  states?: Maybe<Array<GQLProjectState>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type GQLOrganizationRegistryPackagesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  names?: Maybe<Array<Maybe<Scalars['String']>>>;
  packageType?: Maybe<GQLRegistryPackageType>;
  publicOnly?: Maybe<Scalars['Boolean']>;
  registryPackageType?: Maybe<Scalars['String']>;
  repositoryId?: Maybe<Scalars['ID']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type GQLOrganizationRegistryPackagesForQueryArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  packageType?: Maybe<GQLRegistryPackageType>;
  query?: Maybe<Scalars['String']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type GQLOrganizationRepositoriesArgs = {
  affiliations?: Maybe<Array<Maybe<GQLRepositoryAffiliation>>>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  isFork?: Maybe<Scalars['Boolean']>;
  isLocked?: Maybe<Scalars['Boolean']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLRepositoryOrder>;
  ownerAffiliations?: Maybe<Array<Maybe<GQLRepositoryAffiliation>>>;
  privacy?: Maybe<GQLRepositoryPrivacy>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type GQLOrganizationRepositoryArgs = {
  name: Scalars['String'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type GQLOrganizationSponsorshipsAsMaintainerArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  includePrivate?: Maybe<Scalars['Boolean']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLSponsorshipOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type GQLOrganizationSponsorshipsAsSponsorArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLSponsorshipOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type GQLOrganizationTeamArgs = {
  slug: Scalars['String'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type GQLOrganizationTeamsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  ldapMapped?: Maybe<Scalars['Boolean']>;
  orderBy?: Maybe<GQLTeamOrder>;
  privacy?: Maybe<GQLTeamPrivacy>;
  query?: Maybe<Scalars['String']>;
  role?: Maybe<GQLTeamRole>;
  rootTeamsOnly?: Maybe<Scalars['Boolean']>;
  userLogins?: Maybe<Array<Scalars['String']>>;
};

/** An audit entry in an organization audit log. */
export type GQLOrganizationAuditEntry = GQLMembersCanDeleteReposClearAuditEntry | GQLMembersCanDeleteReposDisableAuditEntry | GQLMembersCanDeleteReposEnableAuditEntry | GQLOauthApplicationCreateAuditEntry | GQLOrgAddBillingManagerAuditEntry | GQLOrgAddMemberAuditEntry | GQLOrgBlockUserAuditEntry | GQLOrgConfigDisableCollaboratorsOnlyAuditEntry | GQLOrgConfigEnableCollaboratorsOnlyAuditEntry | GQLOrgCreateAuditEntry | GQLOrgDisableOauthAppRestrictionsAuditEntry | GQLOrgDisableSamlAuditEntry | GQLOrgDisableTwoFactorRequirementAuditEntry | GQLOrgEnableOauthAppRestrictionsAuditEntry | GQLOrgEnableSamlAuditEntry | GQLOrgEnableTwoFactorRequirementAuditEntry | GQLOrgInviteMemberAuditEntry | GQLOrgInviteToBusinessAuditEntry | GQLOrgOauthAppAccessApprovedAuditEntry | GQLOrgOauthAppAccessDeniedAuditEntry | GQLOrgOauthAppAccessRequestedAuditEntry | GQLOrgRemoveBillingManagerAuditEntry | GQLOrgRemoveMemberAuditEntry | GQLOrgRemoveOutsideCollaboratorAuditEntry | GQLOrgRestoreMemberAuditEntry | GQLOrgUnblockUserAuditEntry | GQLOrgUpdateDefaultRepositoryPermissionAuditEntry | GQLOrgUpdateMemberAuditEntry | GQLOrgUpdateMemberRepositoryCreationPermissionAuditEntry | GQLOrgUpdateMemberRepositoryInvitationPermissionAuditEntry | GQLPrivateRepositoryForkingDisableAuditEntry | GQLPrivateRepositoryForkingEnableAuditEntry | GQLRepoAccessAuditEntry | GQLRepoAddMemberAuditEntry | GQLRepoAddTopicAuditEntry | GQLRepoArchivedAuditEntry | GQLRepoChangeMergeSettingAuditEntry | GQLRepoConfigDisableAnonymousGitAccessAuditEntry | GQLRepoConfigDisableCollaboratorsOnlyAuditEntry | GQLRepoConfigDisableContributorsOnlyAuditEntry | GQLRepoConfigDisableSockpuppetDisallowedAuditEntry | GQLRepoConfigEnableAnonymousGitAccessAuditEntry | GQLRepoConfigEnableCollaboratorsOnlyAuditEntry | GQLRepoConfigEnableContributorsOnlyAuditEntry | GQLRepoConfigEnableSockpuppetDisallowedAuditEntry | GQLRepoConfigLockAnonymousGitAccessAuditEntry | GQLRepoConfigUnlockAnonymousGitAccessAuditEntry | GQLRepoCreateAuditEntry | GQLRepoDestroyAuditEntry | GQLRepoRemoveMemberAuditEntry | GQLRepoRemoveTopicAuditEntry | GQLRepositoryVisibilityChangeDisableAuditEntry | GQLRepositoryVisibilityChangeEnableAuditEntry | GQLTeamAddMemberAuditEntry | GQLTeamAddRepositoryAuditEntry | GQLTeamChangeParentTeamAuditEntry | GQLTeamRemoveMemberAuditEntry | GQLTeamRemoveRepositoryAuditEntry;

/** The connection type for OrganizationAuditEntry. */
export type GQLOrganizationAuditEntryConnection = {
  __typename?: 'OrganizationAuditEntryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLOrganizationAuditEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLOrganizationAuditEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Metadata for an audit entry with action org.* */
export type GQLOrganizationAuditEntryData = {
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
};

/** An edge in a connection. */
export type GQLOrganizationAuditEntryEdge = {
  __typename?: 'OrganizationAuditEntryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLOrganizationAuditEntry>;
};

/** The connection type for Organization. */
export type GQLOrganizationConnection = {
  __typename?: 'OrganizationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLOrganizationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLOrganization>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLOrganizationEdge = {
  __typename?: 'OrganizationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLOrganization>;
};

/** An Identity Provider configured to provision SAML and SCIM identities for Organizations */
export type GQLOrganizationIdentityProvider = GQLNode & {
  __typename?: 'OrganizationIdentityProvider';
  /** The digest algorithm used to sign SAML requests for the Identity Provider. */
  digestMethod?: Maybe<Scalars['URI']>;
  /** External Identities provisioned by this Identity Provider */
  externalIdentities: GQLExternalIdentityConnection;
  id: Scalars['ID'];
  /** The x509 certificate used by the Identity Provder to sign assertions and responses. */
  idpCertificate?: Maybe<Scalars['X509Certificate']>;
  /** The Issuer Entity ID for the SAML Identity Provider */
  issuer?: Maybe<Scalars['String']>;
  /** Organization this Identity Provider belongs to */
  organization?: Maybe<GQLOrganization>;
  /** The signature algorithm used to sign SAML requests for the Identity Provider. */
  signatureMethod?: Maybe<Scalars['URI']>;
  /** The URL endpoint for the Identity Provider's SAML SSO. */
  ssoUrl?: Maybe<Scalars['URI']>;
};


/** An Identity Provider configured to provision SAML and SCIM identities for Organizations */
export type GQLOrganizationIdentityProviderExternalIdentitiesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** An Invitation for a user to an organization. */
export type GQLOrganizationInvitation = GQLNode & {
  __typename?: 'OrganizationInvitation';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The email address of the user invited to the organization. */
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The type of invitation that was sent (e.g. email, user). */
  invitationType: GQLOrganizationInvitationType;
  /** The user who was invited to the organization. */
  invitee?: Maybe<GQLUser>;
  /** The user who created the invitation. */
  inviter: GQLUser;
  /** The organization the invite is for */
  organization: GQLOrganization;
  /** The user's pending role in the organization (e.g. member, owner). */
  role: GQLOrganizationInvitationRole;
};

/** The connection type for OrganizationInvitation. */
export type GQLOrganizationInvitationConnection = {
  __typename?: 'OrganizationInvitationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLOrganizationInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLOrganizationInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLOrganizationInvitationEdge = {
  __typename?: 'OrganizationInvitationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLOrganizationInvitation>;
};

/** The possible organization invitation roles. */
export enum GQLOrganizationInvitationRole {
  /** The user is invited to be an admin of the organization. */
  Admin = 'ADMIN',
  /** The user is invited to be a billing manager of the organization. */
  BillingManager = 'BILLING_MANAGER',
  /** The user is invited to be a direct member of the organization. */
  DirectMember = 'DIRECT_MEMBER',
  /** The user's previous role will be reinstated. */
  Reinstate = 'REINSTATE'
}

/** The possible organization invitation types. */
export enum GQLOrganizationInvitationType {
  /** The invitation was to an email address. */
  Email = 'EMAIL',
  /** The invitation was to an existing user. */
  User = 'USER'
}

/** The connection type for User. */
export type GQLOrganizationMemberConnection = {
  __typename?: 'OrganizationMemberConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLOrganizationMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLUser>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a user within an organization. */
export type GQLOrganizationMemberEdge = {
  __typename?: 'OrganizationMemberEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** Whether the organization member has two factor enabled or not. Returns null if information is not available to viewer. */
  hasTwoFactorEnabled?: Maybe<Scalars['Boolean']>;
  /** The item at the end of the edge. */
  node?: Maybe<GQLUser>;
  /** The role this user has in the organization. */
  role?: Maybe<GQLOrganizationMemberRole>;
};

/** The possible roles within an organization for its members. */
export enum GQLOrganizationMemberRole {
  /** The user is an administrator of the organization. */
  Admin = 'ADMIN',
  /** The user is a member of the organization. */
  Member = 'MEMBER'
}

/** The possible values for the members can create repositories setting on an organization. */
export enum GQLOrganizationMembersCanCreateRepositoriesSettingValue {
  /** Members will be able to create public and private repositories. */
  All = 'ALL',
  /** Members will not be able to create public or private repositories. */
  Disabled = 'DISABLED',
  /** Members will be able to create only private repositories. */
  Private = 'PRIVATE'
}

/** Ordering options for organization connections. */
export type GQLOrganizationOrder = {
  /** The ordering direction. */
  direction: GQLOrderDirection;
  /** The field to order organizations by. */
  field: GQLOrganizationOrderField;
};

/** Properties by which organization connections can be ordered. */
export enum GQLOrganizationOrderField {
  /** Order organizations by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order organizations by login */
  Login = 'LOGIN'
}

/** An organization teams hovercard context */
export type GQLOrganizationTeamsHovercardContext = GQLHovercardContext & {
  __typename?: 'OrganizationTeamsHovercardContext';
  /** A string describing this context */
  message: Scalars['String'];
  /** An octicon to accompany this context */
  octicon: Scalars['String'];
  /** Teams in this organization the user is a member of that are relevant */
  relevantTeams: GQLTeamConnection;
  /** The path for the full team list for this user */
  teamsResourcePath: Scalars['URI'];
  /** The URL for the full team list for this user */
  teamsUrl: Scalars['URI'];
  /** The total number of teams the user is on in the organization */
  totalTeamCount: Scalars['Int'];
};


/** An organization teams hovercard context */
export type GQLOrganizationTeamsHovercardContextRelevantTeamsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** An organization list hovercard context */
export type GQLOrganizationsHovercardContext = GQLHovercardContext & {
  __typename?: 'OrganizationsHovercardContext';
  /** A string describing this context */
  message: Scalars['String'];
  /** An octicon to accompany this context */
  octicon: Scalars['String'];
  /** Organizations this user is a member of that are relevant */
  relevantOrganizations: GQLOrganizationConnection;
  /** The total number of organizations this user is in */
  totalOrganizationCount: Scalars['Int'];
};


/** An organization list hovercard context */
export type GQLOrganizationsHovercardContextRelevantOrganizationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** Information for an uploaded package. */
export type GQLPackage = GQLNode & {
  __typename?: 'Package';
  id: Scalars['ID'];
  /** Find the latest version for the package. */
  latestVersion?: Maybe<GQLPackageVersion>;
  /** Identifies the name of the package. */
  name: Scalars['String'];
  /** Identifies the type of the package. */
  packageType: GQLPackageType;
  /** The repository this package belongs to. */
  repository?: Maybe<GQLRepository>;
  /** Statistics about package activity. */
  statistics?: Maybe<GQLPackageStatistics>;
  /** Find package version by version string. */
  version?: Maybe<GQLPackageVersion>;
  /** list of versions for this package */
  versions: GQLPackageVersionConnection;
};


/** Information for an uploaded package. */
export type GQLPackageVersionArgs = {
  version: Scalars['String'];
};


/** Information for an uploaded package. */
export type GQLPackageVersionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLPackageVersionOrder>;
};

/** The connection type for Package. */
export type GQLPackageConnection = {
  __typename?: 'PackageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLPackageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLPackage>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLPackageEdge = {
  __typename?: 'PackageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLPackage>;
};

/** A file in a package version. */
export type GQLPackageFile = GQLNode & {
  __typename?: 'PackageFile';
  id: Scalars['ID'];
  /** MD5 hash of the file. */
  md5?: Maybe<Scalars['String']>;
  /** Name of the file. */
  name: Scalars['String'];
  /** The package version this file belongs to. */
  packageVersion?: Maybe<GQLPackageVersion>;
  /** SHA1 hash of the file. */
  sha1?: Maybe<Scalars['String']>;
  /** SHA256 hash of the file. */
  sha256?: Maybe<Scalars['String']>;
  /** Size of the file in bytes. */
  size?: Maybe<Scalars['Int']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** URL to download the asset. */
  url?: Maybe<Scalars['URI']>;
};

/** The connection type for PackageFile. */
export type GQLPackageFileConnection = {
  __typename?: 'PackageFileConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLPackageFileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLPackageFile>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLPackageFileEdge = {
  __typename?: 'PackageFileEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLPackageFile>;
};

/** Ways in which lists of package files can be ordered upon return. */
export type GQLPackageFileOrder = {
  /** The direction in which to order package files by the specified field. */
  direction?: Maybe<GQLOrderDirection>;
  /** The field in which to order package files by. */
  field?: Maybe<GQLPackageFileOrderField>;
};

/** Properties by which package file connections can be ordered. */
export enum GQLPackageFileOrderField {
  /** Order package files by creation time */
  CreatedAt = 'CREATED_AT'
}

/** Ways in which lists of packages can be ordered upon return. */
export type GQLPackageOrder = {
  /** The direction in which to order packages by the specified field. */
  direction?: Maybe<GQLOrderDirection>;
  /** The field in which to order packages by. */
  field?: Maybe<GQLPackageOrderField>;
};

/** Properties by which package connections can be ordered. */
export enum GQLPackageOrderField {
  /** Order packages by creation time */
  CreatedAt = 'CREATED_AT'
}

/** Represents an owner of a package. */
export type GQLPackageOwner = {
  id: Scalars['ID'];
  /** A list of packages under the owner. */
  packages: GQLPackageConnection;
};


/** Represents an owner of a package. */
export type GQLPackageOwnerPackagesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  names?: Maybe<Array<Maybe<Scalars['String']>>>;
  orderBy?: Maybe<GQLPackageOrder>;
  repositoryId?: Maybe<Scalars['ID']>;
};

/** Represents a object that contains package activity statistics such as downloads. */
export type GQLPackageStatistics = {
  __typename?: 'PackageStatistics';
  /** Number of times the package was downloaded since it was created. */
  downloadsTotalCount: Scalars['Int'];
};

/** A version tag contains the mapping between a tag name and a version. */
export type GQLPackageTag = GQLNode & {
  __typename?: 'PackageTag';
  id: Scalars['ID'];
  /** Identifies the tag name of the version. */
  name: Scalars['String'];
  /** Version that the tag is associated with. */
  version?: Maybe<GQLPackageVersion>;
};

/** The possible types of a package. */
export enum GQLPackageType {
  /** A debian package. */
  Debian = 'DEBIAN',
  /** A docker image. */
  Docker = 'DOCKER',
  /** A maven package. */
  Maven = 'MAVEN',
  /** An npm package. */
  Npm = 'NPM',
  /** A nuget package. */
  Nuget = 'NUGET',
  /** A python package. */
  Pypi = 'PYPI',
  /** A rubygems package. */
  Rubygems = 'RUBYGEMS'
}

/** Information about a specific package version. */
export type GQLPackageVersion = GQLNode & {
  __typename?: 'PackageVersion';
  /** List of files associated with this package version */
  files: GQLPackageFileConnection;
  id: Scalars['ID'];
  /** The package associated with this version. */
  package?: Maybe<GQLPackage>;
  /** The platform this version was built for. */
  platform?: Maybe<Scalars['String']>;
  /** Whether or not this version is a pre-release. */
  preRelease: Scalars['Boolean'];
  /** The README of this package version. */
  readme?: Maybe<Scalars['String']>;
  /** The release associated with this package version. */
  release?: Maybe<GQLRelease>;
  /** Statistics about package activity. */
  statistics?: Maybe<GQLPackageVersionStatistics>;
  /** The package version summary. */
  summary?: Maybe<Scalars['String']>;
  /** The version string. */
  version: Scalars['String'];
};


/** Information about a specific package version. */
export type GQLPackageVersionFilesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLPackageFileOrder>;
};

/** The connection type for PackageVersion. */
export type GQLPackageVersionConnection = {
  __typename?: 'PackageVersionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLPackageVersionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLPackageVersion>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLPackageVersionEdge = {
  __typename?: 'PackageVersionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLPackageVersion>;
};

/** Ways in which lists of package versions can be ordered upon return. */
export type GQLPackageVersionOrder = {
  /** The direction in which to order package versions by the specified field. */
  direction?: Maybe<GQLOrderDirection>;
  /** The field in which to order package versions by. */
  field?: Maybe<GQLPackageVersionOrderField>;
};

/** Properties by which package version connections can be ordered. */
export enum GQLPackageVersionOrderField {
  /** Order package versions by creation time */
  CreatedAt = 'CREATED_AT'
}

/** Represents a object that contains package version activity statistics such as downloads. */
export type GQLPackageVersionStatistics = {
  __typename?: 'PackageVersionStatistics';
  /** Number of times the package was downloaded since it was created. */
  downloadsTotalCount: Scalars['Int'];
};

/** Information about pagination in a connection. */
export type GQLPageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
};

/** Types that can grant permissions on a repository to a user */
export type GQLPermissionGranter = GQLOrganization | GQLRepository | GQLTeam;

/** A level of permission and source for a user's access to a repository. */
export type GQLPermissionSource = {
  __typename?: 'PermissionSource';
  /** The organization the repository belongs to. */
  organization: GQLOrganization;
  /** The level of access this source has granted to the user. */
  permission: GQLDefaultRepositoryPermissionField;
  /** The source of this permission. */
  source: GQLPermissionGranter;
};

/** Autogenerated input type of PinIssue */
export type GQLPinIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the issue to be pinned */
  issueId: Scalars['ID'];
};

/** Autogenerated return type of PinIssue */
export type GQLPinIssuePayload = {
  __typename?: 'PinIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The issue that was pinned */
  issue?: Maybe<GQLIssue>;
};

/** Types that can be pinned to a profile page. */
export type GQLPinnableItem = GQLGist | GQLRepository;

/** The connection type for PinnableItem. */
export type GQLPinnableItemConnection = {
  __typename?: 'PinnableItemConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLPinnableItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLPinnableItem>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLPinnableItemEdge = {
  __typename?: 'PinnableItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLPinnableItem>;
};

/** Represents items that can be pinned to a profile page or dashboard. */
export enum GQLPinnableItemType {
  /** A gist. */
  Gist = 'GIST',
  /** An issue. */
  Issue = 'ISSUE',
  /** An organization. */
  Organization = 'ORGANIZATION',
  /** A project. */
  Project = 'PROJECT',
  /** A pull request. */
  PullRequest = 'PULL_REQUEST',
  /** A repository. */
  Repository = 'REPOSITORY',
  /** A team. */
  Team = 'TEAM',
  /** A user. */
  User = 'USER'
}

/** Represents a 'pinned' event on a given issue or pull request. */
export type GQLPinnedEvent = GQLNode & {
  __typename?: 'PinnedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Identifies the issue associated with the event. */
  issue: GQLIssue;
};

/** A Pinned Issue is a issue pinned to a repository's index page. */
export type GQLPinnedIssue = GQLNode & {
  __typename?: 'PinnedIssue';
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The issue that was pinned. */
  issue: GQLIssue;
  /** The actor that pinned this issue. */
  pinnedBy: GQLActor;
  /** The repository that this issue was pinned to. */
  repository: GQLRepository;
};

/** The connection type for PinnedIssue. */
export type GQLPinnedIssueConnection = {
  __typename?: 'PinnedIssueConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLPinnedIssueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLPinnedIssue>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLPinnedIssueEdge = {
  __typename?: 'PinnedIssueEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLPinnedIssue>;
};


/** Audit log entry for a private_repository_forking.disable event. */
export type GQLPrivateRepositoryForkingDisableAuditEntry = GQLAuditEntry & GQLEnterpriseAuditEntryData & GQLNode & GQLOrganizationAuditEntryData & GQLRepositoryAuditEntryData & {
  __typename?: 'PrivateRepositoryForkingDisableAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a private_repository_forking.enable event. */
export type GQLPrivateRepositoryForkingEnableAuditEntry = GQLAuditEntry & GQLEnterpriseAuditEntryData & GQLNode & GQLOrganizationAuditEntryData & GQLRepositoryAuditEntryData & {
  __typename?: 'PrivateRepositoryForkingEnableAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/**
 * A curatable list of repositories relating to a repository owner, which defaults
 * to showing the most popular repositories they own.
 */
export type GQLProfileItemShowcase = {
  __typename?: 'ProfileItemShowcase';
  /** Whether or not the owner has pinned any repositories or gists. */
  hasPinnedItems: Scalars['Boolean'];
  /**
   * The repositories and gists in the showcase. If the profile owner has any
   * pinned items, those will be returned. Otherwise, the profile owner's popular
   * repositories will be returned.
   */
  items: GQLPinnableItemConnection;
};


/**
 * A curatable list of repositories relating to a repository owner, which defaults
 * to showing the most popular repositories they own.
 */
export type GQLProfileItemShowcaseItemsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** Represents any entity on GitHub that has a profile page. */
export type GQLProfileOwner = {
  /** Determine if this repository owner has any items that can be pinned to their profile. */
  anyPinnableItems: Scalars['Boolean'];
  /** The public profile email. */
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /**
   * Showcases a selection of repositories and gists that the profile owner has
   * either curated or that have been selected automatically based on popularity.
   */
  itemShowcase: GQLProfileItemShowcase;
  /** The public profile location. */
  location?: Maybe<Scalars['String']>;
  /** The username used to login. */
  login: Scalars['String'];
  /** The public profile name. */
  name?: Maybe<Scalars['String']>;
  /** A list of repositories and gists this profile owner can pin to their profile. */
  pinnableItems: GQLPinnableItemConnection;
  /** A list of repositories and gists this profile owner has pinned to their profile */
  pinnedItems: GQLPinnableItemConnection;
  /** Returns how many more items this profile owner can pin to their profile. */
  pinnedItemsRemaining: Scalars['Int'];
  /** Can the viewer pin repositories and gists to the profile? */
  viewerCanChangePinnedItems: Scalars['Boolean'];
  /** The public profile website URL. */
  websiteUrl?: Maybe<Scalars['URI']>;
};


/** Represents any entity on GitHub that has a profile page. */
export type GQLProfileOwnerAnyPinnableItemsArgs = {
  type?: Maybe<GQLPinnableItemType>;
};


/** Represents any entity on GitHub that has a profile page. */
export type GQLProfileOwnerPinnableItemsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  types?: Maybe<Array<GQLPinnableItemType>>;
};


/** Represents any entity on GitHub that has a profile page. */
export type GQLProfileOwnerPinnedItemsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  types?: Maybe<Array<GQLPinnableItemType>>;
};

/** Projects manage issues, pull requests and notes within a project owner. */
export type GQLProject = GQLClosable & GQLNode & GQLUpdatable & {
  __typename?: 'Project';
  /** The project's description body. */
  body?: Maybe<Scalars['String']>;
  /** The projects description body rendered to HTML. */
  bodyHTML: Scalars['HTML'];
  /** `true` if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']>;
  /** List of columns in the project */
  columns: GQLProjectColumnConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The actor who originally created the project. */
  creator?: Maybe<GQLActor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The project's name. */
  name: Scalars['String'];
  /** The project's number. */
  number: Scalars['Int'];
  /** The project's owner. Currently limited to repositories, organizations, and users. */
  owner: GQLProjectOwner;
  /** List of pending cards in this project */
  pendingCards: GQLProjectCardConnection;
  /** The HTTP path for this project */
  resourcePath: Scalars['URI'];
  /** Whether the project is open or closed. */
  state: GQLProjectState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this project */
  url: Scalars['URI'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
};


/** Projects manage issues, pull requests and notes within a project owner. */
export type GQLProjectColumnsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** Projects manage issues, pull requests and notes within a project owner. */
export type GQLProjectPendingCardsArgs = {
  after?: Maybe<Scalars['String']>;
  archivedStates?: Maybe<Array<Maybe<GQLProjectCardArchivedState>>>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** A card in a project. */
export type GQLProjectCard = GQLNode & {
  __typename?: 'ProjectCard';
  /**
   * The project column this card is associated under. A card may only belong to one
   * project column at a time. The column field will be null if the card is created
   * in a pending state and has yet to be associated with a column. Once cards are
   * associated with a column, they will not become pending in the future.
   */
  column?: Maybe<GQLProjectColumn>;
  /** The card content item */
  content?: Maybe<GQLProjectCardItem>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The actor who created this card */
  creator?: Maybe<GQLActor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** Whether the card is archived */
  isArchived: Scalars['Boolean'];
  /** The card note */
  note?: Maybe<Scalars['String']>;
  /** The project that contains this card. */
  project: GQLProject;
  /** The HTTP path for this card */
  resourcePath: Scalars['URI'];
  /** The state of ProjectCard */
  state?: Maybe<GQLProjectCardState>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this card */
  url: Scalars['URI'];
};

/** The possible archived states of a project card. */
export enum GQLProjectCardArchivedState {
  /** A project card that is archived */
  Archived = 'ARCHIVED',
  /** A project card that is not archived */
  NotArchived = 'NOT_ARCHIVED'
}

/** The connection type for ProjectCard. */
export type GQLProjectCardConnection = {
  __typename?: 'ProjectCardConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLProjectCardEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLProjectCard>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLProjectCardEdge = {
  __typename?: 'ProjectCardEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLProjectCard>;
};

/** An issue or PR and its owning repository to be used in a project card. */
export type GQLProjectCardImport = {
  /** The issue or pull request number. */
  number: Scalars['Int'];
  /** Repository name with owner (owner/repository). */
  repository: Scalars['String'];
};

/** Types that can be inside Project Cards. */
export type GQLProjectCardItem = GQLIssue | GQLPullRequest;

/** Various content states of a ProjectCard */
export enum GQLProjectCardState {
  /** The card has content only. */
  ContentOnly = 'CONTENT_ONLY',
  /** The card has a note only. */
  NoteOnly = 'NOTE_ONLY',
  /** The card is redacted. */
  Redacted = 'REDACTED'
}

/** A column inside a project. */
export type GQLProjectColumn = GQLNode & {
  __typename?: 'ProjectColumn';
  /** List of cards in the column */
  cards: GQLProjectCardConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The project column's name. */
  name: Scalars['String'];
  /** The project that contains this column. */
  project: GQLProject;
  /** The semantic purpose of the column */
  purpose?: Maybe<GQLProjectColumnPurpose>;
  /** The HTTP path for this project column */
  resourcePath: Scalars['URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this project column */
  url: Scalars['URI'];
};


/** A column inside a project. */
export type GQLProjectColumnCardsArgs = {
  after?: Maybe<Scalars['String']>;
  archivedStates?: Maybe<Array<Maybe<GQLProjectCardArchivedState>>>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** The connection type for ProjectColumn. */
export type GQLProjectColumnConnection = {
  __typename?: 'ProjectColumnConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLProjectColumnEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLProjectColumn>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLProjectColumnEdge = {
  __typename?: 'ProjectColumnEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLProjectColumn>;
};

/** A project column and a list of its issues and PRs. */
export type GQLProjectColumnImport = {
  /** The name of the column. */
  columnName: Scalars['String'];
  /** A list of issues and pull requests in the column. */
  issues?: Maybe<Array<GQLProjectCardImport>>;
  /** The position of the column, starting from 0. */
  position: Scalars['Int'];
};

/** The semantic purpose of the column - todo, in progress, or done. */
export enum GQLProjectColumnPurpose {
  /** The column contains cards which are complete */
  Done = 'DONE',
  /** The column contains cards which are currently being worked on */
  InProgress = 'IN_PROGRESS',
  /** The column contains cards still to be worked on */
  Todo = 'TODO'
}

/** A list of projects associated with the owner. */
export type GQLProjectConnection = {
  __typename?: 'ProjectConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLProject>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLProjectEdge = {
  __typename?: 'ProjectEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLProject>;
};

/** Ways in which lists of projects can be ordered upon return. */
export type GQLProjectOrder = {
  /** The direction in which to order projects by the specified field. */
  direction: GQLOrderDirection;
  /** The field in which to order projects by. */
  field: GQLProjectOrderField;
};

/** Properties by which project connections can be ordered. */
export enum GQLProjectOrderField {
  /** Order projects by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order projects by name */
  Name = 'NAME',
  /** Order projects by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** Represents an owner of a Project. */
export type GQLProjectOwner = {
  id: Scalars['ID'];
  /** Find project by number. */
  project?: Maybe<GQLProject>;
  /** A list of projects under the owner. */
  projects: GQLProjectConnection;
  /** The HTTP path listing owners projects */
  projectsResourcePath: Scalars['URI'];
  /** The HTTP URL listing owners projects */
  projectsUrl: Scalars['URI'];
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean'];
};


/** Represents an owner of a Project. */
export type GQLProjectOwnerProjectArgs = {
  number: Scalars['Int'];
};


/** Represents an owner of a Project. */
export type GQLProjectOwnerProjectsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLProjectOrder>;
  search?: Maybe<Scalars['String']>;
  states?: Maybe<Array<GQLProjectState>>;
};

/** State of the project; either 'open' or 'closed' */
export enum GQLProjectState {
  /** The project is closed. */
  Closed = 'CLOSED',
  /** The project is open. */
  Open = 'OPEN'
}

/** GitHub-provided templates for Projects */
export enum GQLProjectTemplate {
  /** Create a board with v2 triggers to automatically move cards across To do, In progress and Done columns. */
  AutomatedKanbanV2 = 'AUTOMATED_KANBAN_V2',
  /** Create a board with triggers to automatically move cards across columns with review automation. */
  AutomatedReviewsKanban = 'AUTOMATED_REVIEWS_KANBAN',
  /** Create a board with columns for To do, In progress and Done. */
  BasicKanban = 'BASIC_KANBAN',
  /** Create a board to triage and prioritize bugs with To do, priority, and Done columns. */
  BugTriage = 'BUG_TRIAGE'
}

/** A user's public key. */
export type GQLPublicKey = GQLNode & {
  __typename?: 'PublicKey';
  /** The last time this authorization was used to perform an action. Values will be null for keys not owned by the user. */
  accessedAt?: Maybe<Scalars['DateTime']>;
  /**
   * Identifies the date and time when the key was created. Keys created before
   * March 5th, 2014 have inaccurate values. Values will be null for keys not owned by the user.
   */
  createdAt?: Maybe<Scalars['DateTime']>;
  /** The fingerprint for this PublicKey. */
  fingerprint: Scalars['String'];
  id: Scalars['ID'];
  /** Whether this PublicKey is read-only or not. Values will be null for keys not owned by the user. */
  isReadOnly?: Maybe<Scalars['Boolean']>;
  /** The public key string. */
  key: Scalars['String'];
  /**
   * Identifies the date and time when the key was updated. Keys created before
   * March 5th, 2014 may have inaccurate values. Values will be null for keys not
   * owned by the user.
   */
  updatedAt?: Maybe<Scalars['DateTime']>;
};

/** The connection type for PublicKey. */
export type GQLPublicKeyConnection = {
  __typename?: 'PublicKeyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLPublicKeyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLPublicKey>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLPublicKeyEdge = {
  __typename?: 'PublicKeyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLPublicKey>;
};

/** A repository pull request. */
export type GQLPullRequest = GQLAssignable & GQLClosable & GQLComment & GQLLabelable & GQLLockable & GQLNode & GQLReactable & GQLRepositoryNode & GQLSubscribable & GQLUniformResourceLocatable & GQLUpdatable & GQLUpdatableComment & {
  __typename?: 'PullRequest';
  /** Reason that the conversation was locked. */
  activeLockReason?: Maybe<GQLLockReason>;
  /** The number of additions in this pull request. */
  additions: Scalars['Int'];
  /** A list of Users assigned to this object. */
  assignees: GQLUserConnection;
  /** The actor who authored the comment. */
  author?: Maybe<GQLActor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: GQLCommentAuthorAssociation;
  /** Identifies the base Ref associated with the pull request. */
  baseRef?: Maybe<GQLRef>;
  /** Identifies the name of the base Ref associated with the pull request, even if the ref has been deleted. */
  baseRefName: Scalars['String'];
  /** Identifies the oid of the base ref associated with the pull request, even if the ref has been deleted. */
  baseRefOid: Scalars['GitObjectID'];
  /** The repository associated with this pull request's base Ref. */
  baseRepository?: Maybe<GQLRepository>;
  /** The body as Markdown. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** Whether or not the pull request is rebaseable. */
  canBeRebased: Scalars['Boolean'];
  /** The number of changed files in this pull request. */
  changedFiles: Scalars['Int'];
  /** The HTTP path for the checks of this pull request. */
  checksResourcePath: Scalars['URI'];
  /** The HTTP URL for the checks of this pull request. */
  checksUrl: Scalars['URI'];
  /** `true` if the pull request is closed */
  closed: Scalars['Boolean'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']>;
  /** A list of comments associated with the pull request. */
  comments: GQLIssueCommentConnection;
  /** A list of commits present in this pull request's head branch not present in the base branch. */
  commits: GQLPullRequestCommitConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The number of deletions in this pull request. */
  deletions: Scalars['Int'];
  /** The actor who edited this pull request's body. */
  editor?: Maybe<GQLActor>;
  /** Lists the files changed within this pull request. */
  files?: Maybe<GQLPullRequestChangedFileConnection>;
  /** Identifies the head Ref associated with the pull request. */
  headRef?: Maybe<GQLRef>;
  /** Identifies the name of the head Ref associated with the pull request, even if the ref has been deleted. */
  headRefName: Scalars['String'];
  /** Identifies the oid of the head ref associated with the pull request, even if the ref has been deleted. */
  headRefOid: Scalars['GitObjectID'];
  /** The repository associated with this pull request's head Ref. */
  headRepository?: Maybe<GQLRepository>;
  /** The owner of the repository associated with this pull request's head Ref. */
  headRepositoryOwner?: Maybe<GQLRepositoryOwner>;
  /** The hovercard information for this issue */
  hovercard: GQLHovercard;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** The head and base repositories are different. */
  isCrossRepository: Scalars['Boolean'];
  /** Identifies if the pull request is a draft. */
  isDraft: Scalars['Boolean'];
  /** A list of labels associated with the object. */
  labels?: Maybe<GQLLabelConnection>;
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** `true` if the pull request is locked */
  locked: Scalars['Boolean'];
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify: Scalars['Boolean'];
  /** The commit that was created when this pull request was merged. */
  mergeCommit?: Maybe<GQLCommit>;
  /** Detailed information about the current pull request merge state status. */
  mergeStateStatus: GQLMergeStateStatus;
  /** Whether or not the pull request can be merged based on the existence of merge conflicts. */
  mergeable: GQLMergeableState;
  /** Whether or not the pull request was merged. */
  merged: Scalars['Boolean'];
  /** The date and time that the pull request was merged. */
  mergedAt?: Maybe<Scalars['DateTime']>;
  /** The actor who merged the pull request. */
  mergedBy?: Maybe<GQLActor>;
  /** Identifies the milestone associated with the pull request. */
  milestone?: Maybe<GQLMilestone>;
  /** Identifies the pull request number. */
  number: Scalars['Int'];
  /** A list of Users that are participating in the Pull Request conversation. */
  participants: GQLUserConnection;
  /** The permalink to the pull request. */
  permalink: Scalars['URI'];
  /**
   * The commit that GitHub automatically generated to test if this pull request
   * could be merged. This field will not return a value if the pull request is
   * merged, or if the test merge commit is still being generated. See the
   * `mergeable` field for more details on the mergeability of the pull request.
   */
  potentialMergeCommit?: Maybe<GQLCommit>;
  /** List of project cards associated with this pull request. */
  projectCards: GQLProjectCardConnection;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<GQLReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: GQLReactionConnection;
  /** The repository associated with this node. */
  repository: GQLRepository;
  /** The HTTP path for this pull request. */
  resourcePath: Scalars['URI'];
  /** The HTTP path for reverting this pull request. */
  revertResourcePath: Scalars['URI'];
  /** The HTTP URL for reverting this pull request. */
  revertUrl: Scalars['URI'];
  /** The current status of this pull request with respect to code review. */
  reviewDecision?: Maybe<GQLPullRequestReviewDecision>;
  /** A list of review requests associated with the pull request. */
  reviewRequests?: Maybe<GQLReviewRequestConnection>;
  /** The list of all review threads for this pull request. */
  reviewThreads: GQLPullRequestReviewThreadConnection;
  /** A list of reviews associated with the pull request. */
  reviews?: Maybe<GQLPullRequestReviewConnection>;
  /** Identifies the state of the pull request. */
  state: GQLPullRequestState;
  /** A list of reviewer suggestions based on commit history and past review comments. */
  suggestedReviewers: Array<Maybe<GQLSuggestedReviewer>>;
  /**
   * A list of events, comments, commits, etc. associated with the pull request.
   * @deprecated `timeline` will be removed Use PullRequest.timelineItems instead. Removal on 2020-10-01 UTC.
   */
  timeline: GQLPullRequestTimelineConnection;
  /** A list of events, comments, commits, etc. associated with the pull request. */
  timelineItems: GQLPullRequestTimelineItemsConnection;
  /** Identifies the pull request title. */
  title: Scalars['String'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this pull request. */
  url: Scalars['URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<GQLUserContentEditConnection>;
  /** Whether or not the viewer can apply suggestion. */
  viewerCanApplySuggestion: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<GQLCommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<GQLSubscriptionState>;
};


/** A repository pull request. */
export type GQLPullRequestAssigneesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A repository pull request. */
export type GQLPullRequestCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A repository pull request. */
export type GQLPullRequestCommitsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A repository pull request. */
export type GQLPullRequestFilesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A repository pull request. */
export type GQLPullRequestHovercardArgs = {
  includeNotificationContexts?: Maybe<Scalars['Boolean']>;
};


/** A repository pull request. */
export type GQLPullRequestLabelsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLLabelOrder>;
};


/** A repository pull request. */
export type GQLPullRequestParticipantsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A repository pull request. */
export type GQLPullRequestProjectCardsArgs = {
  after?: Maybe<Scalars['String']>;
  archivedStates?: Maybe<Array<Maybe<GQLProjectCardArchivedState>>>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A repository pull request. */
export type GQLPullRequestReactionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  content?: Maybe<GQLReactionContent>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLReactionOrder>;
};


/** A repository pull request. */
export type GQLPullRequestReviewRequestsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A repository pull request. */
export type GQLPullRequestReviewThreadsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A repository pull request. */
export type GQLPullRequestReviewsArgs = {
  after?: Maybe<Scalars['String']>;
  author?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  states?: Maybe<Array<GQLPullRequestReviewState>>;
};


/** A repository pull request. */
export type GQLPullRequestTimelineArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  since?: Maybe<Scalars['DateTime']>;
};


/** A repository pull request. */
export type GQLPullRequestTimelineItemsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  itemTypes?: Maybe<Array<GQLPullRequestTimelineItemsItemType>>;
  last?: Maybe<Scalars['Int']>;
  since?: Maybe<Scalars['DateTime']>;
  skip?: Maybe<Scalars['Int']>;
};


/** A repository pull request. */
export type GQLPullRequestUserContentEditsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** A file changed in a pull request. */
export type GQLPullRequestChangedFile = {
  __typename?: 'PullRequestChangedFile';
  /** The number of additions to the file. */
  additions: Scalars['Int'];
  /** The number of deletions to the file. */
  deletions: Scalars['Int'];
  /** The path of the file. */
  path: Scalars['String'];
};

/** The connection type for PullRequestChangedFile. */
export type GQLPullRequestChangedFileConnection = {
  __typename?: 'PullRequestChangedFileConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLPullRequestChangedFileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLPullRequestChangedFile>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLPullRequestChangedFileEdge = {
  __typename?: 'PullRequestChangedFileEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLPullRequestChangedFile>;
};

/** Represents a Git commit part of a pull request. */
export type GQLPullRequestCommit = GQLNode & GQLUniformResourceLocatable & {
  __typename?: 'PullRequestCommit';
  /** The Git commit object */
  commit: GQLCommit;
  id: Scalars['ID'];
  /** The pull request this commit belongs to */
  pullRequest: GQLPullRequest;
  /** The HTTP path for this pull request commit */
  resourcePath: Scalars['URI'];
  /** The HTTP URL for this pull request commit */
  url: Scalars['URI'];
};

/** Represents a commit comment thread part of a pull request. */
export type GQLPullRequestCommitCommentThread = GQLNode & GQLRepositoryNode & {
  __typename?: 'PullRequestCommitCommentThread';
  /** The comments that exist in this thread. */
  comments: GQLCommitCommentConnection;
  /** The commit the comments were made on. */
  commit: GQLCommit;
  id: Scalars['ID'];
  /** The file the comments were made on. */
  path?: Maybe<Scalars['String']>;
  /** The position in the diff for the commit that the comment was made on. */
  position?: Maybe<Scalars['Int']>;
  /** The pull request this commit comment thread belongs to */
  pullRequest: GQLPullRequest;
  /** The repository associated with this node. */
  repository: GQLRepository;
};


/** Represents a commit comment thread part of a pull request. */
export type GQLPullRequestCommitCommentThreadCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** The connection type for PullRequestCommit. */
export type GQLPullRequestCommitConnection = {
  __typename?: 'PullRequestCommitConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLPullRequestCommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLPullRequestCommit>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLPullRequestCommitEdge = {
  __typename?: 'PullRequestCommitEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLPullRequestCommit>;
};

/** The connection type for PullRequest. */
export type GQLPullRequestConnection = {
  __typename?: 'PullRequestConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLPullRequestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLPullRequest>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** This aggregates pull requests opened by a user within one repository. */
export type GQLPullRequestContributionsByRepository = {
  __typename?: 'PullRequestContributionsByRepository';
  /** The pull request contributions. */
  contributions: GQLCreatedPullRequestContributionConnection;
  /** The repository in which the pull requests were opened. */
  repository: GQLRepository;
};


/** This aggregates pull requests opened by a user within one repository. */
export type GQLPullRequestContributionsByRepositoryContributionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLContributionOrder>;
};

/** An edge in a connection. */
export type GQLPullRequestEdge = {
  __typename?: 'PullRequestEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLPullRequest>;
};

/** Represents available types of methods to use when merging a pull request. */
export enum GQLPullRequestMergeMethod {
  /** Add all commits from the head branch to the base branch with a merge commit. */
  Merge = 'MERGE',
  /** Add all commits from the head branch onto the base branch individually. */
  Rebase = 'REBASE',
  /** Combine all commits from the head branch into a single commit in the base branch. */
  Squash = 'SQUASH'
}

/** Ways in which lists of issues can be ordered upon return. */
export type GQLPullRequestOrder = {
  /** The direction in which to order pull requests by the specified field. */
  direction: GQLOrderDirection;
  /** The field in which to order pull requests by. */
  field: GQLPullRequestOrderField;
};

/** Properties by which pull_requests connections can be ordered. */
export enum GQLPullRequestOrderField {
  /** Order pull_requests by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order pull_requests by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** A review object for a given pull request. */
export type GQLPullRequestReview = GQLComment & GQLDeletable & GQLNode & GQLReactable & GQLRepositoryNode & GQLUpdatable & GQLUpdatableComment & {
  __typename?: 'PullRequestReview';
  /** The actor who authored the comment. */
  author?: Maybe<GQLActor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: GQLCommentAuthorAssociation;
  /** Identifies the pull request review body. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML'];
  /** The body of this review rendered as plain text. */
  bodyText: Scalars['String'];
  /** A list of review comments for the current pull request review. */
  comments: GQLPullRequestReviewCommentConnection;
  /** Identifies the commit associated with this pull request review. */
  commit?: Maybe<GQLCommit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The actor who edited the comment. */
  editor?: Maybe<GQLActor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** A list of teams that this review was made on behalf of. */
  onBehalfOf: GQLTeamConnection;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies the pull request associated with this pull request review. */
  pullRequest: GQLPullRequest;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<GQLReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: GQLReactionConnection;
  /** The repository associated with this node. */
  repository: GQLRepository;
  /** The HTTP path permalink for this PullRequestReview. */
  resourcePath: Scalars['URI'];
  /** Identifies the current state of the pull request review. */
  state: GQLPullRequestReviewState;
  /** Identifies when the Pull Request Review was submitted */
  submittedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL permalink for this PullRequestReview. */
  url: Scalars['URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<GQLUserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<GQLCommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
};


/** A review object for a given pull request. */
export type GQLPullRequestReviewCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A review object for a given pull request. */
export type GQLPullRequestReviewOnBehalfOfArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A review object for a given pull request. */
export type GQLPullRequestReviewReactionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  content?: Maybe<GQLReactionContent>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLReactionOrder>;
};


/** A review object for a given pull request. */
export type GQLPullRequestReviewUserContentEditsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** A review comment associated with a given repository pull request. */
export type GQLPullRequestReviewComment = GQLComment & GQLDeletable & GQLMinimizable & GQLNode & GQLReactable & GQLRepositoryNode & GQLUpdatable & GQLUpdatableComment & {
  __typename?: 'PullRequestReviewComment';
  /** The actor who authored the comment. */
  author?: Maybe<GQLActor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: GQLCommentAuthorAssociation;
  /** The comment body of this review comment. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML'];
  /** The comment body of this review comment rendered as plain text. */
  bodyText: Scalars['String'];
  /** Identifies the commit associated with the comment. */
  commit?: Maybe<GQLCommit>;
  /** Identifies when the comment was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The diff hunk to which the comment applies. */
  diffHunk: Scalars['String'];
  /** Identifies when the comment was created in a draft state. */
  draftedAt: Scalars['DateTime'];
  /** The actor who edited the comment. */
  editor?: Maybe<GQLActor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** Returns why the comment was minimized. */
  minimizedReason?: Maybe<Scalars['String']>;
  /** Identifies the original commit associated with the comment. */
  originalCommit?: Maybe<GQLCommit>;
  /** The original line index in the diff to which the comment applies. */
  originalPosition: Scalars['Int'];
  /** Identifies when the comment body is outdated */
  outdated: Scalars['Boolean'];
  /** The path to which the comment applies. */
  path: Scalars['String'];
  /** The line index in the diff to which the comment applies. */
  position?: Maybe<Scalars['Int']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** The pull request associated with this review comment. */
  pullRequest: GQLPullRequest;
  /** The pull request review associated with this review comment. */
  pullRequestReview?: Maybe<GQLPullRequestReview>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<GQLReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: GQLReactionConnection;
  /** The comment this is a reply to. */
  replyTo?: Maybe<GQLPullRequestReviewComment>;
  /** The repository associated with this node. */
  repository: GQLRepository;
  /** The HTTP path permalink for this review comment. */
  resourcePath: Scalars['URI'];
  /** Identifies the state of the comment. */
  state: GQLPullRequestReviewCommentState;
  /** Identifies when the comment was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL permalink for this review comment. */
  url: Scalars['URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<GQLUserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<GQLCommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
};


/** A review comment associated with a given repository pull request. */
export type GQLPullRequestReviewCommentReactionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  content?: Maybe<GQLReactionContent>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLReactionOrder>;
};


/** A review comment associated with a given repository pull request. */
export type GQLPullRequestReviewCommentUserContentEditsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** The connection type for PullRequestReviewComment. */
export type GQLPullRequestReviewCommentConnection = {
  __typename?: 'PullRequestReviewCommentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLPullRequestReviewCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLPullRequestReviewComment>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLPullRequestReviewCommentEdge = {
  __typename?: 'PullRequestReviewCommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLPullRequestReviewComment>;
};

/** The possible states of a pull request review comment. */
export enum GQLPullRequestReviewCommentState {
  /** A comment that is part of a pending review */
  Pending = 'PENDING',
  /** A comment that is part of a submitted review */
  Submitted = 'SUBMITTED'
}

/** The connection type for PullRequestReview. */
export type GQLPullRequestReviewConnection = {
  __typename?: 'PullRequestReviewConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLPullRequestReviewEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLPullRequestReview>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** This aggregates pull request reviews made by a user within one repository. */
export type GQLPullRequestReviewContributionsByRepository = {
  __typename?: 'PullRequestReviewContributionsByRepository';
  /** The pull request review contributions. */
  contributions: GQLCreatedPullRequestReviewContributionConnection;
  /** The repository in which the pull request reviews were made. */
  repository: GQLRepository;
};


/** This aggregates pull request reviews made by a user within one repository. */
export type GQLPullRequestReviewContributionsByRepositoryContributionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLContributionOrder>;
};

/** The review status of a pull request. */
export enum GQLPullRequestReviewDecision {
  /** The pull request has received an approving review. */
  Approved = 'APPROVED',
  /** Changes have been requested on the pull request. */
  ChangesRequested = 'CHANGES_REQUESTED',
  /** A review is required before the pull request can be merged. */
  ReviewRequired = 'REVIEW_REQUIRED'
}

/** An edge in a connection. */
export type GQLPullRequestReviewEdge = {
  __typename?: 'PullRequestReviewEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLPullRequestReview>;
};

/** The possible events to perform on a pull request review. */
export enum GQLPullRequestReviewEvent {
  /** Submit feedback and approve merging these changes. */
  Approve = 'APPROVE',
  /** Submit general feedback without explicit approval. */
  Comment = 'COMMENT',
  /** Dismiss review so it now longer effects merging. */
  Dismiss = 'DISMISS',
  /** Submit feedback that must be addressed before merging. */
  RequestChanges = 'REQUEST_CHANGES'
}

/** The possible states of a pull request review. */
export enum GQLPullRequestReviewState {
  /** A review allowing the pull request to merge. */
  Approved = 'APPROVED',
  /** A review blocking the pull request from merging. */
  ChangesRequested = 'CHANGES_REQUESTED',
  /** An informational review. */
  Commented = 'COMMENTED',
  /** A review that has been dismissed. */
  Dismissed = 'DISMISSED',
  /** A review that has not yet been submitted. */
  Pending = 'PENDING'
}

/** A threaded list of comments for a given pull request. */
export type GQLPullRequestReviewThread = GQLNode & {
  __typename?: 'PullRequestReviewThread';
  /** A list of pull request comments associated with the thread. */
  comments: GQLPullRequestReviewCommentConnection;
  /** The side of the diff on which this thread was placed. */
  diffSide: GQLDiffSide;
  id: Scalars['ID'];
  /** Whether this thread has been resolved */
  isResolved: Scalars['Boolean'];
  /** The line in the file to which this thread refers */
  line?: Maybe<Scalars['Int']>;
  /** The original line in the file to which this thread refers. */
  originalLine?: Maybe<Scalars['Int']>;
  /** The original start line in the file to which this thread refers (multi-line only). */
  originalStartLine?: Maybe<Scalars['Int']>;
  /** Identifies the pull request associated with this thread. */
  pullRequest: GQLPullRequest;
  /** Identifies the repository associated with this thread. */
  repository: GQLRepository;
  /** The user who resolved this thread */
  resolvedBy?: Maybe<GQLUser>;
  /** The side of the diff that the first line of the thread starts on (multi-line only) */
  startDiffSide?: Maybe<GQLDiffSide>;
  /** The start line in the file to which this thread refers (multi-line only) */
  startLine?: Maybe<Scalars['Int']>;
  /** Whether or not the viewer can resolve this thread */
  viewerCanResolve: Scalars['Boolean'];
  /** Whether or not the viewer can unresolve this thread */
  viewerCanUnresolve: Scalars['Boolean'];
};


/** A threaded list of comments for a given pull request. */
export type GQLPullRequestReviewThreadCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
};

/** Review comment threads for a pull request review. */
export type GQLPullRequestReviewThreadConnection = {
  __typename?: 'PullRequestReviewThreadConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLPullRequestReviewThreadEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLPullRequestReviewThread>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLPullRequestReviewThreadEdge = {
  __typename?: 'PullRequestReviewThreadEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLPullRequestReviewThread>;
};

/** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */
export type GQLPullRequestRevisionMarker = {
  __typename?: 'PullRequestRevisionMarker';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The last commit the viewer has seen. */
  lastSeenCommit: GQLCommit;
  /** The pull request to which the marker belongs. */
  pullRequest: GQLPullRequest;
};

/** The possible states of a pull request. */
export enum GQLPullRequestState {
  /** A pull request that has been closed without being merged. */
  Closed = 'CLOSED',
  /** A pull request that has been closed by being merged. */
  Merged = 'MERGED',
  /** A pull request that is still open. */
  Open = 'OPEN'
}

/** The connection type for PullRequestTimelineItem. */
export type GQLPullRequestTimelineConnection = {
  __typename?: 'PullRequestTimelineConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLPullRequestTimelineItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLPullRequestTimelineItem>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An item in an pull request timeline */
export type GQLPullRequestTimelineItem = GQLAssignedEvent | GQLBaseRefForcePushedEvent | GQLClosedEvent | GQLCommit | GQLCommitCommentThread | GQLCrossReferencedEvent | GQLDemilestonedEvent | GQLDeployedEvent | GQLDeploymentEnvironmentChangedEvent | GQLHeadRefDeletedEvent | GQLHeadRefForcePushedEvent | GQLHeadRefRestoredEvent | GQLIssueComment | GQLLabeledEvent | GQLLockedEvent | GQLMergedEvent | GQLMilestonedEvent | GQLPullRequestReview | GQLPullRequestReviewComment | GQLPullRequestReviewThread | GQLReferencedEvent | GQLRenamedTitleEvent | GQLReopenedEvent | GQLReviewDismissedEvent | GQLReviewRequestRemovedEvent | GQLReviewRequestedEvent | GQLSubscribedEvent | GQLUnassignedEvent | GQLUnlabeledEvent | GQLUnlockedEvent | GQLUnsubscribedEvent | GQLUserBlockedEvent;

/** An edge in a connection. */
export type GQLPullRequestTimelineItemEdge = {
  __typename?: 'PullRequestTimelineItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLPullRequestTimelineItem>;
};

/** An item in a pull request timeline */
export type GQLPullRequestTimelineItems = GQLAddedToProjectEvent | GQLAssignedEvent | GQLAutomaticBaseChangeFailedEvent | GQLAutomaticBaseChangeSucceededEvent | GQLBaseRefChangedEvent | GQLBaseRefForcePushedEvent | GQLClosedEvent | GQLCommentDeletedEvent | GQLConnectedEvent | GQLConvertToDraftEvent | GQLConvertedNoteToIssueEvent | GQLCrossReferencedEvent | GQLDemilestonedEvent | GQLDeployedEvent | GQLDeploymentEnvironmentChangedEvent | GQLDisconnectedEvent | GQLHeadRefDeletedEvent | GQLHeadRefForcePushedEvent | GQLHeadRefRestoredEvent | GQLIssueComment | GQLLabeledEvent | GQLLockedEvent | GQLMarkedAsDuplicateEvent | GQLMentionedEvent | GQLMergedEvent | GQLMilestonedEvent | GQLMovedColumnsInProjectEvent | GQLPinnedEvent | GQLPullRequestCommit | GQLPullRequestCommitCommentThread | GQLPullRequestReview | GQLPullRequestReviewThread | GQLPullRequestRevisionMarker | GQLReadyForReviewEvent | GQLReferencedEvent | GQLRemovedFromProjectEvent | GQLRenamedTitleEvent | GQLReopenedEvent | GQLReviewDismissedEvent | GQLReviewRequestRemovedEvent | GQLReviewRequestedEvent | GQLSubscribedEvent | GQLTransferredEvent | GQLUnassignedEvent | GQLUnlabeledEvent | GQLUnlockedEvent | GQLUnmarkedAsDuplicateEvent | GQLUnpinnedEvent | GQLUnsubscribedEvent | GQLUserBlockedEvent;

/** The connection type for PullRequestTimelineItems. */
export type GQLPullRequestTimelineItemsConnection = {
  __typename?: 'PullRequestTimelineItemsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLPullRequestTimelineItemsEdge>>>;
  /** Identifies the count of items after applying `before` and `after` filters. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLPullRequestTimelineItems>>>;
  /** Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
  /** Identifies the date and time when the timeline was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** An edge in a connection. */
export type GQLPullRequestTimelineItemsEdge = {
  __typename?: 'PullRequestTimelineItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLPullRequestTimelineItems>;
};

/** The possible item types found in a timeline. */
export enum GQLPullRequestTimelineItemsItemType {
  /** Represents a 'added_to_project' event on a given issue or pull request. */
  AddedToProjectEvent = 'ADDED_TO_PROJECT_EVENT',
  /** Represents an 'assigned' event on any assignable object. */
  AssignedEvent = 'ASSIGNED_EVENT',
  /** Represents a 'automatic_base_change_failed' event on a given pull request. */
  AutomaticBaseChangeFailedEvent = 'AUTOMATIC_BASE_CHANGE_FAILED_EVENT',
  /** Represents a 'automatic_base_change_succeeded' event on a given pull request. */
  AutomaticBaseChangeSucceededEvent = 'AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT',
  /** Represents a 'base_ref_changed' event on a given issue or pull request. */
  BaseRefChangedEvent = 'BASE_REF_CHANGED_EVENT',
  /** Represents a 'base_ref_force_pushed' event on a given pull request. */
  BaseRefForcePushedEvent = 'BASE_REF_FORCE_PUSHED_EVENT',
  /** Represents a 'closed' event on any `Closable`. */
  ClosedEvent = 'CLOSED_EVENT',
  /** Represents a 'comment_deleted' event on a given issue or pull request. */
  CommentDeletedEvent = 'COMMENT_DELETED_EVENT',
  /** Represents a 'connected' event on a given issue or pull request. */
  ConnectedEvent = 'CONNECTED_EVENT',
  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
  ConvertedNoteToIssueEvent = 'CONVERTED_NOTE_TO_ISSUE_EVENT',
  /** Represents a 'convert_to_draft' event on a given pull request. */
  ConvertToDraftEvent = 'CONVERT_TO_DRAFT_EVENT',
  /** Represents a mention made by one issue or pull request to another. */
  CrossReferencedEvent = 'CROSS_REFERENCED_EVENT',
  /** Represents a 'demilestoned' event on a given issue or pull request. */
  DemilestonedEvent = 'DEMILESTONED_EVENT',
  /** Represents a 'deployed' event on a given pull request. */
  DeployedEvent = 'DEPLOYED_EVENT',
  /** Represents a 'deployment_environment_changed' event on a given pull request. */
  DeploymentEnvironmentChangedEvent = 'DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT',
  /** Represents a 'disconnected' event on a given issue or pull request. */
  DisconnectedEvent = 'DISCONNECTED_EVENT',
  /** Represents a 'head_ref_deleted' event on a given pull request. */
  HeadRefDeletedEvent = 'HEAD_REF_DELETED_EVENT',
  /** Represents a 'head_ref_force_pushed' event on a given pull request. */
  HeadRefForcePushedEvent = 'HEAD_REF_FORCE_PUSHED_EVENT',
  /** Represents a 'head_ref_restored' event on a given pull request. */
  HeadRefRestoredEvent = 'HEAD_REF_RESTORED_EVENT',
  /** Represents a comment on an Issue. */
  IssueComment = 'ISSUE_COMMENT',
  /** Represents a 'labeled' event on a given issue or pull request. */
  LabeledEvent = 'LABELED_EVENT',
  /** Represents a 'locked' event on a given issue or pull request. */
  LockedEvent = 'LOCKED_EVENT',
  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
  MarkedAsDuplicateEvent = 'MARKED_AS_DUPLICATE_EVENT',
  /** Represents a 'mentioned' event on a given issue or pull request. */
  MentionedEvent = 'MENTIONED_EVENT',
  /** Represents a 'merged' event on a given pull request. */
  MergedEvent = 'MERGED_EVENT',
  /** Represents a 'milestoned' event on a given issue or pull request. */
  MilestonedEvent = 'MILESTONED_EVENT',
  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
  MovedColumnsInProjectEvent = 'MOVED_COLUMNS_IN_PROJECT_EVENT',
  /** Represents a 'pinned' event on a given issue or pull request. */
  PinnedEvent = 'PINNED_EVENT',
  /** Represents a Git commit part of a pull request. */
  PullRequestCommit = 'PULL_REQUEST_COMMIT',
  /** Represents a commit comment thread part of a pull request. */
  PullRequestCommitCommentThread = 'PULL_REQUEST_COMMIT_COMMENT_THREAD',
  /** A review object for a given pull request. */
  PullRequestReview = 'PULL_REQUEST_REVIEW',
  /** A threaded list of comments for a given pull request. */
  PullRequestReviewThread = 'PULL_REQUEST_REVIEW_THREAD',
  /** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */
  PullRequestRevisionMarker = 'PULL_REQUEST_REVISION_MARKER',
  /** Represents a 'ready_for_review' event on a given pull request. */
  ReadyForReviewEvent = 'READY_FOR_REVIEW_EVENT',
  /** Represents a 'referenced' event on a given `ReferencedSubject`. */
  ReferencedEvent = 'REFERENCED_EVENT',
  /** Represents a 'removed_from_project' event on a given issue or pull request. */
  RemovedFromProjectEvent = 'REMOVED_FROM_PROJECT_EVENT',
  /** Represents a 'renamed' event on a given issue or pull request */
  RenamedTitleEvent = 'RENAMED_TITLE_EVENT',
  /** Represents a 'reopened' event on any `Closable`. */
  ReopenedEvent = 'REOPENED_EVENT',
  /** Represents a 'review_dismissed' event on a given issue or pull request. */
  ReviewDismissedEvent = 'REVIEW_DISMISSED_EVENT',
  /** Represents an 'review_requested' event on a given pull request. */
  ReviewRequestedEvent = 'REVIEW_REQUESTED_EVENT',
  /** Represents an 'review_request_removed' event on a given pull request. */
  ReviewRequestRemovedEvent = 'REVIEW_REQUEST_REMOVED_EVENT',
  /** Represents a 'subscribed' event on a given `Subscribable`. */
  SubscribedEvent = 'SUBSCRIBED_EVENT',
  /** Represents a 'transferred' event on a given issue or pull request. */
  TransferredEvent = 'TRANSFERRED_EVENT',
  /** Represents an 'unassigned' event on any assignable object. */
  UnassignedEvent = 'UNASSIGNED_EVENT',
  /** Represents an 'unlabeled' event on a given issue or pull request. */
  UnlabeledEvent = 'UNLABELED_EVENT',
  /** Represents an 'unlocked' event on a given issue or pull request. */
  UnlockedEvent = 'UNLOCKED_EVENT',
  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
  UnmarkedAsDuplicateEvent = 'UNMARKED_AS_DUPLICATE_EVENT',
  /** Represents an 'unpinned' event on a given issue or pull request. */
  UnpinnedEvent = 'UNPINNED_EVENT',
  /** Represents an 'unsubscribed' event on a given `Subscribable`. */
  UnsubscribedEvent = 'UNSUBSCRIBED_EVENT',
  /** Represents a 'user_blocked' event on a given user. */
  UserBlockedEvent = 'USER_BLOCKED_EVENT'
}

/** The possible target states when updating a pull request. */
export enum GQLPullRequestUpdateState {
  /** A pull request that has been closed without being merged. */
  Closed = 'CLOSED',
  /** A pull request that is still open. */
  Open = 'OPEN'
}

/** A Git push. */
export type GQLPush = GQLNode & {
  __typename?: 'Push';
  id: Scalars['ID'];
  /** The SHA after the push */
  nextSha?: Maybe<Scalars['GitObjectID']>;
  /** The permalink for this push. */
  permalink: Scalars['URI'];
  /** The SHA before the push */
  previousSha?: Maybe<Scalars['GitObjectID']>;
  /** The user who pushed */
  pusher: GQLUser;
  /** The repository that was pushed to */
  repository: GQLRepository;
};

/** A team, user or app who has the ability to push to a protected branch. */
export type GQLPushAllowance = GQLNode & {
  __typename?: 'PushAllowance';
  /** The actor that can push. */
  actor?: Maybe<GQLPushAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user or team. */
  branchProtectionRule?: Maybe<GQLBranchProtectionRule>;
  id: Scalars['ID'];
};

/** Types that can be an actor. */
export type GQLPushAllowanceActor = GQLApp | GQLTeam | GQLUser;

/** The connection type for PushAllowance. */
export type GQLPushAllowanceConnection = {
  __typename?: 'PushAllowanceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLPushAllowanceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLPushAllowance>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLPushAllowanceEdge = {
  __typename?: 'PushAllowanceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLPushAllowance>;
};

/** The query root of GitHub's GraphQL interface. */
export type GQLQuery = {
  __typename?: 'Query';
  /** Look up a code of conduct by its key */
  codeOfConduct?: Maybe<GQLCodeOfConduct>;
  /** Look up a code of conduct by its key */
  codesOfConduct?: Maybe<Array<Maybe<GQLCodeOfConduct>>>;
  /** Look up an enterprise by URL slug. */
  enterprise?: Maybe<GQLEnterprise>;
  /** Look up a pending enterprise administrator invitation by invitee, enterprise and role. */
  enterpriseAdministratorInvitation?: Maybe<GQLEnterpriseAdministratorInvitation>;
  /** Look up a pending enterprise administrator invitation by invitation token. */
  enterpriseAdministratorInvitationByToken?: Maybe<GQLEnterpriseAdministratorInvitation>;
  /** Look up an open source license by its key */
  license?: Maybe<GQLLicense>;
  /** Return a list of known open source licenses */
  licenses: Array<Maybe<GQLLicense>>;
  /** Get alphabetically sorted list of Marketplace categories */
  marketplaceCategories: Array<GQLMarketplaceCategory>;
  /** Look up a Marketplace category by its slug. */
  marketplaceCategory?: Maybe<GQLMarketplaceCategory>;
  /** Look up a single Marketplace listing */
  marketplaceListing?: Maybe<GQLMarketplaceListing>;
  /** Look up Marketplace listings */
  marketplaceListings: GQLMarketplaceListingConnection;
  /** Return information about the GitHub instance */
  meta: GQLGitHubMetadata;
  /** Fetches an object given its ID. */
  node?: Maybe<GQLNode>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<GQLNode>>;
  /** Lookup a organization by login. */
  organization?: Maybe<GQLOrganization>;
  /** The client's rate limit information. */
  rateLimit?: Maybe<GQLRateLimit>;
  /** Hack to workaround https://github.com/facebook/relay/issues/112 re-exposing the root query object */
  relay: GQLQuery;
  /** Lookup a given repository by the owner and repository name. */
  repository?: Maybe<GQLRepository>;
  /** Lookup a repository owner (ie. either a User or an Organization) by login. */
  repositoryOwner?: Maybe<GQLRepositoryOwner>;
  /** Lookup resource by a URL. */
  resource?: Maybe<GQLUniformResourceLocatable>;
  /** Perform a search across resources. */
  search: GQLSearchResultItemConnection;
  /** GitHub Security Advisories */
  securityAdvisories: GQLSecurityAdvisoryConnection;
  /** Fetch a Security Advisory by its GHSA ID */
  securityAdvisory?: Maybe<GQLSecurityAdvisory>;
  /** Software Vulnerabilities documented by GitHub Security Advisories */
  securityVulnerabilities: GQLSecurityVulnerabilityConnection;
  /**
   * Look up a single Sponsors Listing
   * @deprecated `Query.sponsorsListing` will be removed. Use `Sponsorable.sponsorsListing` instead. Removal on 2020-04-01 UTC.
   */
  sponsorsListing?: Maybe<GQLSponsorsListing>;
  /** Look up a topic by name. */
  topic?: Maybe<GQLTopic>;
  /** Lookup a user by login. */
  user?: Maybe<GQLUser>;
  /** The currently authenticated user. */
  viewer: GQLUser;
};


/** The query root of GitHub's GraphQL interface. */
export type GQLQueryCodeOfConductArgs = {
  key: Scalars['String'];
};


/** The query root of GitHub's GraphQL interface. */
export type GQLQueryEnterpriseArgs = {
  invitationToken?: Maybe<Scalars['String']>;
  slug: Scalars['String'];
};


/** The query root of GitHub's GraphQL interface. */
export type GQLQueryEnterpriseAdministratorInvitationArgs = {
  enterpriseSlug: Scalars['String'];
  role: GQLEnterpriseAdministratorRole;
  userLogin: Scalars['String'];
};


/** The query root of GitHub's GraphQL interface. */
export type GQLQueryEnterpriseAdministratorInvitationByTokenArgs = {
  invitationToken: Scalars['String'];
};


/** The query root of GitHub's GraphQL interface. */
export type GQLQueryLicenseArgs = {
  key: Scalars['String'];
};


/** The query root of GitHub's GraphQL interface. */
export type GQLQueryMarketplaceCategoriesArgs = {
  excludeEmpty?: Maybe<Scalars['Boolean']>;
  excludeSubcategories?: Maybe<Scalars['Boolean']>;
  includeCategories?: Maybe<Array<Scalars['String']>>;
};


/** The query root of GitHub's GraphQL interface. */
export type GQLQueryMarketplaceCategoryArgs = {
  slug: Scalars['String'];
  useTopicAliases?: Maybe<Scalars['Boolean']>;
};


/** The query root of GitHub's GraphQL interface. */
export type GQLQueryMarketplaceListingArgs = {
  slug: Scalars['String'];
};


/** The query root of GitHub's GraphQL interface. */
export type GQLQueryMarketplaceListingsArgs = {
  adminId?: Maybe<Scalars['ID']>;
  after?: Maybe<Scalars['String']>;
  allStates?: Maybe<Scalars['Boolean']>;
  before?: Maybe<Scalars['String']>;
  categorySlug?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['ID']>;
  primaryCategoryOnly?: Maybe<Scalars['Boolean']>;
  slugs?: Maybe<Array<Maybe<Scalars['String']>>>;
  useTopicAliases?: Maybe<Scalars['Boolean']>;
  viewerCanAdmin?: Maybe<Scalars['Boolean']>;
  withFreeTrialsOnly?: Maybe<Scalars['Boolean']>;
};


/** The query root of GitHub's GraphQL interface. */
export type GQLQueryNodeArgs = {
  id: Scalars['ID'];
};


/** The query root of GitHub's GraphQL interface. */
export type GQLQueryNodesArgs = {
  ids: Array<Scalars['ID']>;
};


/** The query root of GitHub's GraphQL interface. */
export type GQLQueryOrganizationArgs = {
  login: Scalars['String'];
};


/** The query root of GitHub's GraphQL interface. */
export type GQLQueryRateLimitArgs = {
  dryRun?: Maybe<Scalars['Boolean']>;
};


/** The query root of GitHub's GraphQL interface. */
export type GQLQueryRepositoryArgs = {
  name: Scalars['String'];
  owner: Scalars['String'];
};


/** The query root of GitHub's GraphQL interface. */
export type GQLQueryRepositoryOwnerArgs = {
  login: Scalars['String'];
};


/** The query root of GitHub's GraphQL interface. */
export type GQLQueryResourceArgs = {
  url: Scalars['URI'];
};


/** The query root of GitHub's GraphQL interface. */
export type GQLQuerySearchArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  query: Scalars['String'];
  type: GQLSearchType;
};


/** The query root of GitHub's GraphQL interface. */
export type GQLQuerySecurityAdvisoriesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  identifier?: Maybe<GQLSecurityAdvisoryIdentifierFilter>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLSecurityAdvisoryOrder>;
  publishedSince?: Maybe<Scalars['DateTime']>;
  updatedSince?: Maybe<Scalars['DateTime']>;
};


/** The query root of GitHub's GraphQL interface. */
export type GQLQuerySecurityAdvisoryArgs = {
  ghsaId: Scalars['String'];
};


/** The query root of GitHub's GraphQL interface. */
export type GQLQuerySecurityVulnerabilitiesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  ecosystem?: Maybe<GQLSecurityAdvisoryEcosystem>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLSecurityVulnerabilityOrder>;
  package?: Maybe<Scalars['String']>;
  severities?: Maybe<Array<GQLSecurityAdvisorySeverity>>;
};


/** The query root of GitHub's GraphQL interface. */
export type GQLQuerySponsorsListingArgs = {
  slug: Scalars['String'];
};


/** The query root of GitHub's GraphQL interface. */
export type GQLQueryTopicArgs = {
  name: Scalars['String'];
};


/** The query root of GitHub's GraphQL interface. */
export type GQLQueryUserArgs = {
  login: Scalars['String'];
};

/** Represents the client's rate limit. */
export type GQLRateLimit = {
  __typename?: 'RateLimit';
  /** The point cost for the current query counting against the rate limit. */
  cost: Scalars['Int'];
  /** The maximum number of points the client is permitted to consume in a 60 minute window. */
  limit: Scalars['Int'];
  /** The maximum number of nodes this query may return */
  nodeCount: Scalars['Int'];
  /** The number of points remaining in the current rate limit window. */
  remaining: Scalars['Int'];
  /** The time at which the current rate limit window resets in UTC epoch seconds. */
  resetAt: Scalars['DateTime'];
};

/** Represents a subject that can be reacted on. */
export type GQLReactable = {
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<GQLReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: GQLReactionConnection;
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
};


/** Represents a subject that can be reacted on. */
export type GQLReactableReactionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  content?: Maybe<GQLReactionContent>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLReactionOrder>;
};

/** The connection type for User. */
export type GQLReactingUserConnection = {
  __typename?: 'ReactingUserConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLReactingUserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLUser>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a user that's made a reaction. */
export type GQLReactingUserEdge = {
  __typename?: 'ReactingUserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  node: GQLUser;
  /** The moment when the user made the reaction. */
  reactedAt: Scalars['DateTime'];
};

/** An emoji reaction to a particular piece of content. */
export type GQLReaction = GQLNode & {
  __typename?: 'Reaction';
  /** Identifies the emoji reaction. */
  content: GQLReactionContent;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The reactable piece of content */
  reactable: GQLReactable;
  /** Identifies the user who created this reaction. */
  user?: Maybe<GQLUser>;
};

/** A list of reactions that have been left on the subject. */
export type GQLReactionConnection = {
  __typename?: 'ReactionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLReactionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLReaction>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
  /** Whether or not the authenticated user has left a reaction on the subject. */
  viewerHasReacted: Scalars['Boolean'];
};

/** Emojis that can be attached to Issues, Pull Requests and Comments. */
export enum GQLReactionContent {
  /** Represents the `:confused:` emoji. */
  Confused = 'CONFUSED',
  /** Represents the `:eyes:` emoji. */
  Eyes = 'EYES',
  /** Represents the `:heart:` emoji. */
  Heart = 'HEART',
  /** Represents the `:hooray:` emoji. */
  Hooray = 'HOORAY',
  /** Represents the `:laugh:` emoji. */
  Laugh = 'LAUGH',
  /** Represents the `:rocket:` emoji. */
  Rocket = 'ROCKET',
  /** Represents the `:-1:` emoji. */
  ThumbsDown = 'THUMBS_DOWN',
  /** Represents the `:+1:` emoji. */
  ThumbsUp = 'THUMBS_UP'
}

/** An edge in a connection. */
export type GQLReactionEdge = {
  __typename?: 'ReactionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLReaction>;
};

/** A group of emoji reactions to a particular piece of content. */
export type GQLReactionGroup = {
  __typename?: 'ReactionGroup';
  /** Identifies the emoji reaction. */
  content: GQLReactionContent;
  /** Identifies when the reaction was created. */
  createdAt?: Maybe<Scalars['DateTime']>;
  /** The subject that was reacted to. */
  subject: GQLReactable;
  /** Users who have reacted to the reaction subject with the emotion represented by this reaction group */
  users: GQLReactingUserConnection;
  /** Whether or not the authenticated user has left a reaction on the subject. */
  viewerHasReacted: Scalars['Boolean'];
};


/** A group of emoji reactions to a particular piece of content. */
export type GQLReactionGroupUsersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** Ways in which lists of reactions can be ordered upon return. */
export type GQLReactionOrder = {
  /** The direction in which to order reactions by the specified field. */
  direction: GQLOrderDirection;
  /** The field in which to order reactions by. */
  field: GQLReactionOrderField;
};

/** A list of fields that reactions can be ordered by. */
export enum GQLReactionOrderField {
  /** Allows ordering a list of reactions by when they were created. */
  CreatedAt = 'CREATED_AT'
}

/** Represents a 'ready_for_review' event on a given pull request. */
export type GQLReadyForReviewEvent = GQLNode & GQLUniformResourceLocatable & {
  __typename?: 'ReadyForReviewEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: GQLPullRequest;
  /** The HTTP path for this ready for review event. */
  resourcePath: Scalars['URI'];
  /** The HTTP URL for this ready for review event. */
  url: Scalars['URI'];
};

/** Represents a Git reference. */
export type GQLRef = GQLNode & {
  __typename?: 'Ref';
  /** A list of pull requests with this ref as the head ref. */
  associatedPullRequests: GQLPullRequestConnection;
  id: Scalars['ID'];
  /** The ref name. */
  name: Scalars['String'];
  /** The ref's prefix, such as `refs/heads/` or `refs/tags/`. */
  prefix: Scalars['String'];
  /** The repository the ref belongs to. */
  repository: GQLRepository;
  /**
   * The object the ref points to.
   * 
   * **Upcoming Change on 2019-07-01 UTC**
   * **Description:** Type for `target` will change from `GitObject!` to `GitObject`.
   * **Reason:** The `target` field may return `null` values and is changing to nullable
   */
  target: GQLGitObject;
};


/** Represents a Git reference. */
export type GQLRefAssociatedPullRequestsArgs = {
  after?: Maybe<Scalars['String']>;
  baseRefName?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  headRefName?: Maybe<Scalars['String']>;
  labels?: Maybe<Array<Scalars['String']>>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLIssueOrder>;
  states?: Maybe<Array<GQLPullRequestState>>;
};

/** The connection type for Ref. */
export type GQLRefConnection = {
  __typename?: 'RefConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLRefEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLRef>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLRefEdge = {
  __typename?: 'RefEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLRef>;
};

/** Ways in which lists of git refs can be ordered upon return. */
export type GQLRefOrder = {
  /** The direction in which to order refs by the specified field. */
  direction: GQLOrderDirection;
  /** The field in which to order refs by. */
  field: GQLRefOrderField;
};

/** Properties by which ref connections can be ordered. */
export enum GQLRefOrderField {
  /** Order refs by their alphanumeric name */
  Alphabetical = 'ALPHABETICAL',
  /** Order refs by underlying commit date if the ref prefix is refs/tags/ */
  TagCommitDate = 'TAG_COMMIT_DATE'
}

/** A ref update */
export type GQLRefUpdate = {
  /** The value this ref should be updated to. */
  afterOid: Scalars['GitObjectID'];
  /** The value this ref needs to point to before the update. */
  beforeOid?: Maybe<Scalars['GitObjectID']>;
  /** Force a non fast-forward update. */
  force?: Maybe<Scalars['Boolean']>;
  /** The fully qualified name of the ref to be update. For example `refs/heads/branch-name` */
  name: Scalars['GitRefname'];
};

/** Represents a 'referenced' event on a given `ReferencedSubject`. */
export type GQLReferencedEvent = GQLNode & {
  __typename?: 'ReferencedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the commit associated with the 'referenced' event. */
  commit?: Maybe<GQLCommit>;
  /** Identifies the repository associated with the 'referenced' event. */
  commitRepository: GQLRepository;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars['Boolean'];
  /** Checks if the commit message itself references the subject. Can be false in the case of a commit comment reference. */
  isDirectReference: Scalars['Boolean'];
  /** Object referenced by event. */
  subject: GQLReferencedSubject;
};

/** Any referencable object */
export type GQLReferencedSubject = GQLIssue | GQLPullRequest;

/** Autogenerated input type of RegenerateEnterpriseIdentityProviderRecoveryCodes */
export type GQLRegenerateEnterpriseIdentityProviderRecoveryCodesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set an identity provider. */
  enterpriseId: Scalars['ID'];
};

/** Autogenerated return type of RegenerateEnterpriseIdentityProviderRecoveryCodes */
export type GQLRegenerateEnterpriseIdentityProviderRecoveryCodesPayload = {
  __typename?: 'RegenerateEnterpriseIdentityProviderRecoveryCodesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The identity provider for the enterprise. */
  identityProvider?: Maybe<GQLEnterpriseIdentityProvider>;
};

/** A registry package contains the content for an uploaded package. */
export type GQLRegistryPackage = GQLNode & {
  __typename?: 'RegistryPackage';
  /**
   * The package type color
   * @deprecated Renaming GitHub Packages fields and objects. Use the `Package` object instead. Removal on 2020-04-01 UTC.
   */
  color: Scalars['String'];
  id: Scalars['ID'];
  /**
   * Find the latest version for the package.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `Package` object instead. Removal on 2020-04-01 UTC.
   */
  latestVersion?: Maybe<GQLRegistryPackageVersion>;
  /**
   * Identifies the title of the package.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `Package` object instead. Removal on 2020-04-01 UTC.
   */
  name: Scalars['String'];
  /**
   * Identifies the title of the package, with the owner prefixed.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `Package` object instead. Removal on 2020-04-01 UTC.
   */
  nameWithOwner: Scalars['String'];
  /**
   * Find the package file identified by the guid.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `Package` object. Removal on 2020-04-01 UTC.
   */
  packageFileByGuid?: Maybe<GQLRegistryPackageFile>;
  /**
   * Find the package file identified by the sha256.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `Package` object. Removal on 2020-04-01 UTC.
   */
  packageFileBySha256?: Maybe<GQLRegistryPackageFile>;
  /**
   * Identifies the type of the package.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `Package` object instead. Removal on 2020-04-01 UTC.
   */
  packageType: GQLRegistryPackageType;
  /**
   * List the prerelease versions for this package.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `Package` object instead. Removal on 2020-04-01 UTC.
   */
  preReleaseVersions?: Maybe<GQLRegistryPackageVersionConnection>;
  /**
   * The type of the package.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `Package` object instead. Removal on 2020-04-01 UTC.
   */
  registryPackageType?: Maybe<Scalars['String']>;
  /**
   * repository that the release is associated with
   * @deprecated Renaming GitHub Packages fields and objects. Use the `Package` object instead. Removal on 2020-04-01 UTC.
   */
  repository?: Maybe<GQLRepository>;
  /**
   * Statistics about package activity.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `Package` object instead. Removal on 2020-04-01 UTC.
   */
  statistics?: Maybe<GQLRegistryPackageStatistics>;
  /**
   * list of tags for this package
   * @deprecated Renaming GitHub Packages fields and objects. Use the `Package` object. Removal on 2020-04-01 UTC.
   */
  tags: GQLRegistryPackageTagConnection;
  /**
   * List the topics for this package.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `Package` object. Removal on 2020-04-01 UTC.
   */
  topics?: Maybe<GQLTopicConnection>;
  /**
   * Find package version by version string.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `Package` object instead. Removal on 2020-04-01 UTC.
   */
  version?: Maybe<GQLRegistryPackageVersion>;
  /**
   * Find package version by version string.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `Package` object instead. Removal on 2020-04-01 UTC.
   */
  versionByPlatform?: Maybe<GQLRegistryPackageVersion>;
  /**
   * Find package version by manifest SHA256.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `Package` object instead. Removal on 2020-04-01 UTC.
   */
  versionBySha256?: Maybe<GQLRegistryPackageVersion>;
  /**
   * list of versions for this package
   * @deprecated Renaming GitHub Packages fields and objects. Use the `Package` object instead. Removal on 2020-04-01 UTC.
   */
  versions: GQLRegistryPackageVersionConnection;
  /**
   * List package versions with a specific metadatum.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `Package` object instead. Removal on 2020-04-01 UTC.
   */
  versionsByMetadatum?: Maybe<GQLRegistryPackageVersionConnection>;
};


/** A registry package contains the content for an uploaded package. */
export type GQLRegistryPackagePackageFileByGuidArgs = {
  guid: Scalars['String'];
};


/** A registry package contains the content for an uploaded package. */
export type GQLRegistryPackagePackageFileBySha256Args = {
  sha256: Scalars['String'];
};


/** A registry package contains the content for an uploaded package. */
export type GQLRegistryPackagePreReleaseVersionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A registry package contains the content for an uploaded package. */
export type GQLRegistryPackageTagsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A registry package contains the content for an uploaded package. */
export type GQLRegistryPackageTopicsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A registry package contains the content for an uploaded package. */
export type GQLRegistryPackageVersionArgs = {
  version: Scalars['String'];
};


/** A registry package contains the content for an uploaded package. */
export type GQLRegistryPackageVersionByPlatformArgs = {
  platform: Scalars['String'];
  version: Scalars['String'];
};


/** A registry package contains the content for an uploaded package. */
export type GQLRegistryPackageVersionBySha256Args = {
  sha256: Scalars['String'];
};


/** A registry package contains the content for an uploaded package. */
export type GQLRegistryPackageVersionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A registry package contains the content for an uploaded package. */
export type GQLRegistryPackageVersionsByMetadatumArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  metadatum: GQLRegistryPackageMetadatum;
};

/** The connection type for RegistryPackage. */
export type GQLRegistryPackageConnection = {
  __typename?: 'RegistryPackageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLRegistryPackageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLRegistryPackage>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** A package dependency contains the information needed to satisfy a dependency. */
export type GQLRegistryPackageDependency = GQLNode & {
  __typename?: 'RegistryPackageDependency';
  /**
   * Identifies the type of dependency.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageDependency` object instead. Removal on 2020-04-01 UTC.
   */
  dependencyType: GQLRegistryPackageDependencyType;
  id: Scalars['ID'];
  /**
   * Identifies the name of the dependency.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageDependency` object instead. Removal on 2020-04-01 UTC.
   */
  name: Scalars['String'];
  /**
   * Identifies the version of the dependency.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageDependency` object instead. Removal on 2020-04-01 UTC.
   */
  version: Scalars['String'];
};

/** The connection type for RegistryPackageDependency. */
export type GQLRegistryPackageDependencyConnection = {
  __typename?: 'RegistryPackageDependencyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLRegistryPackageDependencyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLRegistryPackageDependency>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLRegistryPackageDependencyEdge = {
  __typename?: 'RegistryPackageDependencyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLRegistryPackageDependency>;
};

/** The possible types of a registry package dependency. */
export enum GQLRegistryPackageDependencyType {
  /** An optional registry package dependency type. */
  Bundled = 'BUNDLED',
  /** A default registry package dependency type. */
  Default = 'DEFAULT',
  /** A dev registry package dependency type. */
  Dev = 'DEV',
  /** An optional registry package dependency type. */
  Optional = 'OPTIONAL',
  /** A peer registry package dependency type. */
  Peer = 'PEER',
  /** A test registry package dependency type. */
  Test = 'TEST'
}

/** An edge in a connection. */
export type GQLRegistryPackageEdge = {
  __typename?: 'RegistryPackageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLRegistryPackage>;
};

/** A file in a specific registry package version. */
export type GQLRegistryPackageFile = GQLNode & {
  __typename?: 'RegistryPackageFile';
  /**
   * A unique identifier for this file.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageFile` object instead. Removal on 2020-04-01 UTC.
   */
  guid?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /**
   * Identifies the md5.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageFile` object instead. Removal on 2020-04-01 UTC.
   */
  md5?: Maybe<Scalars['String']>;
  /**
   * URL to download the asset metadata.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageFile` object instead. Removal on 2020-04-01 UTC.
   */
  metadataUrl: Scalars['URI'];
  /**
   * Name of the file
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageFile` object instead. Removal on 2020-04-01 UTC.
   */
  name: Scalars['String'];
  /**
   * The package version this file belongs to.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageFile` object instead. Removal on 2020-04-01 UTC.
   */
  packageVersion: GQLRegistryPackageVersion;
  /**
   * Identifies the sha1.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageFile` object instead. Removal on 2020-04-01 UTC.
   */
  sha1?: Maybe<Scalars['String']>;
  /**
   * Identifies the sha256.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageFile` object instead. Removal on 2020-04-01 UTC.
   */
  sha256?: Maybe<Scalars['String']>;
  /**
   * Identifies the size.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageFile` object instead. Removal on 2020-04-01 UTC.
   */
  size?: Maybe<Scalars['Int']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /**
   * URL to download the asset.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageFile` object instead. Removal on 2020-04-01 UTC.
   */
  url: Scalars['URI'];
};

/** The connection type for RegistryPackageFile. */
export type GQLRegistryPackageFileConnection = {
  __typename?: 'RegistryPackageFileConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLRegistryPackageFileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLRegistryPackageFile>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLRegistryPackageFileEdge = {
  __typename?: 'RegistryPackageFileEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLRegistryPackageFile>;
};

/** Represents a single registry metadatum */
export type GQLRegistryPackageMetadatum = {
  /** Name of the metadatum. */
  name: Scalars['String'];
  /** True, if the metadatum can be updated if it already exists */
  update?: Maybe<Scalars['Boolean']>;
  /** Value of the metadatum. */
  value: Scalars['String'];
};

/** Represents an owner of a registry package. */
export type GQLRegistryPackageOwner = {
  id: Scalars['ID'];
  /**
   * A list of registry packages under the owner.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageOwner` object instead. Removal on 2020-04-01 UTC.
   */
  registryPackages: GQLRegistryPackageConnection;
};


/** Represents an owner of a registry package. */
export type GQLRegistryPackageOwnerRegistryPackagesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  names?: Maybe<Array<Maybe<Scalars['String']>>>;
  packageType?: Maybe<GQLRegistryPackageType>;
  publicOnly?: Maybe<Scalars['Boolean']>;
  registryPackageType?: Maybe<Scalars['String']>;
  repositoryId?: Maybe<Scalars['ID']>;
};

/** Represents an interface to search packages on an object. */
export type GQLRegistryPackageSearch = {
  id: Scalars['ID'];
  /**
   * A list of registry packages for a particular search query.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageSearch` object instead. Removal on 2020-04-01 UTC.
   */
  registryPackagesForQuery: GQLRegistryPackageConnection;
};


/** Represents an interface to search packages on an object. */
export type GQLRegistryPackageSearchRegistryPackagesForQueryArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  packageType?: Maybe<GQLRegistryPackageType>;
  query?: Maybe<Scalars['String']>;
};

/** Represents a object that contains package activity statistics such as downloads. */
export type GQLRegistryPackageStatistics = {
  __typename?: 'RegistryPackageStatistics';
  /**
   * Number of times the package was downloaded this month.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageStatistics` object instead. Removal on 2020-04-01 UTC.
   */
  downloadsThisMonth: Scalars['Int'];
  /**
   * Number of times the package was downloaded this week.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageStatistics` object instead. Removal on 2020-04-01 UTC.
   */
  downloadsThisWeek: Scalars['Int'];
  /**
   * Number of times the package was downloaded this year.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageStatistics` object instead. Removal on 2020-04-01 UTC.
   */
  downloadsThisYear: Scalars['Int'];
  /**
   * Number of times the package was downloaded today.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageStatistics` object instead. Removal on 2020-04-01 UTC.
   */
  downloadsToday: Scalars['Int'];
  /**
   * Number of times the package was downloaded since it was created.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageStatistics` object instead. Removal on 2020-04-01 UTC.
   */
  downloadsTotalCount: Scalars['Int'];
};

/** A version tag contains the mapping between a tag name and a version. */
export type GQLRegistryPackageTag = GQLNode & {
  __typename?: 'RegistryPackageTag';
  id: Scalars['ID'];
  /**
   * Identifies the tag name of the version.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageTag` object instead. Removal on 2020-04-01 UTC.
   */
  name: Scalars['String'];
  /**
   * version that the tag is associated with
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageTag` object instead. Removal on 2020-04-01 UTC.
   */
  version?: Maybe<GQLRegistryPackageVersion>;
};

/** The connection type for RegistryPackageTag. */
export type GQLRegistryPackageTagConnection = {
  __typename?: 'RegistryPackageTagConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLRegistryPackageTagEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLRegistryPackageTag>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLRegistryPackageTagEdge = {
  __typename?: 'RegistryPackageTagEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLRegistryPackageTag>;
};

/** The possible types of a registry package. */
export enum GQLRegistryPackageType {
  /** A debian package. */
  Debian = 'DEBIAN',
  /** A docker image. */
  Docker = 'DOCKER',
  /** A maven registry package. */
  Maven = 'MAVEN',
  /** An npm registry package. */
  Npm = 'NPM',
  /** A nuget package. */
  Nuget = 'NUGET',
  /** A python package. */
  Python = 'PYTHON',
  /** A rubygems registry package. */
  Rubygems = 'RUBYGEMS'
}

/** A package version contains the information about a specific package version. */
export type GQLRegistryPackageVersion = GQLNode & {
  __typename?: 'RegistryPackageVersion';
  /**
   * Whether or not this version has been deleted.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageVersion` object instead. Removal on 2020-04-01 UTC.
   */
  deleted: Scalars['Boolean'];
  /**
   * list of dependencies for this package
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageVersion` object instead. Removal on 2020-04-01 UTC.
   */
  dependencies: GQLRegistryPackageDependencyConnection;
  /**
   * A file associated with this registry package version
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageVersion` object instead. Removal on 2020-04-01 UTC.
   */
  fileByName?: Maybe<GQLRegistryPackageFile>;
  /**
   * List of files associated with this registry package version
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageVersion` object instead. Removal on 2020-04-01 UTC.
   */
  files: GQLRegistryPackageFileConnection;
  id: Scalars['ID'];
  /**
   * A single line of text to install this package version.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageVersion` object instead. Removal on 2020-04-01 UTC.
   */
  installationCommand?: Maybe<Scalars['String']>;
  /**
   * Identifies the package manifest for this package version.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageVersion` object instead. Removal on 2020-04-01 UTC.
   */
  manifest?: Maybe<Scalars['String']>;
  /**
   * Identifies the platform this version was built for.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageVersion` object instead. Removal on 2020-04-01 UTC.
   */
  platform?: Maybe<Scalars['String']>;
  /**
   * Indicates whether this version is a pre-release.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageVersion` object instead. Removal on 2020-04-01 UTC.
   */
  preRelease: Scalars['Boolean'];
  /**
   * The README of this package version
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageVersion` object instead. Removal on 2020-04-01 UTC.
   */
  readme?: Maybe<Scalars['String']>;
  /**
   * The HTML README of this package version
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageVersion` object instead. Removal on 2020-04-01 UTC.
   */
  readmeHtml?: Maybe<Scalars['HTML']>;
  /**
   * Registry package associated with this version.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageVersion` object instead. Removal on 2020-04-01 UTC.
   */
  registryPackage?: Maybe<GQLRegistryPackage>;
  /**
   * Release associated with this package.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageVersion` object instead. Removal on 2020-04-01 UTC.
   */
  release?: Maybe<GQLRelease>;
  /**
   * Identifies the sha256.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageVersion` object instead. Removal on 2020-04-01 UTC.
   */
  sha256?: Maybe<Scalars['String']>;
  /**
   * Identifies the size.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageVersion` object instead. Removal on 2020-04-01 UTC.
   */
  size?: Maybe<Scalars['Int']>;
  /**
   * Statistics about package activity.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageVersion` object instead. Removal on 2020-04-01 UTC.
   */
  statistics?: Maybe<GQLRegistryPackageVersionStatistics>;
  /**
   * Identifies the package version summary.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageVersion` object instead. Removal on 2020-04-01 UTC.
   */
  summary?: Maybe<Scalars['String']>;
  /**
   * Time at which the most recent file upload for this package version finished
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageVersion` object instead. Removal on 2020-04-01 UTC.
   */
  updatedAt: Scalars['DateTime'];
  /**
   * Identifies the version number.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageVersion` object instead. Removal on 2020-04-01 UTC.
   */
  version: Scalars['String'];
  /**
   * Can the current viewer edit this Package version.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageVersion` object instead. Removal on 2020-04-01 UTC.
   */
  viewerCanEdit: Scalars['Boolean'];
};


/** A package version contains the information about a specific package version. */
export type GQLRegistryPackageVersionDependenciesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  type?: Maybe<GQLRegistryPackageDependencyType>;
};


/** A package version contains the information about a specific package version. */
export type GQLRegistryPackageVersionFileByNameArgs = {
  filename: Scalars['String'];
};


/** A package version contains the information about a specific package version. */
export type GQLRegistryPackageVersionFilesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** The connection type for RegistryPackageVersion. */
export type GQLRegistryPackageVersionConnection = {
  __typename?: 'RegistryPackageVersionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLRegistryPackageVersionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLRegistryPackageVersion>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLRegistryPackageVersionEdge = {
  __typename?: 'RegistryPackageVersionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLRegistryPackageVersion>;
};

/** Represents a object that contains package version activity statistics such as downloads. */
export type GQLRegistryPackageVersionStatistics = {
  __typename?: 'RegistryPackageVersionStatistics';
  /**
   * Number of times the package was downloaded this month.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageVersionStatistics` object instead. Removal on 2020-04-01 UTC.
   */
  downloadsThisMonth: Scalars['Int'];
  /**
   * Number of times the package was downloaded this week.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageVersionStatistics` object instead. Removal on 2020-04-01 UTC.
   */
  downloadsThisWeek: Scalars['Int'];
  /**
   * Number of times the package was downloaded this year.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageVersionStatistics` object instead. Removal on 2020-04-01 UTC.
   */
  downloadsThisYear: Scalars['Int'];
  /**
   * Number of times the package was downloaded today.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageVersionStatistics` object instead. Removal on 2020-04-01 UTC.
   */
  downloadsToday: Scalars['Int'];
  /**
   * Number of times the package was downloaded since it was created.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageVersionStatistics` object instead. Removal on 2020-04-01 UTC.
   */
  downloadsTotalCount: Scalars['Int'];
};

/** A release contains the content for a release. */
export type GQLRelease = GQLNode & GQLUniformResourceLocatable & {
  __typename?: 'Release';
  /** The author of the release */
  author?: Maybe<GQLUser>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The description of the release. */
  description?: Maybe<Scalars['String']>;
  /** The description of this release rendered to HTML. */
  descriptionHTML?: Maybe<Scalars['HTML']>;
  id: Scalars['ID'];
  /** Whether or not the release is a draft */
  isDraft: Scalars['Boolean'];
  /** Whether or not the release is a prerelease */
  isPrerelease: Scalars['Boolean'];
  /** The title of the release. */
  name?: Maybe<Scalars['String']>;
  /** Identifies the date and time when the release was created. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** List of releases assets which are dependent on this release. */
  releaseAssets: GQLReleaseAssetConnection;
  /** The HTTP path for this issue */
  resourcePath: Scalars['URI'];
  /** A description of the release, rendered to HTML without any links in it. */
  shortDescriptionHTML?: Maybe<Scalars['HTML']>;
  /** The Git tag the release points to */
  tag?: Maybe<GQLRef>;
  /** The name of the release's Git tag */
  tagName: Scalars['String'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this issue */
  url: Scalars['URI'];
};


/** A release contains the content for a release. */
export type GQLReleaseReleaseAssetsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
};


/** A release contains the content for a release. */
export type GQLReleaseShortDescriptionHtmlArgs = {
  limit?: Maybe<Scalars['Int']>;
};

/** A release asset contains the content for a release asset. */
export type GQLReleaseAsset = GQLNode & {
  __typename?: 'ReleaseAsset';
  /** The asset's content-type */
  contentType: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The number of times this asset was downloaded */
  downloadCount: Scalars['Int'];
  /** Identifies the URL where you can download the release asset via the browser. */
  downloadUrl: Scalars['URI'];
  id: Scalars['ID'];
  /** Identifies the title of the release asset. */
  name: Scalars['String'];
  /** Release that the asset is associated with */
  release?: Maybe<GQLRelease>;
  /** The size (in bytes) of the asset */
  size: Scalars['Int'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The user that performed the upload */
  uploadedBy: GQLUser;
  /** Identifies the URL of the release asset. */
  url: Scalars['URI'];
};

/** The connection type for ReleaseAsset. */
export type GQLReleaseAssetConnection = {
  __typename?: 'ReleaseAssetConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLReleaseAssetEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLReleaseAsset>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLReleaseAssetEdge = {
  __typename?: 'ReleaseAssetEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLReleaseAsset>;
};

/** The connection type for Release. */
export type GQLReleaseConnection = {
  __typename?: 'ReleaseConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLReleaseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLRelease>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLReleaseEdge = {
  __typename?: 'ReleaseEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLRelease>;
};

/** Ways in which lists of releases can be ordered upon return. */
export type GQLReleaseOrder = {
  /** The direction in which to order releases by the specified field. */
  direction: GQLOrderDirection;
  /** The field in which to order releases by. */
  field: GQLReleaseOrderField;
};

/** Properties by which release connections can be ordered. */
export enum GQLReleaseOrderField {
  /** Order releases by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order releases alphabetically by name */
  Name = 'NAME'
}

/** Autogenerated input type of RemoveAssigneesFromAssignable */
export type GQLRemoveAssigneesFromAssignableInput = {
  /** The id of the assignable object to remove assignees from. */
  assignableId: Scalars['ID'];
  /** The id of users to remove as assignees. */
  assigneeIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of RemoveAssigneesFromAssignable */
export type GQLRemoveAssigneesFromAssignablePayload = {
  __typename?: 'RemoveAssigneesFromAssignablePayload';
  /** The item that was unassigned. */
  assignable?: Maybe<GQLAssignable>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of RemoveEnterpriseAdmin */
export type GQLRemoveEnterpriseAdminInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Enterprise ID from which to remove the administrator. */
  enterpriseId: Scalars['ID'];
  /** The login of the user to remove as an administrator. */
  login: Scalars['String'];
};

/** Autogenerated return type of RemoveEnterpriseAdmin */
export type GQLRemoveEnterpriseAdminPayload = {
  __typename?: 'RemoveEnterpriseAdminPayload';
  /** The user who was removed as an administrator. */
  admin?: Maybe<GQLUser>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated enterprise. */
  enterprise?: Maybe<GQLEnterprise>;
  /** A message confirming the result of removing an administrator. */
  message?: Maybe<Scalars['String']>;
  /** The viewer performing the mutation. */
  viewer?: Maybe<GQLUser>;
};

/** Autogenerated input type of RemoveEnterpriseIdentityProvider */
export type GQLRemoveEnterpriseIdentityProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise from which to remove the identity provider. */
  enterpriseId: Scalars['ID'];
};

/** Autogenerated return type of RemoveEnterpriseIdentityProvider */
export type GQLRemoveEnterpriseIdentityProviderPayload = {
  __typename?: 'RemoveEnterpriseIdentityProviderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The identity provider that was removed from the enterprise. */
  identityProvider?: Maybe<GQLEnterpriseIdentityProvider>;
};

/** Autogenerated input type of RemoveEnterpriseOrganization */
export type GQLRemoveEnterpriseOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise from which the organization should be removed. */
  enterpriseId: Scalars['ID'];
  /** The ID of the organization to remove from the enterprise. */
  organizationId: Scalars['ID'];
};

/** Autogenerated return type of RemoveEnterpriseOrganization */
export type GQLRemoveEnterpriseOrganizationPayload = {
  __typename?: 'RemoveEnterpriseOrganizationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated enterprise. */
  enterprise?: Maybe<GQLEnterprise>;
  /** The organization that was removed from the enterprise. */
  organization?: Maybe<GQLOrganization>;
  /** The viewer performing the mutation. */
  viewer?: Maybe<GQLUser>;
};

/** Autogenerated input type of RemoveLabelsFromLabelable */
export type GQLRemoveLabelsFromLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ids of labels to remove. */
  labelIds: Array<Scalars['ID']>;
  /** The id of the Labelable to remove labels from. */
  labelableId: Scalars['ID'];
};

/** Autogenerated return type of RemoveLabelsFromLabelable */
export type GQLRemoveLabelsFromLabelablePayload = {
  __typename?: 'RemoveLabelsFromLabelablePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Labelable the labels were removed from. */
  labelable?: Maybe<GQLLabelable>;
};

/** Autogenerated input type of RemoveOutsideCollaborator */
export type GQLRemoveOutsideCollaboratorInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the organization to remove the outside collaborator from. */
  organizationId: Scalars['ID'];
  /** The ID of the outside collaborator to remove. */
  userId: Scalars['ID'];
};

/** Autogenerated return type of RemoveOutsideCollaborator */
export type GQLRemoveOutsideCollaboratorPayload = {
  __typename?: 'RemoveOutsideCollaboratorPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The user that was removed as an outside collaborator. */
  removedUser?: Maybe<GQLUser>;
};

/** Autogenerated input type of RemoveReaction */
export type GQLRemoveReactionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The name of the emoji reaction to remove. */
  content: GQLReactionContent;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'];
};

/** Autogenerated return type of RemoveReaction */
export type GQLRemoveReactionPayload = {
  __typename?: 'RemoveReactionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The reaction object. */
  reaction?: Maybe<GQLReaction>;
  /** The reactable subject. */
  subject?: Maybe<GQLReactable>;
};

/** Autogenerated input type of RemoveStar */
export type GQLRemoveStarInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Starrable ID to unstar. */
  starrableId: Scalars['ID'];
};

/** Autogenerated return type of RemoveStar */
export type GQLRemoveStarPayload = {
  __typename?: 'RemoveStarPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The starrable. */
  starrable?: Maybe<GQLStarrable>;
};

/** Represents a 'removed_from_project' event on a given issue or pull request. */
export type GQLRemovedFromProjectEvent = GQLNode & {
  __typename?: 'RemovedFromProjectEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** Project referenced by event. */
  project?: Maybe<GQLProject>;
  /** Column name referenced by this project event. */
  projectColumnName: Scalars['String'];
};

/** Represents a 'renamed' event on a given issue or pull request */
export type GQLRenamedTitleEvent = GQLNode & {
  __typename?: 'RenamedTitleEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the current title of the issue or pull request. */
  currentTitle: Scalars['String'];
  id: Scalars['ID'];
  /** Identifies the previous title of the issue or pull request. */
  previousTitle: Scalars['String'];
  /** Subject that was renamed. */
  subject: GQLRenamedTitleSubject;
};

/** An object which has a renamable title */
export type GQLRenamedTitleSubject = GQLIssue | GQLPullRequest;

/** Autogenerated input type of ReopenIssue */
export type GQLReopenIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** ID of the issue to be opened. */
  issueId: Scalars['ID'];
};

/** Autogenerated return type of ReopenIssue */
export type GQLReopenIssuePayload = {
  __typename?: 'ReopenIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The issue that was opened. */
  issue?: Maybe<GQLIssue>;
};

/** Autogenerated input type of ReopenPullRequest */
export type GQLReopenPullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** ID of the pull request to be reopened. */
  pullRequestId: Scalars['ID'];
};

/** Autogenerated return type of ReopenPullRequest */
export type GQLReopenPullRequestPayload = {
  __typename?: 'ReopenPullRequestPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request that was reopened. */
  pullRequest?: Maybe<GQLPullRequest>;
};

/** Represents a 'reopened' event on any `Closable`. */
export type GQLReopenedEvent = GQLNode & {
  __typename?: 'ReopenedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Object that was reopened. */
  closable: GQLClosable;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
};

/** Audit log entry for a repo.access event. */
export type GQLRepoAccessAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & GQLRepositoryAuditEntryData & {
  __typename?: 'RepoAccessAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
  /** The visibility of the repository */
  visibility?: Maybe<GQLRepoAccessAuditEntryVisibility>;
};

/** The privacy of a repository */
export enum GQLRepoAccessAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}

/** Audit log entry for a repo.add_member event. */
export type GQLRepoAddMemberAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & GQLRepositoryAuditEntryData & {
  __typename?: 'RepoAddMemberAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
  /** The visibility of the repository */
  visibility?: Maybe<GQLRepoAddMemberAuditEntryVisibility>;
};

/** The privacy of a repository */
export enum GQLRepoAddMemberAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}

/** Audit log entry for a repo.add_topic event. */
export type GQLRepoAddTopicAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & GQLRepositoryAuditEntryData & GQLTopicAuditEntryData & {
  __typename?: 'RepoAddTopicAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
  /** The name of the topic added to the repository */
  topic?: Maybe<GQLTopic>;
  /** The name of the topic added to the repository */
  topicName?: Maybe<Scalars['String']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a repo.archived event. */
export type GQLRepoArchivedAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & GQLRepositoryAuditEntryData & {
  __typename?: 'RepoArchivedAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
  /** The visibility of the repository */
  visibility?: Maybe<GQLRepoArchivedAuditEntryVisibility>;
};

/** The privacy of a repository */
export enum GQLRepoArchivedAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}

/** Audit log entry for a repo.change_merge_setting event. */
export type GQLRepoChangeMergeSettingAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & GQLRepositoryAuditEntryData & {
  __typename?: 'RepoChangeMergeSettingAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** Whether the change was to enable (true) or disable (false) the merge type */
  isEnabled?: Maybe<Scalars['Boolean']>;
  /** The merge method affected by the change */
  mergeType?: Maybe<GQLRepoChangeMergeSettingAuditEntryMergeType>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** The merge options available for pull requests to this repository. */
export enum GQLRepoChangeMergeSettingAuditEntryMergeType {
  /** The pull request is added to the base branch in a merge commit. */
  Merge = 'MERGE',
  /** Commits from the pull request are added onto the base branch individually without a merge commit. */
  Rebase = 'REBASE',
  /** The pull request's commits are squashed into a single commit before they are merged to the base branch. */
  Squash = 'SQUASH'
}

/** Audit log entry for a repo.config.disable_anonymous_git_access event. */
export type GQLRepoConfigDisableAnonymousGitAccessAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & GQLRepositoryAuditEntryData & {
  __typename?: 'RepoConfigDisableAnonymousGitAccessAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a repo.config.disable_collaborators_only event. */
export type GQLRepoConfigDisableCollaboratorsOnlyAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & GQLRepositoryAuditEntryData & {
  __typename?: 'RepoConfigDisableCollaboratorsOnlyAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a repo.config.disable_contributors_only event. */
export type GQLRepoConfigDisableContributorsOnlyAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & GQLRepositoryAuditEntryData & {
  __typename?: 'RepoConfigDisableContributorsOnlyAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a repo.config.disable_sockpuppet_disallowed event. */
export type GQLRepoConfigDisableSockpuppetDisallowedAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & GQLRepositoryAuditEntryData & {
  __typename?: 'RepoConfigDisableSockpuppetDisallowedAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a repo.config.enable_anonymous_git_access event. */
export type GQLRepoConfigEnableAnonymousGitAccessAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & GQLRepositoryAuditEntryData & {
  __typename?: 'RepoConfigEnableAnonymousGitAccessAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a repo.config.enable_collaborators_only event. */
export type GQLRepoConfigEnableCollaboratorsOnlyAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & GQLRepositoryAuditEntryData & {
  __typename?: 'RepoConfigEnableCollaboratorsOnlyAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a repo.config.enable_contributors_only event. */
export type GQLRepoConfigEnableContributorsOnlyAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & GQLRepositoryAuditEntryData & {
  __typename?: 'RepoConfigEnableContributorsOnlyAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a repo.config.enable_sockpuppet_disallowed event. */
export type GQLRepoConfigEnableSockpuppetDisallowedAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & GQLRepositoryAuditEntryData & {
  __typename?: 'RepoConfigEnableSockpuppetDisallowedAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a repo.config.lock_anonymous_git_access event. */
export type GQLRepoConfigLockAnonymousGitAccessAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & GQLRepositoryAuditEntryData & {
  __typename?: 'RepoConfigLockAnonymousGitAccessAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a repo.config.unlock_anonymous_git_access event. */
export type GQLRepoConfigUnlockAnonymousGitAccessAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & GQLRepositoryAuditEntryData & {
  __typename?: 'RepoConfigUnlockAnonymousGitAccessAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a repo.create event. */
export type GQLRepoCreateAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & GQLRepositoryAuditEntryData & {
  __typename?: 'RepoCreateAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  /** The name of the parent repository for this forked repository. */
  forkParentName?: Maybe<Scalars['String']>;
  /** The name of the root repository for this netork. */
  forkSourceName?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
  /** The visibility of the repository */
  visibility?: Maybe<GQLRepoCreateAuditEntryVisibility>;
};

/** The privacy of a repository */
export enum GQLRepoCreateAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}

/** Audit log entry for a repo.destroy event. */
export type GQLRepoDestroyAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & GQLRepositoryAuditEntryData & {
  __typename?: 'RepoDestroyAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
  /** The visibility of the repository */
  visibility?: Maybe<GQLRepoDestroyAuditEntryVisibility>;
};

/** The privacy of a repository */
export enum GQLRepoDestroyAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}

/** Audit log entry for a repo.remove_member event. */
export type GQLRepoRemoveMemberAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & GQLRepositoryAuditEntryData & {
  __typename?: 'RepoRemoveMemberAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
  /** The visibility of the repository */
  visibility?: Maybe<GQLRepoRemoveMemberAuditEntryVisibility>;
};

/** The privacy of a repository */
export enum GQLRepoRemoveMemberAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}

/** Audit log entry for a repo.remove_topic event. */
export type GQLRepoRemoveTopicAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & GQLRepositoryAuditEntryData & GQLTopicAuditEntryData & {
  __typename?: 'RepoRemoveTopicAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
  /** The name of the topic added to the repository */
  topic?: Maybe<GQLTopic>;
  /** The name of the topic added to the repository */
  topicName?: Maybe<Scalars['String']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** The reasons a piece of content can be reported or minimized. */
export enum GQLReportedContentClassifiers {
  /** An abusive or harassing piece of content */
  Abuse = 'ABUSE',
  /** A duplicated piece of content */
  Duplicate = 'DUPLICATE',
  /** An irrelevant piece of content */
  OffTopic = 'OFF_TOPIC',
  /** An outdated piece of content */
  Outdated = 'OUTDATED',
  /** The content has been resolved */
  Resolved = 'RESOLVED',
  /** A spammy piece of content */
  Spam = 'SPAM'
}

/** A repository contains the content for a project. */
export type GQLRepository = GQLNode & GQLPackageOwner & GQLProjectOwner & GQLRegistryPackageOwner & GQLRegistryPackageSearch & GQLRepositoryInfo & GQLStarrable & GQLSubscribable & GQLUniformResourceLocatable & {
  __typename?: 'Repository';
  /** A list of users that can be assigned to issues in this repository. */
  assignableUsers: GQLUserConnection;
  /** A list of branch protection rules for this repository. */
  branchProtectionRules: GQLBranchProtectionRuleConnection;
  /** Returns the code of conduct for this repository */
  codeOfConduct?: Maybe<GQLCodeOfConduct>;
  /** A list of collaborators associated with the repository. */
  collaborators?: Maybe<GQLRepositoryCollaboratorConnection>;
  /** A list of commit comments associated with the repository. */
  commitComments: GQLCommitCommentConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The Ref associated with the repository's default branch. */
  defaultBranchRef?: Maybe<GQLRef>;
  /** Whether or not branches are automatically deleted when merged in this repository. */
  deleteBranchOnMerge: Scalars['Boolean'];
  /** A list of dependency manifests contained in the repository */
  dependencyGraphManifests?: Maybe<GQLDependencyGraphManifestConnection>;
  /** A list of deploy keys that are on this repository. */
  deployKeys: GQLDeployKeyConnection;
  /** Deployments associated with the repository */
  deployments: GQLDeploymentConnection;
  /** The description of the repository. */
  description?: Maybe<Scalars['String']>;
  /** The description of the repository rendered to HTML. */
  descriptionHTML: Scalars['HTML'];
  /** The number of kilobytes this repository occupies on disk. */
  diskUsage?: Maybe<Scalars['Int']>;
  /** Returns how many forks there are of this repository in the whole network. */
  forkCount: Scalars['Int'];
  /** A list of direct forked repositories. */
  forks: GQLRepositoryConnection;
  /** The funding links for this repository */
  fundingLinks: Array<GQLFundingLink>;
  /** Indicates if the repository has issues feature enabled. */
  hasIssuesEnabled: Scalars['Boolean'];
  /** Indicates if the repository has the Projects feature enabled. */
  hasProjectsEnabled: Scalars['Boolean'];
  /** Indicates if the repository has wiki feature enabled. */
  hasWikiEnabled: Scalars['Boolean'];
  /** The repository's URL. */
  homepageUrl?: Maybe<Scalars['URI']>;
  id: Scalars['ID'];
  /** Indicates if the repository is unmaintained. */
  isArchived: Scalars['Boolean'];
  /** Returns whether or not this repository disabled. */
  isDisabled: Scalars['Boolean'];
  /** Identifies if the repository is a fork. */
  isFork: Scalars['Boolean'];
  /** Indicates if the repository has been locked or not. */
  isLocked: Scalars['Boolean'];
  /** Identifies if the repository is a mirror. */
  isMirror: Scalars['Boolean'];
  /** Identifies if the repository is private. */
  isPrivate: Scalars['Boolean'];
  /** Identifies if the repository is a template that can be used to generate new repositories. */
  isTemplate: Scalars['Boolean'];
  /** Returns a single issue from the current repository by number. */
  issue?: Maybe<GQLIssue>;
  /** Returns a single issue-like object from the current repository by number. */
  issueOrPullRequest?: Maybe<GQLIssueOrPullRequest>;
  /** A list of issues that have been opened in the repository. */
  issues: GQLIssueConnection;
  /** Returns a single label by name */
  label?: Maybe<GQLLabel>;
  /** A list of labels associated with the repository. */
  labels?: Maybe<GQLLabelConnection>;
  /** A list containing a breakdown of the language composition of the repository. */
  languages?: Maybe<GQLLanguageConnection>;
  /** The license associated with the repository */
  licenseInfo?: Maybe<GQLLicense>;
  /** The reason the repository has been locked. */
  lockReason?: Maybe<GQLRepositoryLockReason>;
  /** A list of Users that can be mentioned in the context of the repository. */
  mentionableUsers: GQLUserConnection;
  /** Whether or not PRs are merged with a merge commit on this repository. */
  mergeCommitAllowed: Scalars['Boolean'];
  /** Returns a single milestone from the current repository by number. */
  milestone?: Maybe<GQLMilestone>;
  /** A list of milestones associated with the repository. */
  milestones?: Maybe<GQLMilestoneConnection>;
  /** The repository's original mirror URL. */
  mirrorUrl?: Maybe<Scalars['URI']>;
  /** The name of the repository. */
  name: Scalars['String'];
  /** The repository's name with owner. */
  nameWithOwner: Scalars['String'];
  /** A Git object in the repository */
  object?: Maybe<GQLGitObject>;
  /** The image used to represent this repository in Open Graph data. */
  openGraphImageUrl: Scalars['URI'];
  /** The User owner of the repository. */
  owner: GQLRepositoryOwner;
  /** A list of packages under the owner. */
  packages: GQLPackageConnection;
  /** The repository parent, if this is a fork. */
  parent?: Maybe<GQLRepository>;
  /** A list of pinned issues for this repository. */
  pinnedIssues?: Maybe<GQLPinnedIssueConnection>;
  /** The primary language of the repository's code. */
  primaryLanguage?: Maybe<GQLLanguage>;
  /** Find project by number. */
  project?: Maybe<GQLProject>;
  /** A list of projects under the owner. */
  projects: GQLProjectConnection;
  /** The HTTP path listing the repository's projects */
  projectsResourcePath: Scalars['URI'];
  /** The HTTP URL listing the repository's projects */
  projectsUrl: Scalars['URI'];
  /** Returns a single pull request from the current repository by number. */
  pullRequest?: Maybe<GQLPullRequest>;
  /** A list of pull requests that have been opened in the repository. */
  pullRequests: GQLPullRequestConnection;
  /** Identifies when the repository was last pushed to. */
  pushedAt?: Maybe<Scalars['DateTime']>;
  /** Whether or not rebase-merging is enabled on this repository. */
  rebaseMergeAllowed: Scalars['Boolean'];
  /** Fetch a given ref from the repository */
  ref?: Maybe<GQLRef>;
  /** Fetch a list of refs from the repository */
  refs?: Maybe<GQLRefConnection>;
  /**
   * A list of registry packages under the owner.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageOwner` object instead. Removal on 2020-04-01 UTC.
   */
  registryPackages: GQLRegistryPackageConnection;
  /**
   * A list of registry packages for a particular search query.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageSearch` object instead. Removal on 2020-04-01 UTC.
   */
  registryPackagesForQuery: GQLRegistryPackageConnection;
  /** Lookup a single release given various criteria. */
  release?: Maybe<GQLRelease>;
  /** List of releases which are dependent on this repository. */
  releases: GQLReleaseConnection;
  /** A list of applied repository-topic associations for this repository. */
  repositoryTopics: GQLRepositoryTopicConnection;
  /** The HTTP path for this repository */
  resourcePath: Scalars['URI'];
  /** A description of the repository, rendered to HTML without any links in it. */
  shortDescriptionHTML: Scalars['HTML'];
  /** Whether or not squash-merging is enabled on this repository. */
  squashMergeAllowed: Scalars['Boolean'];
  /** The SSH URL to clone this repository */
  sshUrl: Scalars['GitSSHRemote'];
  /** A list of users who have starred this starrable. */
  stargazers: GQLStargazerConnection;
  /**
   * Returns a list of all submodules in this repository parsed from the
   * .gitmodules file as of the default branch's HEAD commit.
   */
  submodules: GQLSubmoduleConnection;
  /** Temporary authentication token for cloning this repository. */
  tempCloneToken?: Maybe<Scalars['String']>;
  /** The repository from which this repository was generated, if any. */
  templateRepository?: Maybe<GQLRepository>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this repository */
  url: Scalars['URI'];
  /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */
  usesCustomOpenGraphImage: Scalars['Boolean'];
  /** Indicates whether the viewer has admin permissions on this repository. */
  viewerCanAdminister: Scalars['Boolean'];
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'];
  /** Indicates whether the viewer can update the topics of this repository. */
  viewerCanUpdateTopics: Scalars['Boolean'];
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean'];
  /** The users permission level on the repository. Will return null if authenticated as an GitHub App. */
  viewerPermission?: Maybe<GQLRepositoryPermission>;
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<GQLSubscriptionState>;
  /** A list of vulnerability alerts that are on this repository. */
  vulnerabilityAlerts?: Maybe<GQLRepositoryVulnerabilityAlertConnection>;
  /** A list of users watching the repository. */
  watchers: GQLUserConnection;
};


/** A repository contains the content for a project. */
export type GQLRepositoryAssignableUsersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  query?: Maybe<Scalars['String']>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryBranchProtectionRulesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryCollaboratorsArgs = {
  affiliation?: Maybe<GQLCollaboratorAffiliation>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  query?: Maybe<Scalars['String']>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryCommitCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryDependencyGraphManifestsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  dependenciesAfter?: Maybe<Scalars['String']>;
  dependenciesFirst?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  withDependencies?: Maybe<Scalars['Boolean']>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryDeployKeysArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryDeploymentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  environments?: Maybe<Array<Scalars['String']>>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLDeploymentOrder>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryForksArgs = {
  affiliations?: Maybe<Array<Maybe<GQLRepositoryAffiliation>>>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  isLocked?: Maybe<Scalars['Boolean']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLRepositoryOrder>;
  ownerAffiliations?: Maybe<Array<Maybe<GQLRepositoryAffiliation>>>;
  privacy?: Maybe<GQLRepositoryPrivacy>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryIssueArgs = {
  number: Scalars['Int'];
};


/** A repository contains the content for a project. */
export type GQLRepositoryIssueOrPullRequestArgs = {
  number: Scalars['Int'];
};


/** A repository contains the content for a project. */
export type GQLRepositoryIssuesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  filterBy?: Maybe<GQLIssueFilters>;
  first?: Maybe<Scalars['Int']>;
  labels?: Maybe<Array<Scalars['String']>>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLIssueOrder>;
  states?: Maybe<Array<GQLIssueState>>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryLabelArgs = {
  name: Scalars['String'];
};


/** A repository contains the content for a project. */
export type GQLRepositoryLabelsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLLabelOrder>;
  query?: Maybe<Scalars['String']>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryLanguagesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLLanguageOrder>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryMentionableUsersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  query?: Maybe<Scalars['String']>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryMilestoneArgs = {
  number: Scalars['Int'];
};


/** A repository contains the content for a project. */
export type GQLRepositoryMilestonesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLMilestoneOrder>;
  states?: Maybe<Array<GQLMilestoneState>>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryObjectArgs = {
  expression?: Maybe<Scalars['String']>;
  oid?: Maybe<Scalars['GitObjectID']>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryPackagesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  names?: Maybe<Array<Maybe<Scalars['String']>>>;
  orderBy?: Maybe<GQLPackageOrder>;
  repositoryId?: Maybe<Scalars['ID']>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryPinnedIssuesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryProjectArgs = {
  number: Scalars['Int'];
};


/** A repository contains the content for a project. */
export type GQLRepositoryProjectsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLProjectOrder>;
  search?: Maybe<Scalars['String']>;
  states?: Maybe<Array<GQLProjectState>>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryPullRequestArgs = {
  number: Scalars['Int'];
};


/** A repository contains the content for a project. */
export type GQLRepositoryPullRequestsArgs = {
  after?: Maybe<Scalars['String']>;
  baseRefName?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  headRefName?: Maybe<Scalars['String']>;
  labels?: Maybe<Array<Scalars['String']>>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLIssueOrder>;
  states?: Maybe<Array<GQLPullRequestState>>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryRefArgs = {
  qualifiedName: Scalars['String'];
};


/** A repository contains the content for a project. */
export type GQLRepositoryRefsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  direction?: Maybe<GQLOrderDirection>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLRefOrder>;
  query?: Maybe<Scalars['String']>;
  refPrefix: Scalars['String'];
};


/** A repository contains the content for a project. */
export type GQLRepositoryRegistryPackagesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  names?: Maybe<Array<Maybe<Scalars['String']>>>;
  packageType?: Maybe<GQLRegistryPackageType>;
  publicOnly?: Maybe<Scalars['Boolean']>;
  registryPackageType?: Maybe<Scalars['String']>;
  repositoryId?: Maybe<Scalars['ID']>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryRegistryPackagesForQueryArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  packageType?: Maybe<GQLRegistryPackageType>;
  query?: Maybe<Scalars['String']>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryReleaseArgs = {
  tagName: Scalars['String'];
};


/** A repository contains the content for a project. */
export type GQLRepositoryReleasesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLReleaseOrder>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryRepositoryTopicsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryShortDescriptionHtmlArgs = {
  limit?: Maybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryStargazersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLStarOrder>;
};


/** A repository contains the content for a project. */
export type GQLRepositorySubmodulesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryVulnerabilityAlertsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type GQLRepositoryWatchersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** The affiliation of a user to a repository */
export enum GQLRepositoryAffiliation {
  /** Repositories that the user has been added to as a collaborator. */
  Collaborator = 'COLLABORATOR',
  /**
   * Repositories that the user has access to through being a member of an
   * organization. This includes every repository on every team that the user is on.
   */
  OrganizationMember = 'ORGANIZATION_MEMBER',
  /** Repositories that are owned by the authenticated user. */
  Owner = 'OWNER'
}

/** Metadata for an audit entry with action repo.* */
export type GQLRepositoryAuditEntryData = {
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
};

/** The connection type for User. */
export type GQLRepositoryCollaboratorConnection = {
  __typename?: 'RepositoryCollaboratorConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLRepositoryCollaboratorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLUser>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a user who is a collaborator of a repository. */
export type GQLRepositoryCollaboratorEdge = {
  __typename?: 'RepositoryCollaboratorEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  node: GQLUser;
  /**
   * The permission the user has on the repository.
   * 
   * **Upcoming Change on 2020-10-01 UTC**
   * **Description:** Type for `permission` will change from `RepositoryPermission!` to `String`.
   * **Reason:** This field may return additional values
   */
  permission: GQLRepositoryPermission;
  /** A list of sources for the user's access to the repository. */
  permissionSources?: Maybe<Array<GQLPermissionSource>>;
};

/** A list of repositories owned by the subject. */
export type GQLRepositoryConnection = {
  __typename?: 'RepositoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLRepositoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLRepository>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
  /** The total size in kilobytes of all repositories in the connection. */
  totalDiskUsage: Scalars['Int'];
};

/** The reason a repository is listed as 'contributed'. */
export enum GQLRepositoryContributionType {
  /** Created a commit */
  Commit = 'COMMIT',
  /** Created an issue */
  Issue = 'ISSUE',
  /** Created a pull request */
  PullRequest = 'PULL_REQUEST',
  /** Reviewed a pull request */
  PullRequestReview = 'PULL_REQUEST_REVIEW',
  /** Created the repository */
  Repository = 'REPOSITORY'
}

/** An edge in a connection. */
export type GQLRepositoryEdge = {
  __typename?: 'RepositoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLRepository>;
};

/** A subset of repository info. */
export type GQLRepositoryInfo = {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The description of the repository. */
  description?: Maybe<Scalars['String']>;
  /** The description of the repository rendered to HTML. */
  descriptionHTML: Scalars['HTML'];
  /** Returns how many forks there are of this repository in the whole network. */
  forkCount: Scalars['Int'];
  /** Indicates if the repository has issues feature enabled. */
  hasIssuesEnabled: Scalars['Boolean'];
  /** Indicates if the repository has the Projects feature enabled. */
  hasProjectsEnabled: Scalars['Boolean'];
  /** Indicates if the repository has wiki feature enabled. */
  hasWikiEnabled: Scalars['Boolean'];
  /** The repository's URL. */
  homepageUrl?: Maybe<Scalars['URI']>;
  /** Indicates if the repository is unmaintained. */
  isArchived: Scalars['Boolean'];
  /** Identifies if the repository is a fork. */
  isFork: Scalars['Boolean'];
  /** Indicates if the repository has been locked or not. */
  isLocked: Scalars['Boolean'];
  /** Identifies if the repository is a mirror. */
  isMirror: Scalars['Boolean'];
  /** Identifies if the repository is private. */
  isPrivate: Scalars['Boolean'];
  /** Identifies if the repository is a template that can be used to generate new repositories. */
  isTemplate: Scalars['Boolean'];
  /** The license associated with the repository */
  licenseInfo?: Maybe<GQLLicense>;
  /** The reason the repository has been locked. */
  lockReason?: Maybe<GQLRepositoryLockReason>;
  /** The repository's original mirror URL. */
  mirrorUrl?: Maybe<Scalars['URI']>;
  /** The name of the repository. */
  name: Scalars['String'];
  /** The repository's name with owner. */
  nameWithOwner: Scalars['String'];
  /** The image used to represent this repository in Open Graph data. */
  openGraphImageUrl: Scalars['URI'];
  /** The User owner of the repository. */
  owner: GQLRepositoryOwner;
  /** Identifies when the repository was last pushed to. */
  pushedAt?: Maybe<Scalars['DateTime']>;
  /** The HTTP path for this repository */
  resourcePath: Scalars['URI'];
  /** A description of the repository, rendered to HTML without any links in it. */
  shortDescriptionHTML: Scalars['HTML'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this repository */
  url: Scalars['URI'];
  /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */
  usesCustomOpenGraphImage: Scalars['Boolean'];
};


/** A subset of repository info. */
export type GQLRepositoryInfoShortDescriptionHtmlArgs = {
  limit?: Maybe<Scalars['Int']>;
};

/** An invitation for a user to be added to a repository. */
export type GQLRepositoryInvitation = GQLNode & {
  __typename?: 'RepositoryInvitation';
  /** The email address that received the invitation. */
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The user who received the invitation. */
  invitee?: Maybe<GQLUser>;
  /** The user who created the invitation. */
  inviter: GQLUser;
  /**
   * The permission granted on this repository by this invitation.
   * 
   * **Upcoming Change on 2020-10-01 UTC**
   * **Description:** Type for `permission` will change from `RepositoryPermission!` to `String`.
   * **Reason:** This field may return additional values
   */
  permission: GQLRepositoryPermission;
  /** The Repository the user is invited to. */
  repository?: Maybe<GQLRepositoryInfo>;
};

/** The connection type for RepositoryInvitation. */
export type GQLRepositoryInvitationConnection = {
  __typename?: 'RepositoryInvitationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLRepositoryInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLRepositoryInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLRepositoryInvitationEdge = {
  __typename?: 'RepositoryInvitationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLRepositoryInvitation>;
};

/** Ordering options for repository invitation connections. */
export type GQLRepositoryInvitationOrder = {
  /** The ordering direction. */
  direction: GQLOrderDirection;
  /** The field to order repository invitations by. */
  field: GQLRepositoryInvitationOrderField;
};

/** Properties by which repository invitation connections can be ordered. */
export enum GQLRepositoryInvitationOrderField {
  /** Order repository invitations by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order repository invitations by invitee login */
  InviteeLogin = 'INVITEE_LOGIN'
}

/** The possible reasons a given repository could be in a locked state. */
export enum GQLRepositoryLockReason {
  /** The repository is locked due to a billing related reason. */
  Billing = 'BILLING',
  /** The repository is locked due to a migration. */
  Migrating = 'MIGRATING',
  /** The repository is locked due to a move. */
  Moving = 'MOVING',
  /** The repository is locked due to a rename. */
  Rename = 'RENAME'
}

/** Represents a object that belongs to a repository. */
export type GQLRepositoryNode = {
  /** The repository associated with this node. */
  repository: GQLRepository;
};

/** Ordering options for repository connections */
export type GQLRepositoryOrder = {
  /** The ordering direction. */
  direction: GQLOrderDirection;
  /** The field to order repositories by. */
  field: GQLRepositoryOrderField;
};

/** Properties by which repository connections can be ordered. */
export enum GQLRepositoryOrderField {
  /** Order repositories by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order repositories by name */
  Name = 'NAME',
  /** Order repositories by push time */
  PushedAt = 'PUSHED_AT',
  /** Order repositories by number of stargazers */
  Stargazers = 'STARGAZERS',
  /** Order repositories by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** Represents an owner of a Repository. */
export type GQLRepositoryOwner = {
  /** A URL pointing to the owner's public avatar. */
  avatarUrl: Scalars['URI'];
  id: Scalars['ID'];
  /** The username used to login. */
  login: Scalars['String'];
  /** A list of repositories that the user owns. */
  repositories: GQLRepositoryConnection;
  /** Find Repository. */
  repository?: Maybe<GQLRepository>;
  /** The HTTP URL for the owner. */
  resourcePath: Scalars['URI'];
  /** The HTTP URL for the owner. */
  url: Scalars['URI'];
};


/** Represents an owner of a Repository. */
export type GQLRepositoryOwnerAvatarUrlArgs = {
  size?: Maybe<Scalars['Int']>;
};


/** Represents an owner of a Repository. */
export type GQLRepositoryOwnerRepositoriesArgs = {
  affiliations?: Maybe<Array<Maybe<GQLRepositoryAffiliation>>>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  isFork?: Maybe<Scalars['Boolean']>;
  isLocked?: Maybe<Scalars['Boolean']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLRepositoryOrder>;
  ownerAffiliations?: Maybe<Array<Maybe<GQLRepositoryAffiliation>>>;
  privacy?: Maybe<GQLRepositoryPrivacy>;
};


/** Represents an owner of a Repository. */
export type GQLRepositoryOwnerRepositoryArgs = {
  name: Scalars['String'];
};

/** The access level to a repository */
export enum GQLRepositoryPermission {
  /**
   * Can read, clone, and push to this repository. Can also manage issues, pull
   * requests, and repository settings, including adding collaborators
   */
  Admin = 'ADMIN',
  /** Can read, clone, and push to this repository. They can also manage issues, pull requests, and some repository settings */
  Maintain = 'MAINTAIN',
  /** Can read and clone this repository. Can also open and comment on issues and pull requests */
  Read = 'READ',
  /** Can read and clone this repository. Can also manage issues and pull requests */
  Triage = 'TRIAGE',
  /** Can read, clone, and push to this repository. Can also manage issues and pull requests */
  Write = 'WRITE'
}

/** The privacy of a repository */
export enum GQLRepositoryPrivacy {
  /** Private */
  Private = 'PRIVATE',
  /** Public */
  Public = 'PUBLIC'
}

/** A repository-topic connects a repository to a topic. */
export type GQLRepositoryTopic = GQLNode & GQLUniformResourceLocatable & {
  __typename?: 'RepositoryTopic';
  id: Scalars['ID'];
  /** The HTTP path for this repository-topic. */
  resourcePath: Scalars['URI'];
  /** The topic. */
  topic: GQLTopic;
  /** The HTTP URL for this repository-topic. */
  url: Scalars['URI'];
};

/** The connection type for RepositoryTopic. */
export type GQLRepositoryTopicConnection = {
  __typename?: 'RepositoryTopicConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLRepositoryTopicEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLRepositoryTopic>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLRepositoryTopicEdge = {
  __typename?: 'RepositoryTopicEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLRepositoryTopic>;
};

/** The repository's visibility level. */
export enum GQLRepositoryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}

/** Audit log entry for a repository_visibility_change.disable event. */
export type GQLRepositoryVisibilityChangeDisableAuditEntry = GQLAuditEntry & GQLEnterpriseAuditEntryData & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'RepositoryVisibilityChangeDisableAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a repository_visibility_change.enable event. */
export type GQLRepositoryVisibilityChangeEnableAuditEntry = GQLAuditEntry & GQLEnterpriseAuditEntryData & GQLNode & GQLOrganizationAuditEntryData & {
  __typename?: 'RepositoryVisibilityChangeEnableAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['URI']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** A alert for a repository with an affected vulnerability. */
export type GQLRepositoryVulnerabilityAlert = GQLNode & GQLRepositoryNode & {
  __typename?: 'RepositoryVulnerabilityAlert';
  /** When was the alert created? */
  createdAt: Scalars['DateTime'];
  /** The reason the alert was dismissed */
  dismissReason?: Maybe<Scalars['String']>;
  /** When was the alert dimissed? */
  dismissedAt?: Maybe<Scalars['DateTime']>;
  /** The user who dismissed the alert */
  dismisser?: Maybe<GQLUser>;
  id: Scalars['ID'];
  /** The associated repository */
  repository: GQLRepository;
  /** The associated security advisory */
  securityAdvisory?: Maybe<GQLSecurityAdvisory>;
  /** The associated security vulnerablity */
  securityVulnerability?: Maybe<GQLSecurityVulnerability>;
  /** The vulnerable manifest filename */
  vulnerableManifestFilename: Scalars['String'];
  /** The vulnerable manifest path */
  vulnerableManifestPath: Scalars['String'];
  /** The vulnerable requirements */
  vulnerableRequirements?: Maybe<Scalars['String']>;
};

/** The connection type for RepositoryVulnerabilityAlert. */
export type GQLRepositoryVulnerabilityAlertConnection = {
  __typename?: 'RepositoryVulnerabilityAlertConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLRepositoryVulnerabilityAlertEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLRepositoryVulnerabilityAlert>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLRepositoryVulnerabilityAlertEdge = {
  __typename?: 'RepositoryVulnerabilityAlertEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLRepositoryVulnerabilityAlert>;
};

/** Autogenerated input type of RequestReviews */
export type GQLRequestReviewsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the pull request to modify. */
  pullRequestId: Scalars['ID'];
  /** The Node IDs of the team to request. */
  teamIds?: Maybe<Array<Scalars['ID']>>;
  /** Add users to the set rather than replace. */
  union?: Maybe<Scalars['Boolean']>;
  /** The Node IDs of the user to request. */
  userIds?: Maybe<Array<Scalars['ID']>>;
};

/** Autogenerated return type of RequestReviews */
export type GQLRequestReviewsPayload = {
  __typename?: 'RequestReviewsPayload';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request that is getting requests. */
  pullRequest?: Maybe<GQLPullRequest>;
  /** The edge from the pull request to the requested reviewers. */
  requestedReviewersEdge?: Maybe<GQLUserEdge>;
};

/** The possible states that can be requested when creating a check run. */
export enum GQLRequestableCheckStatusState {
  /** The check suite or run has been completed. */
  Completed = 'COMPLETED',
  /** The check suite or run is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The check suite or run has been queued. */
  Queued = 'QUEUED'
}

/** Types that can be requested reviewers. */
export type GQLRequestedReviewer = GQLMannequin | GQLTeam | GQLUser;

/** Autogenerated input type of RerequestCheckSuite */
export type GQLRerequestCheckSuiteInput = {
  /** The Node ID of the check suite. */
  checkSuiteId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of RerequestCheckSuite */
export type GQLRerequestCheckSuitePayload = {
  __typename?: 'RerequestCheckSuitePayload';
  /** The requested check suite. */
  checkSuite?: Maybe<GQLCheckSuite>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of ResolveReviewThread */
export type GQLResolveReviewThreadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the thread to resolve */
  threadId: Scalars['ID'];
};

/** Autogenerated return type of ResolveReviewThread */
export type GQLResolveReviewThreadPayload = {
  __typename?: 'ResolveReviewThreadPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The thread to resolve. */
  thread?: Maybe<GQLPullRequestReviewThread>;
};

/** Represents a private contribution a user made on GitHub. */
export type GQLRestrictedContribution = GQLContribution & {
  __typename?: 'RestrictedContribution';
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['URI'];
  /** The user who made this contribution. */
  user: GQLUser;
};

/** A team or user who has the ability to dismiss a review on a protected branch. */
export type GQLReviewDismissalAllowance = GQLNode & {
  __typename?: 'ReviewDismissalAllowance';
  /** The actor that can dismiss. */
  actor?: Maybe<GQLReviewDismissalAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user or team. */
  branchProtectionRule?: Maybe<GQLBranchProtectionRule>;
  id: Scalars['ID'];
};

/** Types that can be an actor. */
export type GQLReviewDismissalAllowanceActor = GQLTeam | GQLUser;

/** The connection type for ReviewDismissalAllowance. */
export type GQLReviewDismissalAllowanceConnection = {
  __typename?: 'ReviewDismissalAllowanceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLReviewDismissalAllowanceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLReviewDismissalAllowance>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLReviewDismissalAllowanceEdge = {
  __typename?: 'ReviewDismissalAllowanceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLReviewDismissalAllowance>;
};

/** Represents a 'review_dismissed' event on a given issue or pull request. */
export type GQLReviewDismissedEvent = GQLNode & GQLUniformResourceLocatable & {
  __typename?: 'ReviewDismissedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** Identifies the optional message associated with the 'review_dismissed' event. */
  dismissalMessage?: Maybe<Scalars['String']>;
  /** Identifies the optional message associated with the event, rendered to HTML. */
  dismissalMessageHTML?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** Identifies the previous state of the review with the 'review_dismissed' event. */
  previousReviewState: GQLPullRequestReviewState;
  /** PullRequest referenced by event. */
  pullRequest: GQLPullRequest;
  /** Identifies the commit which caused the review to become stale. */
  pullRequestCommit?: Maybe<GQLPullRequestCommit>;
  /** The HTTP path for this review dismissed event. */
  resourcePath: Scalars['URI'];
  /** Identifies the review associated with the 'review_dismissed' event. */
  review?: Maybe<GQLPullRequestReview>;
  /** The HTTP URL for this review dismissed event. */
  url: Scalars['URI'];
};

/** A request for a user to review a pull request. */
export type GQLReviewRequest = GQLNode & {
  __typename?: 'ReviewRequest';
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** Identifies the pull request associated with this review request. */
  pullRequest: GQLPullRequest;
  /** The reviewer that is requested. */
  requestedReviewer?: Maybe<GQLRequestedReviewer>;
};

/** The connection type for ReviewRequest. */
export type GQLReviewRequestConnection = {
  __typename?: 'ReviewRequestConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLReviewRequestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLReviewRequest>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLReviewRequestEdge = {
  __typename?: 'ReviewRequestEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLReviewRequest>;
};

/** Represents an 'review_request_removed' event on a given pull request. */
export type GQLReviewRequestRemovedEvent = GQLNode & {
  __typename?: 'ReviewRequestRemovedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: GQLPullRequest;
  /** Identifies the reviewer whose review request was removed. */
  requestedReviewer?: Maybe<GQLRequestedReviewer>;
};

/** Represents an 'review_requested' event on a given pull request. */
export type GQLReviewRequestedEvent = GQLNode & {
  __typename?: 'ReviewRequestedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: GQLPullRequest;
  /** Identifies the reviewer whose review was requested. */
  requestedReviewer?: Maybe<GQLRequestedReviewer>;
};

/**
 * A hovercard context with a message describing the current code review state of the pull
 * request.
 */
export type GQLReviewStatusHovercardContext = GQLHovercardContext & {
  __typename?: 'ReviewStatusHovercardContext';
  /** A string describing this context */
  message: Scalars['String'];
  /** An octicon to accompany this context */
  octicon: Scalars['String'];
  /** The current status of the pull request with respect to code review. */
  reviewDecision?: Maybe<GQLPullRequestReviewDecision>;
};

/** The possible digest algorithms used to sign SAML requests for an identity provider. */
export enum GQLSamlDigestAlgorithm {
  /** SHA1 */
  Sha1 = 'SHA1',
  /** SHA256 */
  Sha256 = 'SHA256',
  /** SHA384 */
  Sha384 = 'SHA384',
  /** SHA512 */
  Sha512 = 'SHA512'
}

/** The possible signature algorithms used to sign SAML requests for a Identity Provider. */
export enum GQLSamlSignatureAlgorithm {
  /** RSA-SHA1 */
  RsaSha1 = 'RSA_SHA1',
  /** RSA-SHA256 */
  RsaSha256 = 'RSA_SHA256',
  /** RSA-SHA384 */
  RsaSha384 = 'RSA_SHA384',
  /** RSA-SHA512 */
  RsaSha512 = 'RSA_SHA512'
}

/** A Saved Reply is text a user can use to reply quickly. */
export type GQLSavedReply = GQLNode & {
  __typename?: 'SavedReply';
  /** The body of the saved reply. */
  body: Scalars['String'];
  /** The saved reply body rendered to HTML. */
  bodyHTML: Scalars['HTML'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The title of the saved reply. */
  title: Scalars['String'];
  /** The user that saved this reply. */
  user?: Maybe<GQLActor>;
};

/** The connection type for SavedReply. */
export type GQLSavedReplyConnection = {
  __typename?: 'SavedReplyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLSavedReplyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLSavedReply>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLSavedReplyEdge = {
  __typename?: 'SavedReplyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLSavedReply>;
};

/** Ordering options for saved reply connections. */
export type GQLSavedReplyOrder = {
  /** The ordering direction. */
  direction: GQLOrderDirection;
  /** The field to order saved replies by. */
  field: GQLSavedReplyOrderField;
};

/** Properties by which saved reply connections can be ordered. */
export enum GQLSavedReplyOrderField {
  /** Order saved reply by when they were updated. */
  UpdatedAt = 'UPDATED_AT'
}

/** The results of a search. */
export type GQLSearchResultItem = GQLApp | GQLIssue | GQLMarketplaceListing | GQLOrganization | GQLPullRequest | GQLRepository | GQLUser;

/** A list of results that matched against a search query. */
export type GQLSearchResultItemConnection = {
  __typename?: 'SearchResultItemConnection';
  /** The number of pieces of code that matched the search query. */
  codeCount: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLSearchResultItemEdge>>>;
  /** The number of issues that matched the search query. */
  issueCount: Scalars['Int'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLSearchResultItem>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** The number of repositories that matched the search query. */
  repositoryCount: Scalars['Int'];
  /** The number of users that matched the search query. */
  userCount: Scalars['Int'];
  /** The number of wiki pages that matched the search query. */
  wikiCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLSearchResultItemEdge = {
  __typename?: 'SearchResultItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLSearchResultItem>;
  /** Text matches on the result found. */
  textMatches?: Maybe<Array<Maybe<GQLTextMatch>>>;
};

/** Represents the individual results of a search. */
export enum GQLSearchType {
  /** Returns results matching issues in repositories. */
  Issue = 'ISSUE',
  /** Returns results matching repositories. */
  Repository = 'REPOSITORY',
  /** Returns results matching users and organizations on GitHub. */
  User = 'USER'
}

/** A GitHub Security Advisory */
export type GQLSecurityAdvisory = GQLNode & {
  __typename?: 'SecurityAdvisory';
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** This is a long plaintext description of the advisory */
  description: Scalars['String'];
  /** The GitHub Security Advisory ID */
  ghsaId: Scalars['String'];
  id: Scalars['ID'];
  /** A list of identifiers for this advisory */
  identifiers: Array<GQLSecurityAdvisoryIdentifier>;
  /** The organization that originated the advisory */
  origin: Scalars['String'];
  /** The permalink for the advisory */
  permalink?: Maybe<Scalars['URI']>;
  /** When the advisory was published */
  publishedAt: Scalars['DateTime'];
  /** A list of references for this advisory */
  references: Array<GQLSecurityAdvisoryReference>;
  /** The severity of the advisory */
  severity: GQLSecurityAdvisorySeverity;
  /** A short plaintext summary of the advisory */
  summary: Scalars['String'];
  /** When the advisory was last updated */
  updatedAt: Scalars['DateTime'];
  /** Vulnerabilities associated with this Advisory */
  vulnerabilities: GQLSecurityVulnerabilityConnection;
  /** When the advisory was withdrawn, if it has been withdrawn */
  withdrawnAt?: Maybe<Scalars['DateTime']>;
};


/** A GitHub Security Advisory */
export type GQLSecurityAdvisoryVulnerabilitiesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  ecosystem?: Maybe<GQLSecurityAdvisoryEcosystem>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLSecurityVulnerabilityOrder>;
  package?: Maybe<Scalars['String']>;
  severities?: Maybe<Array<GQLSecurityAdvisorySeverity>>;
};

/** The connection type for SecurityAdvisory. */
export type GQLSecurityAdvisoryConnection = {
  __typename?: 'SecurityAdvisoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLSecurityAdvisoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLSecurityAdvisory>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** The possible ecosystems of a security vulnerability's package. */
export enum GQLSecurityAdvisoryEcosystem {
  /** PHP packages hosted at packagist.org */
  Composer = 'COMPOSER',
  /** Java artifacts hosted at the Maven central repository */
  Maven = 'MAVEN',
  /** JavaScript packages hosted at npmjs.com */
  Npm = 'NPM',
  /** .NET packages hosted at the NuGet Gallery */
  Nuget = 'NUGET',
  /** Python packages hosted at PyPI.org */
  Pip = 'PIP',
  /** Ruby gems hosted at RubyGems.org */
  Rubygems = 'RUBYGEMS'
}

/** An edge in a connection. */
export type GQLSecurityAdvisoryEdge = {
  __typename?: 'SecurityAdvisoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLSecurityAdvisory>;
};

/** A GitHub Security Advisory Identifier */
export type GQLSecurityAdvisoryIdentifier = {
  __typename?: 'SecurityAdvisoryIdentifier';
  /** The identifier type, e.g. GHSA, CVE */
  type: Scalars['String'];
  /** The identifier */
  value: Scalars['String'];
};

/** An advisory identifier to filter results on. */
export type GQLSecurityAdvisoryIdentifierFilter = {
  /** The identifier type. */
  type: GQLSecurityAdvisoryIdentifierType;
  /** The identifier string. Supports exact or partial matching. */
  value: Scalars['String'];
};

/** Identifier formats available for advisories. */
export enum GQLSecurityAdvisoryIdentifierType {
  /** Common Vulnerabilities and Exposures Identifier. */
  Cve = 'CVE',
  /** GitHub Security Advisory ID. */
  Ghsa = 'GHSA'
}

/** Ordering options for security advisory connections */
export type GQLSecurityAdvisoryOrder = {
  /** The ordering direction. */
  direction: GQLOrderDirection;
  /** The field to order security advisories by. */
  field: GQLSecurityAdvisoryOrderField;
};

/** Properties by which security advisory connections can be ordered. */
export enum GQLSecurityAdvisoryOrderField {
  /** Order advisories by publication time */
  PublishedAt = 'PUBLISHED_AT',
  /** Order advisories by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** An individual package */
export type GQLSecurityAdvisoryPackage = {
  __typename?: 'SecurityAdvisoryPackage';
  /** The ecosystem the package belongs to, e.g. RUBYGEMS, NPM */
  ecosystem: GQLSecurityAdvisoryEcosystem;
  /** The package name */
  name: Scalars['String'];
};

/** An individual package version */
export type GQLSecurityAdvisoryPackageVersion = {
  __typename?: 'SecurityAdvisoryPackageVersion';
  /** The package name or version */
  identifier: Scalars['String'];
};

/** A GitHub Security Advisory Reference */
export type GQLSecurityAdvisoryReference = {
  __typename?: 'SecurityAdvisoryReference';
  /** A publicly accessible reference */
  url: Scalars['URI'];
};

/** Severity of the vulnerability. */
export enum GQLSecurityAdvisorySeverity {
  /** Critical. */
  Critical = 'CRITICAL',
  /** High. */
  High = 'HIGH',
  /** Low. */
  Low = 'LOW',
  /** Moderate. */
  Moderate = 'MODERATE'
}

/** An individual vulnerability within an Advisory */
export type GQLSecurityVulnerability = {
  __typename?: 'SecurityVulnerability';
  /** The Advisory associated with this Vulnerability */
  advisory: GQLSecurityAdvisory;
  /** The first version containing a fix for the vulnerability */
  firstPatchedVersion?: Maybe<GQLSecurityAdvisoryPackageVersion>;
  /** A description of the vulnerable package */
  package: GQLSecurityAdvisoryPackage;
  /** The severity of the vulnerability within this package */
  severity: GQLSecurityAdvisorySeverity;
  /** When the vulnerability was last updated */
  updatedAt: Scalars['DateTime'];
  /**
   * A string that describes the vulnerable package versions.
   * This string follows a basic syntax with a few forms.
   * + `= 0.2.0` denotes a single vulnerable version.
   * + `<= 1.0.8` denotes a version range up to and including the specified version
   * + `< 0.1.11` denotes a version range up to, but excluding, the specified version
   * + `>= 4.3.0, < 4.3.5` denotes a version range with a known minimum and maximum version.
   * + `>= 0.0.1` denotes a version range with a known minimum, but no known maximum
   */
  vulnerableVersionRange: Scalars['String'];
};

/** The connection type for SecurityVulnerability. */
export type GQLSecurityVulnerabilityConnection = {
  __typename?: 'SecurityVulnerabilityConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLSecurityVulnerabilityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLSecurityVulnerability>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLSecurityVulnerabilityEdge = {
  __typename?: 'SecurityVulnerabilityEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLSecurityVulnerability>;
};

/** Ordering options for security vulnerability connections */
export type GQLSecurityVulnerabilityOrder = {
  /** The ordering direction. */
  direction: GQLOrderDirection;
  /** The field to order security vulnerabilities by. */
  field: GQLSecurityVulnerabilityOrderField;
};

/** Properties by which security vulnerability connections can be ordered. */
export enum GQLSecurityVulnerabilityOrderField {
  /** Order vulnerability by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** Autogenerated input type of SetEnterpriseIdentityProvider */
export type GQLSetEnterpriseIdentityProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The digest algorithm used to sign SAML requests for the identity provider. */
  digestMethod: GQLSamlDigestAlgorithm;
  /** The ID of the enterprise on which to set an identity provider. */
  enterpriseId: Scalars['ID'];
  /** The x509 certificate used by the identity provider to sign assertions and responses. */
  idpCertificate: Scalars['String'];
  /** The Issuer Entity ID for the SAML identity provider */
  issuer?: Maybe<Scalars['String']>;
  /** The signature algorithm used to sign SAML requests for the identity provider. */
  signatureMethod: GQLSamlSignatureAlgorithm;
  /** The URL endpoint for the identity provider's SAML SSO. */
  ssoUrl: Scalars['URI'];
};

/** Autogenerated return type of SetEnterpriseIdentityProvider */
export type GQLSetEnterpriseIdentityProviderPayload = {
  __typename?: 'SetEnterpriseIdentityProviderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The identity provider for the enterprise. */
  identityProvider?: Maybe<GQLEnterpriseIdentityProvider>;
};

/** Represents an S/MIME signature on a Commit or Tag. */
export type GQLSmimeSignature = GQLGitSignature & {
  __typename?: 'SmimeSignature';
  /** Email used to sign this object. */
  email: Scalars['String'];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean'];
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String'];
  /** ASCII-armored signature header from object. */
  signature: Scalars['String'];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<GQLUser>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: GQLGitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean'];
};

/** Entites that can sponsor others via GitHub Sponsors */
export type GQLSponsor = GQLOrganization | GQLUser;

/** Entities that can be sponsored through GitHub Sponsors */
export type GQLSponsorable = {
  /** The GitHub Sponsors listing for this user. */
  sponsorsListing?: Maybe<GQLSponsorsListing>;
  /** This object's sponsorships as the maintainer. */
  sponsorshipsAsMaintainer: GQLSponsorshipConnection;
  /** This object's sponsorships as the sponsor. */
  sponsorshipsAsSponsor: GQLSponsorshipConnection;
};


/** Entities that can be sponsored through GitHub Sponsors */
export type GQLSponsorableSponsorshipsAsMaintainerArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  includePrivate?: Maybe<Scalars['Boolean']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLSponsorshipOrder>;
};


/** Entities that can be sponsored through GitHub Sponsors */
export type GQLSponsorableSponsorshipsAsSponsorArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLSponsorshipOrder>;
};

/** A GitHub Sponsors listing. */
export type GQLSponsorsListing = GQLNode & {
  __typename?: 'SponsorsListing';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The full description of the listing. */
  fullDescription: Scalars['String'];
  /** The full description of the listing rendered to HTML. */
  fullDescriptionHTML: Scalars['HTML'];
  id: Scalars['ID'];
  /** The listing's full name. */
  name: Scalars['String'];
  /** The short description of the listing. */
  shortDescription: Scalars['String'];
  /** The short name of the listing. */
  slug: Scalars['String'];
  /** The published tiers for this GitHub Sponsors listing. */
  tiers?: Maybe<GQLSponsorsTierConnection>;
};


/** A GitHub Sponsors listing. */
export type GQLSponsorsListingTiersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLSponsorsTierOrder>;
};

/** A GitHub Sponsors tier associated with a GitHub Sponsors listing. */
export type GQLSponsorsTier = GQLNode & {
  __typename?: 'SponsorsTier';
  /** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */
  adminInfo?: Maybe<GQLSponsorsTierAdminInfo>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The description of the tier. */
  description: Scalars['String'];
  /** The tier description rendered to HTML */
  descriptionHTML: Scalars['HTML'];
  id: Scalars['ID'];
  /** How much this tier costs per month in cents. */
  monthlyPriceInCents: Scalars['Int'];
  /** How much this tier costs per month in dollars. */
  monthlyPriceInDollars: Scalars['Int'];
  /** The name of the tier. */
  name: Scalars['String'];
  /** The sponsors listing that this tier belongs to. */
  sponsorsListing: GQLSponsorsListing;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */
export type GQLSponsorsTierAdminInfo = {
  __typename?: 'SponsorsTierAdminInfo';
  /** The sponsorships associated with this tier. */
  sponsorships: GQLSponsorshipConnection;
};


/** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */
export type GQLSponsorsTierAdminInfoSponsorshipsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  includePrivate?: Maybe<Scalars['Boolean']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLSponsorshipOrder>;
};

/** The connection type for SponsorsTier. */
export type GQLSponsorsTierConnection = {
  __typename?: 'SponsorsTierConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLSponsorsTierEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLSponsorsTier>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLSponsorsTierEdge = {
  __typename?: 'SponsorsTierEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLSponsorsTier>;
};

/** Ordering options for Sponsors tiers connections. */
export type GQLSponsorsTierOrder = {
  /** The ordering direction. */
  direction: GQLOrderDirection;
  /** The field to order tiers by. */
  field: GQLSponsorsTierOrderField;
};

/** Properties by which Sponsors tiers connections can be ordered. */
export enum GQLSponsorsTierOrderField {
  /** Order tiers by creation time. */
  CreatedAt = 'CREATED_AT',
  /** Order tiers by their monthly price in cents */
  MonthlyPriceInCents = 'MONTHLY_PRICE_IN_CENTS'
}

/** A sponsorship relationship between a sponsor and a maintainer */
export type GQLSponsorship = GQLNode & {
  __typename?: 'Sponsorship';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /**
   * The entity that is being sponsored
   * @deprecated `Sponsorship.maintainer` will be removed. Use `Sponsorship.sponsorable` instead. Removal on 2020-04-01 UTC.
   */
  maintainer: GQLUser;
  /** The privacy level for this sponsorship. */
  privacyLevel: GQLSponsorshipPrivacy;
  /**
   * The user that is sponsoring. Returns null if the sponsorship is private or if sponsor is not a user.
   * @deprecated `Sponsorship.sponsor` will be removed. Use `Sponsorship.sponsorEntity` instead. Removal on 2020-10-01 UTC.
   */
  sponsor?: Maybe<GQLUser>;
  /** The user or organization that is sponsoring. Returns null if the sponsorship is private. */
  sponsorEntity?: Maybe<GQLSponsor>;
  /** The entity that is being sponsored */
  sponsorable: GQLSponsorable;
  /** The associated sponsorship tier */
  tier?: Maybe<GQLSponsorsTier>;
};

/** The connection type for Sponsorship. */
export type GQLSponsorshipConnection = {
  __typename?: 'SponsorshipConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLSponsorshipEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLSponsorship>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLSponsorshipEdge = {
  __typename?: 'SponsorshipEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLSponsorship>;
};

/** Ordering options for sponsorship connections. */
export type GQLSponsorshipOrder = {
  /** The ordering direction. */
  direction: GQLOrderDirection;
  /** The field to order sponsorship by. */
  field: GQLSponsorshipOrderField;
};

/** Properties by which sponsorship connections can be ordered. */
export enum GQLSponsorshipOrderField {
  /** Order sponsorship by creation time. */
  CreatedAt = 'CREATED_AT'
}

/** The privacy of a sponsorship */
export enum GQLSponsorshipPrivacy {
  /** Private */
  Private = 'PRIVATE',
  /** Public */
  Public = 'PUBLIC'
}

/** Ways in which star connections can be ordered. */
export type GQLStarOrder = {
  /** The direction in which to order nodes. */
  direction: GQLOrderDirection;
  /** The field in which to order nodes by. */
  field: GQLStarOrderField;
};

/** Properties by which star connections can be ordered. */
export enum GQLStarOrderField {
  /** Allows ordering a list of stars by when they were created. */
  StarredAt = 'STARRED_AT'
}

/** The connection type for User. */
export type GQLStargazerConnection = {
  __typename?: 'StargazerConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLStargazerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLUser>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a user that's starred a repository. */
export type GQLStargazerEdge = {
  __typename?: 'StargazerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  node: GQLUser;
  /** Identifies when the item was starred. */
  starredAt: Scalars['DateTime'];
};

/** Things that can be starred. */
export type GQLStarrable = {
  id: Scalars['ID'];
  /** A list of users who have starred this starrable. */
  stargazers: GQLStargazerConnection;
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean'];
};


/** Things that can be starred. */
export type GQLStarrableStargazersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLStarOrder>;
};

/** The connection type for Repository. */
export type GQLStarredRepositoryConnection = {
  __typename?: 'StarredRepositoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLStarredRepositoryEdge>>>;
  /** Is the list of stars for this user truncated? This is true for users that have many stars. */
  isOverLimit: Scalars['Boolean'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLRepository>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a starred repository. */
export type GQLStarredRepositoryEdge = {
  __typename?: 'StarredRepositoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  node: GQLRepository;
  /** Identifies when the item was starred. */
  starredAt: Scalars['DateTime'];
};

/** Represents a commit status. */
export type GQLStatus = GQLNode & {
  __typename?: 'Status';
  /** The commit this status is attached to. */
  commit?: Maybe<GQLCommit>;
  /** Looks up an individual status context by context name. */
  context?: Maybe<GQLStatusContext>;
  /** The individual status contexts for this commit. */
  contexts: Array<GQLStatusContext>;
  id: Scalars['ID'];
  /** The combined commit status. */
  state: GQLStatusState;
};


/** Represents a commit status. */
export type GQLStatusContextArgs = {
  name: Scalars['String'];
};

/** Represents the rollup for both the check runs and status for a commit. */
export type GQLStatusCheckRollup = GQLNode & {
  __typename?: 'StatusCheckRollup';
  /** The commit the status and check runs are attached to. */
  commit?: Maybe<GQLCommit>;
  /** A list of status contexts and check runs for this commit. */
  contexts: GQLStatusCheckRollupContextConnection;
  id: Scalars['ID'];
  /** The combined status for the commit. */
  state: GQLStatusState;
};


/** Represents the rollup for both the check runs and status for a commit. */
export type GQLStatusCheckRollupContextsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** Types that can be inside a StatusCheckRollup context. */
export type GQLStatusCheckRollupContext = GQLCheckRun | GQLStatusContext;

/** The connection type for StatusCheckRollupContext. */
export type GQLStatusCheckRollupContextConnection = {
  __typename?: 'StatusCheckRollupContextConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLStatusCheckRollupContextEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLStatusCheckRollupContext>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLStatusCheckRollupContextEdge = {
  __typename?: 'StatusCheckRollupContextEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLStatusCheckRollupContext>;
};

/** Represents an individual commit status context */
export type GQLStatusContext = GQLNode & {
  __typename?: 'StatusContext';
  /** The avatar of the OAuth application or the user that created the status */
  avatarUrl?: Maybe<Scalars['URI']>;
  /** This commit this status context is attached to. */
  commit?: Maybe<GQLCommit>;
  /** The name of this status context. */
  context: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The actor who created this status context. */
  creator?: Maybe<GQLActor>;
  /** The description for this status context. */
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The state of this status context. */
  state: GQLStatusState;
  /** The URL for this status context. */
  targetUrl?: Maybe<Scalars['URI']>;
};


/** Represents an individual commit status context */
export type GQLStatusContextAvatarUrlArgs = {
  size?: Maybe<Scalars['Int']>;
};

/** The possible commit status states. */
export enum GQLStatusState {
  /** Status is errored. */
  Error = 'ERROR',
  /** Status is expected. */
  Expected = 'EXPECTED',
  /** Status is failing. */
  Failure = 'FAILURE',
  /** Status is pending. */
  Pending = 'PENDING',
  /** Status is successful. */
  Success = 'SUCCESS'
}

/** Autogenerated input type of SubmitPullRequestReview */
export type GQLSubmitPullRequestReviewInput = {
  /** The text field to set on the Pull Request Review. */
  body?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The event to send to the Pull Request Review. */
  event: GQLPullRequestReviewEvent;
  /** The Pull Request ID to submit any pending reviews. */
  pullRequestId?: Maybe<Scalars['ID']>;
  /** The Pull Request Review ID to submit. */
  pullRequestReviewId?: Maybe<Scalars['ID']>;
};

/** Autogenerated return type of SubmitPullRequestReview */
export type GQLSubmitPullRequestReviewPayload = {
  __typename?: 'SubmitPullRequestReviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The submitted pull request review. */
  pullRequestReview?: Maybe<GQLPullRequestReview>;
};

/** A pointer to a repository at a specific revision embedded inside another repository. */
export type GQLSubmodule = {
  __typename?: 'Submodule';
  /** The branch of the upstream submodule for tracking updates */
  branch?: Maybe<Scalars['String']>;
  /** The git URL of the submodule repository */
  gitUrl: Scalars['URI'];
  /** The name of the submodule in .gitmodules */
  name: Scalars['String'];
  /** The path in the superproject that this submodule is located in */
  path: Scalars['String'];
  /** The commit revision of the subproject repository being tracked by the submodule */
  subprojectCommitOid?: Maybe<Scalars['GitObjectID']>;
};

/** The connection type for Submodule. */
export type GQLSubmoduleConnection = {
  __typename?: 'SubmoduleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLSubmoduleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLSubmodule>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLSubmoduleEdge = {
  __typename?: 'SubmoduleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLSubmodule>;
};

/** Entities that can be subscribed to for web and email notifications. */
export type GQLSubscribable = {
  id: Scalars['ID'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<GQLSubscriptionState>;
};

/** Represents a 'subscribed' event on a given `Subscribable`. */
export type GQLSubscribedEvent = GQLNode & {
  __typename?: 'SubscribedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Object referenced by event. */
  subscribable: GQLSubscribable;
};

/** The possible states of a subscription. */
export enum GQLSubscriptionState {
  /** The User is never notified. */
  Ignored = 'IGNORED',
  /** The User is notified of all conversations. */
  Subscribed = 'SUBSCRIBED',
  /** The User is only notified when participating or @mentioned. */
  Unsubscribed = 'UNSUBSCRIBED'
}

/** A suggestion to review a pull request based on a user's commit history and review comments. */
export type GQLSuggestedReviewer = {
  __typename?: 'SuggestedReviewer';
  /** Is this suggestion based on past commits? */
  isAuthor: Scalars['Boolean'];
  /** Is this suggestion based on past review comments? */
  isCommenter: Scalars['Boolean'];
  /** Identifies the user suggested to review the pull request. */
  reviewer: GQLUser;
};

/** Represents a Git tag. */
export type GQLTag = GQLGitObject & GQLNode & {
  __typename?: 'Tag';
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String'];
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['URI'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['URI'];
  id: Scalars['ID'];
  /** The Git tag message. */
  message?: Maybe<Scalars['String']>;
  /** The Git tag name. */
  name: Scalars['String'];
  /** The Git object ID */
  oid: Scalars['GitObjectID'];
  /** The Repository the Git object belongs to */
  repository: GQLRepository;
  /** Details about the tag author. */
  tagger?: Maybe<GQLGitActor>;
  /** The Git object the tag points to. */
  target: GQLGitObject;
};

/** A team of users in an organization. */
export type GQLTeam = GQLMemberStatusable & GQLNode & GQLSubscribable & {
  __typename?: 'Team';
  /** A list of teams that are ancestors of this team. */
  ancestors: GQLTeamConnection;
  /** A URL pointing to the team's avatar. */
  avatarUrl?: Maybe<Scalars['URI']>;
  /** List of child teams belonging to this team */
  childTeams: GQLTeamConnection;
  /** The slug corresponding to the organization and team. */
  combinedSlug: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The description of the team. */
  description?: Maybe<Scalars['String']>;
  /** Find a team discussion by its number. */
  discussion?: Maybe<GQLTeamDiscussion>;
  /** A list of team discussions. */
  discussions: GQLTeamDiscussionConnection;
  /** The HTTP path for team discussions */
  discussionsResourcePath: Scalars['URI'];
  /** The HTTP URL for team discussions */
  discussionsUrl: Scalars['URI'];
  /** The HTTP path for editing this team */
  editTeamResourcePath: Scalars['URI'];
  /** The HTTP URL for editing this team */
  editTeamUrl: Scalars['URI'];
  id: Scalars['ID'];
  /** A list of pending invitations for users to this team */
  invitations?: Maybe<GQLOrganizationInvitationConnection>;
  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
  memberStatuses: GQLUserStatusConnection;
  /** A list of users who are members of this team. */
  members: GQLTeamMemberConnection;
  /** The HTTP path for the team' members */
  membersResourcePath: Scalars['URI'];
  /** The HTTP URL for the team' members */
  membersUrl: Scalars['URI'];
  /** The name of the team. */
  name: Scalars['String'];
  /** The HTTP path creating a new team */
  newTeamResourcePath: Scalars['URI'];
  /** The HTTP URL creating a new team */
  newTeamUrl: Scalars['URI'];
  /** The organization that owns this team. */
  organization: GQLOrganization;
  /** The parent team of the team. */
  parentTeam?: Maybe<GQLTeam>;
  /** The level of privacy the team has. */
  privacy: GQLTeamPrivacy;
  /** A list of repositories this team has access to. */
  repositories: GQLTeamRepositoryConnection;
  /** The HTTP path for this team's repositories */
  repositoriesResourcePath: Scalars['URI'];
  /** The HTTP URL for this team's repositories */
  repositoriesUrl: Scalars['URI'];
  /** The HTTP path for this team */
  resourcePath: Scalars['URI'];
  /** What algorithm is used for review assignment for this team */
  reviewRequestDelegationAlgorithm?: Maybe<GQLTeamReviewAssignmentAlgorithm>;
  /** True if review assignment is enabled for this team */
  reviewRequestDelegationEnabled: Scalars['Boolean'];
  /** How many team members are required for review assignment for this team */
  reviewRequestDelegationMemberCount?: Maybe<Scalars['Int']>;
  /** When assigning team members via delegation, whether the entire team should be notified as well. */
  reviewRequestDelegationNotifyTeam: Scalars['Boolean'];
  /** The slug corresponding to the team. */
  slug: Scalars['String'];
  /** The HTTP path for this team's teams */
  teamsResourcePath: Scalars['URI'];
  /** The HTTP URL for this team's teams */
  teamsUrl: Scalars['URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this team */
  url: Scalars['URI'];
  /** Team is adminable by the viewer. */
  viewerCanAdminister: Scalars['Boolean'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<GQLSubscriptionState>;
};


/** A team of users in an organization. */
export type GQLTeamAncestorsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A team of users in an organization. */
export type GQLTeamAvatarUrlArgs = {
  size?: Maybe<Scalars['Int']>;
};


/** A team of users in an organization. */
export type GQLTeamChildTeamsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  immediateOnly?: Maybe<Scalars['Boolean']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLTeamOrder>;
  userLogins?: Maybe<Array<Scalars['String']>>;
};


/** A team of users in an organization. */
export type GQLTeamDiscussionArgs = {
  number: Scalars['Int'];
};


/** A team of users in an organization. */
export type GQLTeamDiscussionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  isPinned?: Maybe<Scalars['Boolean']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLTeamDiscussionOrder>;
};


/** A team of users in an organization. */
export type GQLTeamInvitationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A team of users in an organization. */
export type GQLTeamMemberStatusesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLUserStatusOrder>;
};


/** A team of users in an organization. */
export type GQLTeamMembersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  membership?: Maybe<GQLTeamMembershipType>;
  orderBy?: Maybe<GQLTeamMemberOrder>;
  query?: Maybe<Scalars['String']>;
  role?: Maybe<GQLTeamMemberRole>;
};


/** A team of users in an organization. */
export type GQLTeamRepositoriesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLTeamRepositoryOrder>;
  query?: Maybe<Scalars['String']>;
};

/** Audit log entry for a team.add_member event. */
export type GQLTeamAddMemberAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & GQLTeamAuditEntryData & {
  __typename?: 'TeamAddMemberAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The team associated with the action */
  team?: Maybe<GQLTeam>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a team.add_repository event. */
export type GQLTeamAddRepositoryAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & GQLRepositoryAuditEntryData & GQLTeamAuditEntryData & {
  __typename?: 'TeamAddRepositoryAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
  /** The team associated with the action */
  team?: Maybe<GQLTeam>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Metadata for an audit entry with action team.* */
export type GQLTeamAuditEntryData = {
  /** The team associated with the action */
  team?: Maybe<GQLTeam>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a team.change_parent_team event. */
export type GQLTeamChangeParentTeamAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & GQLTeamAuditEntryData & {
  __typename?: 'TeamChangeParentTeamAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The new parent team. */
  parentTeam?: Maybe<GQLTeam>;
  /** The name of the new parent team */
  parentTeamName?: Maybe<Scalars['String']>;
  /** The name of the former parent team */
  parentTeamNameWas?: Maybe<Scalars['String']>;
  /** The HTTP path for the parent team */
  parentTeamResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the parent team */
  parentTeamUrl?: Maybe<Scalars['URI']>;
  /** The former parent team. */
  parentTeamWas?: Maybe<GQLTeam>;
  /** The HTTP path for the previous parent team */
  parentTeamWasResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the previous parent team */
  parentTeamWasUrl?: Maybe<Scalars['URI']>;
  /** The team associated with the action */
  team?: Maybe<GQLTeam>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** The connection type for Team. */
export type GQLTeamConnection = {
  __typename?: 'TeamConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLTeamEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLTeam>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** A team discussion. */
export type GQLTeamDiscussion = GQLComment & GQLDeletable & GQLNode & GQLReactable & GQLSubscribable & GQLUniformResourceLocatable & GQLUpdatable & GQLUpdatableComment & {
  __typename?: 'TeamDiscussion';
  /** The actor who authored the comment. */
  author?: Maybe<GQLActor>;
  /** Author's association with the discussion's team. */
  authorAssociation: GQLCommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** Identifies the discussion body hash. */
  bodyVersion: Scalars['String'];
  /** A list of comments on this discussion. */
  comments: GQLTeamDiscussionCommentConnection;
  /** The HTTP path for discussion comments */
  commentsResourcePath: Scalars['URI'];
  /** The HTTP URL for discussion comments */
  commentsUrl: Scalars['URI'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The actor who edited the comment. */
  editor?: Maybe<GQLActor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** Whether or not the discussion is pinned. */
  isPinned: Scalars['Boolean'];
  /** Whether or not the discussion is only visible to team members and org admins. */
  isPrivate: Scalars['Boolean'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies the discussion within its team. */
  number: Scalars['Int'];
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<GQLReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: GQLReactionConnection;
  /** The HTTP path for this discussion */
  resourcePath: Scalars['URI'];
  /** The team that defines the context of this discussion. */
  team: GQLTeam;
  /** The title of the discussion */
  title: Scalars['String'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this discussion */
  url: Scalars['URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<GQLUserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Whether or not the current viewer can pin this discussion. */
  viewerCanPin: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<GQLCommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<GQLSubscriptionState>;
};


/** A team discussion. */
export type GQLTeamDiscussionCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  fromComment?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLTeamDiscussionCommentOrder>;
};


/** A team discussion. */
export type GQLTeamDiscussionReactionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  content?: Maybe<GQLReactionContent>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLReactionOrder>;
};


/** A team discussion. */
export type GQLTeamDiscussionUserContentEditsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** A comment on a team discussion. */
export type GQLTeamDiscussionComment = GQLComment & GQLDeletable & GQLNode & GQLReactable & GQLUniformResourceLocatable & GQLUpdatable & GQLUpdatableComment & {
  __typename?: 'TeamDiscussionComment';
  /** The actor who authored the comment. */
  author?: Maybe<GQLActor>;
  /** Author's association with the comment's team. */
  authorAssociation: GQLCommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** The current version of the body content. */
  bodyVersion: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The discussion this comment is about. */
  discussion: GQLTeamDiscussion;
  /** The actor who edited the comment. */
  editor?: Maybe<GQLActor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies the comment number. */
  number: Scalars['Int'];
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<GQLReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: GQLReactionConnection;
  /** The HTTP path for this comment */
  resourcePath: Scalars['URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this comment */
  url: Scalars['URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<GQLUserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<GQLCommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
};


/** A comment on a team discussion. */
export type GQLTeamDiscussionCommentReactionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  content?: Maybe<GQLReactionContent>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLReactionOrder>;
};


/** A comment on a team discussion. */
export type GQLTeamDiscussionCommentUserContentEditsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** The connection type for TeamDiscussionComment. */
export type GQLTeamDiscussionCommentConnection = {
  __typename?: 'TeamDiscussionCommentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLTeamDiscussionCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLTeamDiscussionComment>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLTeamDiscussionCommentEdge = {
  __typename?: 'TeamDiscussionCommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLTeamDiscussionComment>;
};

/** Ways in which team discussion comment connections can be ordered. */
export type GQLTeamDiscussionCommentOrder = {
  /** The direction in which to order nodes. */
  direction: GQLOrderDirection;
  /** The field by which to order nodes. */
  field: GQLTeamDiscussionCommentOrderField;
};

/** Properties by which team discussion comment connections can be ordered. */
export enum GQLTeamDiscussionCommentOrderField {
  /** Allows sequential ordering of team discussion comments (which is equivalent to chronological ordering). */
  Number = 'NUMBER'
}

/** The connection type for TeamDiscussion. */
export type GQLTeamDiscussionConnection = {
  __typename?: 'TeamDiscussionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLTeamDiscussionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLTeamDiscussion>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLTeamDiscussionEdge = {
  __typename?: 'TeamDiscussionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLTeamDiscussion>;
};

/** Ways in which team discussion connections can be ordered. */
export type GQLTeamDiscussionOrder = {
  /** The direction in which to order nodes. */
  direction: GQLOrderDirection;
  /** The field by which to order nodes. */
  field: GQLTeamDiscussionOrderField;
};

/** Properties by which team discussion connections can be ordered. */
export enum GQLTeamDiscussionOrderField {
  /** Allows chronological ordering of team discussions. */
  CreatedAt = 'CREATED_AT'
}

/** An edge in a connection. */
export type GQLTeamEdge = {
  __typename?: 'TeamEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLTeam>;
};

/** The connection type for User. */
export type GQLTeamMemberConnection = {
  __typename?: 'TeamMemberConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLTeamMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLUser>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a user who is a member of a team. */
export type GQLTeamMemberEdge = {
  __typename?: 'TeamMemberEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The HTTP path to the organization's member access page. */
  memberAccessResourcePath: Scalars['URI'];
  /** The HTTP URL to the organization's member access page. */
  memberAccessUrl: Scalars['URI'];
  node: GQLUser;
  /** The role the member has on the team. */
  role: GQLTeamMemberRole;
};

/** Ordering options for team member connections */
export type GQLTeamMemberOrder = {
  /** The ordering direction. */
  direction: GQLOrderDirection;
  /** The field to order team members by. */
  field: GQLTeamMemberOrderField;
};

/** Properties by which team member connections can be ordered. */
export enum GQLTeamMemberOrderField {
  /** Order team members by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order team members by login */
  Login = 'LOGIN'
}

/** The possible team member roles; either 'maintainer' or 'member'. */
export enum GQLTeamMemberRole {
  /** A team maintainer has permission to add and remove team members. */
  Maintainer = 'MAINTAINER',
  /** A team member has no administrative permissions on the team. */
  Member = 'MEMBER'
}

/** Defines which types of team members are included in the returned list. Can be one of IMMEDIATE, CHILD_TEAM or ALL. */
export enum GQLTeamMembershipType {
  /** Includes immediate and child team members for the team. */
  All = 'ALL',
  /** Includes only child team members for the team. */
  ChildTeam = 'CHILD_TEAM',
  /** Includes only immediate members of the team. */
  Immediate = 'IMMEDIATE'
}

/** Ways in which team connections can be ordered. */
export type GQLTeamOrder = {
  /** The direction in which to order nodes. */
  direction: GQLOrderDirection;
  /** The field in which to order nodes by. */
  field: GQLTeamOrderField;
};

/** Properties by which team connections can be ordered. */
export enum GQLTeamOrderField {
  /** Allows ordering a list of teams by name. */
  Name = 'NAME'
}

/** The possible team privacy values. */
export enum GQLTeamPrivacy {
  /** A secret team can only be seen by its members. */
  Secret = 'SECRET',
  /** A visible team can be seen and @mentioned by every member of the organization. */
  Visible = 'VISIBLE'
}

/** Audit log entry for a team.remove_member event. */
export type GQLTeamRemoveMemberAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & GQLTeamAuditEntryData & {
  __typename?: 'TeamRemoveMemberAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The team associated with the action */
  team?: Maybe<GQLTeam>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** Audit log entry for a team.remove_repository event. */
export type GQLTeamRemoveRepositoryAuditEntry = GQLAuditEntry & GQLNode & GQLOrganizationAuditEntryData & GQLRepositoryAuditEntryData & GQLTeamAuditEntryData & {
  __typename?: 'TeamRemoveRepositoryAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<GQLAuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<GQLActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['PreciseDateTime'];
  id: Scalars['ID'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<GQLOperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<GQLOrganization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['URI']>;
  /** The repository associated with the action */
  repository?: Maybe<GQLRepository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['URI']>;
  /** The team associated with the action */
  team?: Maybe<GQLTeam>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['URI']>;
  /** The user affected by the action */
  user?: Maybe<GQLUser>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['URI']>;
};

/** The connection type for Repository. */
export type GQLTeamRepositoryConnection = {
  __typename?: 'TeamRepositoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLTeamRepositoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLRepository>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a team repository. */
export type GQLTeamRepositoryEdge = {
  __typename?: 'TeamRepositoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  node: GQLRepository;
  /**
   * The permission level the team has on the repository
   * 
   * **Upcoming Change on 2020-10-01 UTC**
   * **Description:** Type for `permission` will change from `RepositoryPermission!` to `String`.
   * **Reason:** This field may return additional values
   */
  permission: GQLRepositoryPermission;
};

/** Ordering options for team repository connections */
export type GQLTeamRepositoryOrder = {
  /** The ordering direction. */
  direction: GQLOrderDirection;
  /** The field to order repositories by. */
  field: GQLTeamRepositoryOrderField;
};

/** Properties by which team repository connections can be ordered. */
export enum GQLTeamRepositoryOrderField {
  /** Order repositories by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order repositories by name */
  Name = 'NAME',
  /** Order repositories by permission */
  Permission = 'PERMISSION',
  /** Order repositories by push time */
  PushedAt = 'PUSHED_AT',
  /** Order repositories by number of stargazers */
  Stargazers = 'STARGAZERS',
  /** Order repositories by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** The possible team review assignment algorithms */
export enum GQLTeamReviewAssignmentAlgorithm {
  /** Balance review load across the entire team */
  LoadBalance = 'LOAD_BALANCE',
  /** Alternate reviews between each team member */
  RoundRobin = 'ROUND_ROBIN'
}

/** The role of a user on a team. */
export enum GQLTeamRole {
  /** User has admin rights on the team. */
  Admin = 'ADMIN',
  /** User is a member of the team. */
  Member = 'MEMBER'
}

/** A text match within a search result. */
export type GQLTextMatch = {
  __typename?: 'TextMatch';
  /** The specific text fragment within the property matched on. */
  fragment: Scalars['String'];
  /** Highlights within the matched fragment. */
  highlights: Array<GQLTextMatchHighlight>;
  /** The property matched on. */
  property: Scalars['String'];
};

/** Represents a single highlight in a search result match. */
export type GQLTextMatchHighlight = {
  __typename?: 'TextMatchHighlight';
  /** The indice in the fragment where the matched text begins. */
  beginIndice: Scalars['Int'];
  /** The indice in the fragment where the matched text ends. */
  endIndice: Scalars['Int'];
  /** The text matched. */
  text: Scalars['String'];
};

/** A topic aggregates entities that are related to a subject. */
export type GQLTopic = GQLNode & GQLStarrable & {
  __typename?: 'Topic';
  id: Scalars['ID'];
  /** The topic's name. */
  name: Scalars['String'];
  /**
   * A list of related topics, including aliases of this topic, sorted with the most relevant
   * first. Returns up to 10 Topics.
   */
  relatedTopics: Array<GQLTopic>;
  /** A list of users who have starred this starrable. */
  stargazers: GQLStargazerConnection;
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean'];
};


/** A topic aggregates entities that are related to a subject. */
export type GQLTopicRelatedTopicsArgs = {
  first?: Maybe<Scalars['Int']>;
};


/** A topic aggregates entities that are related to a subject. */
export type GQLTopicStargazersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLStarOrder>;
};

/** Metadata for an audit entry with a topic. */
export type GQLTopicAuditEntryData = {
  /** The name of the topic added to the repository */
  topic?: Maybe<GQLTopic>;
  /** The name of the topic added to the repository */
  topicName?: Maybe<Scalars['String']>;
};

/** The connection type for Topic. */
export type GQLTopicConnection = {
  __typename?: 'TopicConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLTopicEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLTopic>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLTopicEdge = {
  __typename?: 'TopicEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLTopic>;
};

/** Reason that the suggested topic is declined. */
export enum GQLTopicSuggestionDeclineReason {
  /** The suggested topic is not relevant to the repository. */
  NotRelevant = 'NOT_RELEVANT',
  /** The viewer does not like the suggested topic. */
  PersonalPreference = 'PERSONAL_PREFERENCE',
  /** The suggested topic is too general for the repository. */
  TooGeneral = 'TOO_GENERAL',
  /** The suggested topic is too specific for the repository (e.g. #ruby-on-rails-version-4-2-1). */
  TooSpecific = 'TOO_SPECIFIC'
}

/** Autogenerated input type of TransferIssue */
export type GQLTransferIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the issue to be transferred */
  issueId: Scalars['ID'];
  /** The Node ID of the repository the issue should be transferred to */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of TransferIssue */
export type GQLTransferIssuePayload = {
  __typename?: 'TransferIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The issue that was transferred */
  issue?: Maybe<GQLIssue>;
};

/** Represents a 'transferred' event on a given issue or pull request. */
export type GQLTransferredEvent = GQLNode & {
  __typename?: 'TransferredEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The repository this came from */
  fromRepository?: Maybe<GQLRepository>;
  id: Scalars['ID'];
  /** Identifies the issue associated with the event. */
  issue: GQLIssue;
};

/** Represents a Git tree. */
export type GQLTree = GQLGitObject & GQLNode & {
  __typename?: 'Tree';
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String'];
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['URI'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['URI'];
  /** A list of tree entries. */
  entries?: Maybe<Array<GQLTreeEntry>>;
  id: Scalars['ID'];
  /** The Git object ID */
  oid: Scalars['GitObjectID'];
  /** The Repository the Git object belongs to */
  repository: GQLRepository;
};

/** Represents a Git tree entry. */
export type GQLTreeEntry = {
  __typename?: 'TreeEntry';
  /** Entry file mode. */
  mode: Scalars['Int'];
  /** Entry file name. */
  name: Scalars['String'];
  /** Entry file object. */
  object?: Maybe<GQLGitObject>;
  /** Entry file Git object ID. */
  oid: Scalars['GitObjectID'];
  /** The Repository the tree entry belongs to */
  repository: GQLRepository;
  /** If the TreeEntry is for a directory occupied by a submodule project, this returns the corresponding submodule */
  submodule?: Maybe<GQLSubmodule>;
  /** Entry file type. */
  type: Scalars['String'];
};


/** Autogenerated input type of UnarchiveRepository */
export type GQLUnarchiveRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the repository to unarchive. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of UnarchiveRepository */
export type GQLUnarchiveRepositoryPayload = {
  __typename?: 'UnarchiveRepositoryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The repository that was unarchived. */
  repository?: Maybe<GQLRepository>;
};

/** Represents an 'unassigned' event on any assignable object. */
export type GQLUnassignedEvent = GQLNode & {
  __typename?: 'UnassignedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the assignable associated with the event. */
  assignable: GQLAssignable;
  /** Identifies the user or mannequin that was unassigned. */
  assignee?: Maybe<GQLAssignee>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /**
   * Identifies the subject (user) who was unassigned.
   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.
   */
  user?: Maybe<GQLUser>;
};

/** Autogenerated input type of UnfollowUser */
export type GQLUnfollowUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** ID of the user to unfollow. */
  userId: Scalars['ID'];
};

/** Autogenerated return type of UnfollowUser */
export type GQLUnfollowUserPayload = {
  __typename?: 'UnfollowUserPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The user that was unfollowed. */
  user?: Maybe<GQLUser>;
};

/** Represents a type that can be retrieved by a URL. */
export type GQLUniformResourceLocatable = {
  /** The HTML path to this resource. */
  resourcePath: Scalars['URI'];
  /** The URL to this resource. */
  url: Scalars['URI'];
};

/** Represents an unknown signature on a Commit or Tag. */
export type GQLUnknownSignature = GQLGitSignature & {
  __typename?: 'UnknownSignature';
  /** Email used to sign this object. */
  email: Scalars['String'];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean'];
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String'];
  /** ASCII-armored signature header from object. */
  signature: Scalars['String'];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<GQLUser>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: GQLGitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean'];
};

/** Represents an 'unlabeled' event on a given issue or pull request. */
export type GQLUnlabeledEvent = GQLNode & {
  __typename?: 'UnlabeledEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Identifies the label associated with the 'unlabeled' event. */
  label: GQLLabel;
  /** Identifies the `Labelable` associated with the event. */
  labelable: GQLLabelable;
};

/** Autogenerated input type of UnlinkRepositoryFromProject */
export type GQLUnlinkRepositoryFromProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the Project linked to the Repository. */
  projectId: Scalars['ID'];
  /** The ID of the Repository linked to the Project. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of UnlinkRepositoryFromProject */
export type GQLUnlinkRepositoryFromProjectPayload = {
  __typename?: 'UnlinkRepositoryFromProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The linked Project. */
  project?: Maybe<GQLProject>;
  /** The linked Repository. */
  repository?: Maybe<GQLRepository>;
};

/** Autogenerated input type of UnlockLockable */
export type GQLUnlockLockableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** ID of the issue or pull request to be unlocked. */
  lockableId: Scalars['ID'];
};

/** Autogenerated return type of UnlockLockable */
export type GQLUnlockLockablePayload = {
  __typename?: 'UnlockLockablePayload';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The item that was unlocked. */
  unlockedRecord?: Maybe<GQLLockable>;
};

/** Represents an 'unlocked' event on a given issue or pull request. */
export type GQLUnlockedEvent = GQLNode & {
  __typename?: 'UnlockedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Object that was unlocked. */
  lockable: GQLLockable;
};

/** Autogenerated input type of UnmarkIssueAsDuplicate */
export type GQLUnmarkIssueAsDuplicateInput = {
  /** ID of the issue or pull request currently considered canonical/authoritative/original. */
  canonicalId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** ID of the issue or pull request currently marked as a duplicate. */
  duplicateId: Scalars['ID'];
};

/** Autogenerated return type of UnmarkIssueAsDuplicate */
export type GQLUnmarkIssueAsDuplicatePayload = {
  __typename?: 'UnmarkIssueAsDuplicatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The issue or pull request that was marked as a duplicate. */
  duplicate?: Maybe<GQLIssueOrPullRequest>;
};

/** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
export type GQLUnmarkedAsDuplicateEvent = GQLNode & {
  __typename?: 'UnmarkedAsDuplicateEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
};

/** Autogenerated input type of UnminimizeComment */
export type GQLUnminimizeCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'];
};

/** Autogenerated return type of UnminimizeComment */
export type GQLUnminimizeCommentPayload = {
  __typename?: 'UnminimizeCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The comment that was unminimized. */
  unminimizedComment?: Maybe<GQLMinimizable>;
};

/** Autogenerated input type of UnpinIssue */
export type GQLUnpinIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the issue to be unpinned */
  issueId: Scalars['ID'];
};

/** Autogenerated return type of UnpinIssue */
export type GQLUnpinIssuePayload = {
  __typename?: 'UnpinIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The issue that was unpinned */
  issue?: Maybe<GQLIssue>;
};

/** Represents an 'unpinned' event on a given issue or pull request. */
export type GQLUnpinnedEvent = GQLNode & {
  __typename?: 'UnpinnedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Identifies the issue associated with the event. */
  issue: GQLIssue;
};

/** Autogenerated input type of UnresolveReviewThread */
export type GQLUnresolveReviewThreadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the thread to unresolve */
  threadId: Scalars['ID'];
};

/** Autogenerated return type of UnresolveReviewThread */
export type GQLUnresolveReviewThreadPayload = {
  __typename?: 'UnresolveReviewThreadPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The thread to resolve. */
  thread?: Maybe<GQLPullRequestReviewThread>;
};

/** Represents an 'unsubscribed' event on a given `Subscribable`. */
export type GQLUnsubscribedEvent = GQLNode & {
  __typename?: 'UnsubscribedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Object referenced by event. */
  subscribable: GQLSubscribable;
};

/** Entities that can be updated. */
export type GQLUpdatable = {
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
};

/** Comments that can be updated. */
export type GQLUpdatableComment = {
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<GQLCommentCannotUpdateReason>;
};

/** Autogenerated input type of UpdateBranchProtectionRule */
export type GQLUpdateBranchProtectionRuleInput = {
  /** The global relay id of the branch protection rule to be updated. */
  branchProtectionRuleId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews?: Maybe<Scalars['Boolean']>;
  /** Can admins overwrite branch protection. */
  isAdminEnforced?: Maybe<Scalars['Boolean']>;
  /** The glob-like pattern used to determine matching branches. */
  pattern?: Maybe<Scalars['String']>;
  /** A list of User, Team or App IDs allowed to push to matching branches. */
  pushActorIds?: Maybe<Array<Scalars['ID']>>;
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: Maybe<Scalars['Int']>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: Maybe<Array<Scalars['String']>>;
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews?: Maybe<Scalars['Boolean']>;
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews?: Maybe<Scalars['Boolean']>;
  /** Are commits required to be signed. */
  requiresCommitSignatures?: Maybe<Scalars['Boolean']>;
  /** Are status checks required to update matching branches. */
  requiresStatusChecks?: Maybe<Scalars['Boolean']>;
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks?: Maybe<Scalars['Boolean']>;
  /** Is pushing to matching branches restricted. */
  restrictsPushes?: Maybe<Scalars['Boolean']>;
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals?: Maybe<Scalars['Boolean']>;
  /** A list of User or Team IDs allowed to dismiss reviews on pull requests targeting matching branches. */
  reviewDismissalActorIds?: Maybe<Array<Scalars['ID']>>;
};

/** Autogenerated return type of UpdateBranchProtectionRule */
export type GQLUpdateBranchProtectionRulePayload = {
  __typename?: 'UpdateBranchProtectionRulePayload';
  /** The newly created BranchProtectionRule. */
  branchProtectionRule?: Maybe<GQLBranchProtectionRule>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateCheckRun */
export type GQLUpdateCheckRunInput = {
  /** Possible further actions the integrator can perform, which a user may trigger. */
  actions?: Maybe<Array<GQLCheckRunAction>>;
  /** The node of the check. */
  checkRunId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The time that the check run finished. */
  completedAt?: Maybe<Scalars['DateTime']>;
  /** The final conclusion of the check. */
  conclusion?: Maybe<GQLCheckConclusionState>;
  /** The URL of the integrator's site that has the full details of the check. */
  detailsUrl?: Maybe<Scalars['URI']>;
  /** A reference for the run on the integrator's system. */
  externalId?: Maybe<Scalars['String']>;
  /** The name of the check. */
  name?: Maybe<Scalars['String']>;
  /** Descriptive details about the run. */
  output?: Maybe<GQLCheckRunOutput>;
  /** The node ID of the repository. */
  repositoryId: Scalars['ID'];
  /** The time that the check run began. */
  startedAt?: Maybe<Scalars['DateTime']>;
  /** The current status. */
  status?: Maybe<GQLRequestableCheckStatusState>;
};

/** Autogenerated return type of UpdateCheckRun */
export type GQLUpdateCheckRunPayload = {
  __typename?: 'UpdateCheckRunPayload';
  /** The updated check run. */
  checkRun?: Maybe<GQLCheckRun>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateCheckSuitePreferences */
export type GQLUpdateCheckSuitePreferencesInput = {
  /** The check suite preferences to modify. */
  autoTriggerPreferences: Array<GQLCheckSuiteAutoTriggerPreference>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of UpdateCheckSuitePreferences */
export type GQLUpdateCheckSuitePreferencesPayload = {
  __typename?: 'UpdateCheckSuitePreferencesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated repository. */
  repository?: Maybe<GQLRepository>;
};

/** Autogenerated input type of UpdateEnterpriseActionExecutionCapabilitySetting */
export type GQLUpdateEnterpriseActionExecutionCapabilitySettingInput = {
  /** The value for the action execution capability setting on the enterprise. */
  capability: GQLActionExecutionCapabilitySetting;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can create repositories setting. */
  enterpriseId: Scalars['ID'];
};

/** Autogenerated return type of UpdateEnterpriseActionExecutionCapabilitySetting */
export type GQLUpdateEnterpriseActionExecutionCapabilitySettingPayload = {
  __typename?: 'UpdateEnterpriseActionExecutionCapabilitySettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated action execution capability setting. */
  enterprise?: Maybe<GQLEnterprise>;
  /** A message confirming the result of updating the action execution capability setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseAdministratorRole */
export type GQLUpdateEnterpriseAdministratorRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the Enterprise which the admin belongs to. */
  enterpriseId: Scalars['ID'];
  /** The login of a administrator whose role is being changed. */
  login: Scalars['String'];
  /** The new role for the Enterprise administrator. */
  role: GQLEnterpriseAdministratorRole;
};

/** Autogenerated return type of UpdateEnterpriseAdministratorRole */
export type GQLUpdateEnterpriseAdministratorRolePayload = {
  __typename?: 'UpdateEnterpriseAdministratorRolePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A message confirming the result of changing the administrator's role. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */
export type GQLUpdateEnterpriseAllowPrivateRepositoryForkingSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the allow private repository forking setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the allow private repository forking setting on the enterprise. */
  settingValue: GQLEnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */
export type GQLUpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload = {
  __typename?: 'UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated allow private repository forking setting. */
  enterprise?: Maybe<GQLEnterprise>;
  /** A message confirming the result of updating the allow private repository forking setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseDefaultRepositoryPermissionSetting */
export type GQLUpdateEnterpriseDefaultRepositoryPermissionSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the default repository permission setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the default repository permission setting on the enterprise. */
  settingValue: GQLEnterpriseDefaultRepositoryPermissionSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseDefaultRepositoryPermissionSetting */
export type GQLUpdateEnterpriseDefaultRepositoryPermissionSettingPayload = {
  __typename?: 'UpdateEnterpriseDefaultRepositoryPermissionSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated default repository permission setting. */
  enterprise?: Maybe<GQLEnterprise>;
  /** A message confirming the result of updating the default repository permission setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */
export type GQLUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can change repository visibility setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can change repository visibility setting on the enterprise. */
  settingValue: GQLEnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */
export type GQLUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload = {
  __typename?: 'UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated members can change repository visibility setting. */
  enterprise?: Maybe<GQLEnterprise>;
  /** A message confirming the result of updating the members can change repository visibility setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */
export type GQLUpdateEnterpriseMembersCanCreateRepositoriesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can create repositories setting. */
  enterpriseId: Scalars['ID'];
  /** Allow members to create internal repositories. Defaults to current value. */
  membersCanCreateInternalRepositories?: Maybe<Scalars['Boolean']>;
  /** Allow members to create private repositories. Defaults to current value. */
  membersCanCreatePrivateRepositories?: Maybe<Scalars['Boolean']>;
  /** Allow members to create public repositories. Defaults to current value. */
  membersCanCreatePublicRepositories?: Maybe<Scalars['Boolean']>;
  /** When false, allow member organizations to set their own repository creation member privileges. */
  membersCanCreateRepositoriesPolicyEnabled?: Maybe<Scalars['Boolean']>;
  /**
   * Value for the members can create repositories setting on the enterprise. This
   * or the granular public/private/internal allowed fields (but not both) must be provided.
   */
  settingValue?: Maybe<GQLEnterpriseMembersCanCreateRepositoriesSettingValue>;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */
export type GQLUpdateEnterpriseMembersCanCreateRepositoriesSettingPayload = {
  __typename?: 'UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated members can create repositories setting. */
  enterprise?: Maybe<GQLEnterprise>;
  /** A message confirming the result of updating the members can create repositories setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteIssuesSetting */
export type GQLUpdateEnterpriseMembersCanDeleteIssuesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can delete issues setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can delete issues setting on the enterprise. */
  settingValue: GQLEnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanDeleteIssuesSetting */
export type GQLUpdateEnterpriseMembersCanDeleteIssuesSettingPayload = {
  __typename?: 'UpdateEnterpriseMembersCanDeleteIssuesSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated members can delete issues setting. */
  enterprise?: Maybe<GQLEnterprise>;
  /** A message confirming the result of updating the members can delete issues setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */
export type GQLUpdateEnterpriseMembersCanDeleteRepositoriesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can delete repositories setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can delete repositories setting on the enterprise. */
  settingValue: GQLEnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */
export type GQLUpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload = {
  __typename?: 'UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated members can delete repositories setting. */
  enterprise?: Maybe<GQLEnterprise>;
  /** A message confirming the result of updating the members can delete repositories setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */
export type GQLUpdateEnterpriseMembersCanInviteCollaboratorsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can invite collaborators setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can invite collaborators setting on the enterprise. */
  settingValue: GQLEnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */
export type GQLUpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload = {
  __typename?: 'UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated members can invite collaborators setting. */
  enterprise?: Maybe<GQLEnterprise>;
  /** A message confirming the result of updating the members can invite collaborators setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanMakePurchasesSetting */
export type GQLUpdateEnterpriseMembersCanMakePurchasesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can make purchases setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can make purchases setting on the enterprise. */
  settingValue: GQLEnterpriseMembersCanMakePurchasesSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanMakePurchasesSetting */
export type GQLUpdateEnterpriseMembersCanMakePurchasesSettingPayload = {
  __typename?: 'UpdateEnterpriseMembersCanMakePurchasesSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated members can make purchases setting. */
  enterprise?: Maybe<GQLEnterprise>;
  /** A message confirming the result of updating the members can make purchases setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */
export type GQLUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can update protected branches setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can update protected branches setting on the enterprise. */
  settingValue: GQLEnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */
export type GQLUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload = {
  __typename?: 'UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated members can update protected branches setting. */
  enterprise?: Maybe<GQLEnterprise>;
  /** A message confirming the result of updating the members can update protected branches setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */
export type GQLUpdateEnterpriseMembersCanViewDependencyInsightsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can view dependency insights setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can view dependency insights setting on the enterprise. */
  settingValue: GQLEnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */
export type GQLUpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload = {
  __typename?: 'UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated members can view dependency insights setting. */
  enterprise?: Maybe<GQLEnterprise>;
  /** A message confirming the result of updating the members can view dependency insights setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseOrganizationProjectsSetting */
export type GQLUpdateEnterpriseOrganizationProjectsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the organization projects setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the organization projects setting on the enterprise. */
  settingValue: GQLEnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseOrganizationProjectsSetting */
export type GQLUpdateEnterpriseOrganizationProjectsSettingPayload = {
  __typename?: 'UpdateEnterpriseOrganizationProjectsSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated organization projects setting. */
  enterprise?: Maybe<GQLEnterprise>;
  /** A message confirming the result of updating the organization projects setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseProfile */
export type GQLUpdateEnterpriseProfileInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The description of the enterprise. */
  description?: Maybe<Scalars['String']>;
  /** The Enterprise ID to update. */
  enterpriseId: Scalars['ID'];
  /** The location of the enterprise. */
  location?: Maybe<Scalars['String']>;
  /** The name of the enterprise. */
  name?: Maybe<Scalars['String']>;
  /** The URL of the enterprise's website. */
  websiteUrl?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateEnterpriseProfile */
export type GQLUpdateEnterpriseProfilePayload = {
  __typename?: 'UpdateEnterpriseProfilePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated enterprise. */
  enterprise?: Maybe<GQLEnterprise>;
};

/** Autogenerated input type of UpdateEnterpriseRepositoryProjectsSetting */
export type GQLUpdateEnterpriseRepositoryProjectsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the repository projects setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the repository projects setting on the enterprise. */
  settingValue: GQLEnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseRepositoryProjectsSetting */
export type GQLUpdateEnterpriseRepositoryProjectsSettingPayload = {
  __typename?: 'UpdateEnterpriseRepositoryProjectsSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated repository projects setting. */
  enterprise?: Maybe<GQLEnterprise>;
  /** A message confirming the result of updating the repository projects setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseTeamDiscussionsSetting */
export type GQLUpdateEnterpriseTeamDiscussionsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the team discussions setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the team discussions setting on the enterprise. */
  settingValue: GQLEnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseTeamDiscussionsSetting */
export type GQLUpdateEnterpriseTeamDiscussionsSettingPayload = {
  __typename?: 'UpdateEnterpriseTeamDiscussionsSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated team discussions setting. */
  enterprise?: Maybe<GQLEnterprise>;
  /** A message confirming the result of updating the team discussions setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */
export type GQLUpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the two factor authentication required setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the two factor authentication required setting on the enterprise. */
  settingValue: GQLEnterpriseEnabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */
export type GQLUpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload = {
  __typename?: 'UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated two factor authentication required setting. */
  enterprise?: Maybe<GQLEnterprise>;
  /** A message confirming the result of updating the two factor authentication required setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateIpAllowListEnabledSetting */
export type GQLUpdateIpAllowListEnabledSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the owner on which to set the IP allow list enabled setting. */
  ownerId: Scalars['ID'];
  /** The value for the IP allow list enabled setting. */
  settingValue: GQLIpAllowListEnabledSettingValue;
};

/** Autogenerated return type of UpdateIpAllowListEnabledSetting */
export type GQLUpdateIpAllowListEnabledSettingPayload = {
  __typename?: 'UpdateIpAllowListEnabledSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The IP allow list owner on which the setting was updated. */
  owner?: Maybe<GQLIpAllowListOwner>;
};

/** Autogenerated input type of UpdateIpAllowListEntry */
export type GQLUpdateIpAllowListEntryInput = {
  /** An IP address or range of addresses in CIDR notation. */
  allowListValue: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the IP allow list entry to update. */
  ipAllowListEntryId: Scalars['ID'];
  /** Whether the IP allow list entry is active when an IP allow list is enabled. */
  isActive: Scalars['Boolean'];
  /** An optional name for the IP allow list entry. */
  name?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateIpAllowListEntry */
export type GQLUpdateIpAllowListEntryPayload = {
  __typename?: 'UpdateIpAllowListEntryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The IP allow list entry that was updated. */
  ipAllowListEntry?: Maybe<GQLIpAllowListEntry>;
};

/** Autogenerated input type of UpdateIssueComment */
export type GQLUpdateIssueCommentInput = {
  /** The updated text of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the IssueComment to modify. */
  id: Scalars['ID'];
};

/** Autogenerated return type of UpdateIssueComment */
export type GQLUpdateIssueCommentPayload = {
  __typename?: 'UpdateIssueCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated comment. */
  issueComment?: Maybe<GQLIssueComment>;
};

/** Autogenerated input type of UpdateIssue */
export type GQLUpdateIssueInput = {
  /** An array of Node IDs of users for this issue. */
  assigneeIds?: Maybe<Array<Scalars['ID']>>;
  /** The body for the issue description. */
  body?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the Issue to modify. */
  id: Scalars['ID'];
  /** An array of Node IDs of labels for this issue. */
  labelIds?: Maybe<Array<Scalars['ID']>>;
  /** The Node ID of the milestone for this issue. */
  milestoneId?: Maybe<Scalars['ID']>;
  /** An array of Node IDs for projects associated with this issue. */
  projectIds?: Maybe<Array<Scalars['ID']>>;
  /** The desired issue state. */
  state?: Maybe<GQLIssueState>;
  /** The title for the issue. */
  title?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateIssue */
export type GQLUpdateIssuePayload = {
  __typename?: 'UpdateIssuePayload';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The issue. */
  issue?: Maybe<GQLIssue>;
};

/** Autogenerated input type of UpdateLabel */
export type GQLUpdateLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A 6 character hex code, without the leading #, identifying the updated color of the label. */
  color?: Maybe<Scalars['String']>;
  /** A brief description of the label, such as its purpose. */
  description?: Maybe<Scalars['String']>;
  /** The Node ID of the label to be updated. */
  id: Scalars['ID'];
  /** The updated name of the label. */
  name?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateLabel */
export type GQLUpdateLabelPayload = {
  __typename?: 'UpdateLabelPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated label. */
  label?: Maybe<GQLLabel>;
};

/** Autogenerated input type of UpdateProjectCard */
export type GQLUpdateProjectCardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Whether or not the ProjectCard should be archived */
  isArchived?: Maybe<Scalars['Boolean']>;
  /** The note of ProjectCard. */
  note?: Maybe<Scalars['String']>;
  /** The ProjectCard ID to update. */
  projectCardId: Scalars['ID'];
};

/** Autogenerated return type of UpdateProjectCard */
export type GQLUpdateProjectCardPayload = {
  __typename?: 'UpdateProjectCardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated ProjectCard. */
  projectCard?: Maybe<GQLProjectCard>;
};

/** Autogenerated input type of UpdateProjectColumn */
export type GQLUpdateProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The name of project column. */
  name: Scalars['String'];
  /** The ProjectColumn ID to update. */
  projectColumnId: Scalars['ID'];
};

/** Autogenerated return type of UpdateProjectColumn */
export type GQLUpdateProjectColumnPayload = {
  __typename?: 'UpdateProjectColumnPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated project column. */
  projectColumn?: Maybe<GQLProjectColumn>;
};

/** Autogenerated input type of UpdateProject */
export type GQLUpdateProjectInput = {
  /** The description of project. */
  body?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The name of project. */
  name?: Maybe<Scalars['String']>;
  /** The Project ID to update. */
  projectId: Scalars['ID'];
  /** Whether the project is public or not. */
  public?: Maybe<Scalars['Boolean']>;
  /** Whether the project is open or closed. */
  state?: Maybe<GQLProjectState>;
};

/** Autogenerated return type of UpdateProject */
export type GQLUpdateProjectPayload = {
  __typename?: 'UpdateProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated project. */
  project?: Maybe<GQLProject>;
};

/** Autogenerated input type of UpdatePullRequest */
export type GQLUpdatePullRequestInput = {
  /** An array of Node IDs of users for this pull request. */
  assigneeIds?: Maybe<Array<Scalars['ID']>>;
  /**
   * The name of the branch you want your changes pulled into. This should be an existing branch
   * on the current repository.
   */
  baseRefName?: Maybe<Scalars['String']>;
  /** The contents of the pull request. */
  body?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An array of Node IDs of labels for this pull request. */
  labelIds?: Maybe<Array<Scalars['ID']>>;
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify?: Maybe<Scalars['Boolean']>;
  /** The Node ID of the milestone for this pull request. */
  milestoneId?: Maybe<Scalars['ID']>;
  /** An array of Node IDs for projects associated with this pull request. */
  projectIds?: Maybe<Array<Scalars['ID']>>;
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID'];
  /** The target state of the pull request. */
  state?: Maybe<GQLPullRequestUpdateState>;
  /** The title of the pull request. */
  title?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdatePullRequest */
export type GQLUpdatePullRequestPayload = {
  __typename?: 'UpdatePullRequestPayload';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated pull request. */
  pullRequest?: Maybe<GQLPullRequest>;
};

/** Autogenerated input type of UpdatePullRequestReviewComment */
export type GQLUpdatePullRequestReviewCommentInput = {
  /** The text of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the comment to modify. */
  pullRequestReviewCommentId: Scalars['ID'];
};

/** Autogenerated return type of UpdatePullRequestReviewComment */
export type GQLUpdatePullRequestReviewCommentPayload = {
  __typename?: 'UpdatePullRequestReviewCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated comment. */
  pullRequestReviewComment?: Maybe<GQLPullRequestReviewComment>;
};

/** Autogenerated input type of UpdatePullRequestReview */
export type GQLUpdatePullRequestReviewInput = {
  /** The contents of the pull request review body. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the pull request review to modify. */
  pullRequestReviewId: Scalars['ID'];
};

/** Autogenerated return type of UpdatePullRequestReview */
export type GQLUpdatePullRequestReviewPayload = {
  __typename?: 'UpdatePullRequestReviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated pull request review. */
  pullRequestReview?: Maybe<GQLPullRequestReview>;
};

/** Autogenerated input type of UpdateRef */
export type GQLUpdateRefInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Permit updates of branch Refs that are not fast-forwards? */
  force?: Maybe<Scalars['Boolean']>;
  /** The GitObjectID that the Ref shall be updated to target. */
  oid: Scalars['GitObjectID'];
  /** The Node ID of the Ref to be updated. */
  refId: Scalars['ID'];
};

/** Autogenerated return type of UpdateRef */
export type GQLUpdateRefPayload = {
  __typename?: 'UpdateRefPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated Ref. */
  ref?: Maybe<GQLRef>;
};

/** Autogenerated input type of UpdateRefs */
export type GQLUpdateRefsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A list of ref updates. */
  refUpdates: Array<GQLRefUpdate>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of UpdateRefs */
export type GQLUpdateRefsPayload = {
  __typename?: 'UpdateRefsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateRepository */
export type GQLUpdateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A new description for the repository. Pass an empty string to erase the existing description. */
  description?: Maybe<Scalars['String']>;
  /** Indicates if the repository should have the issues feature enabled. */
  hasIssuesEnabled?: Maybe<Scalars['Boolean']>;
  /** Indicates if the repository should have the project boards feature enabled. */
  hasProjectsEnabled?: Maybe<Scalars['Boolean']>;
  /** Indicates if the repository should have the wiki feature enabled. */
  hasWikiEnabled?: Maybe<Scalars['Boolean']>;
  /** The URL for a web page about this repository. Pass an empty string to erase the existing URL. */
  homepageUrl?: Maybe<Scalars['URI']>;
  /** The new name of the repository. */
  name?: Maybe<Scalars['String']>;
  /** The ID of the repository to update. */
  repositoryId: Scalars['ID'];
  /**
   * Whether this repository should be marked as a template such that anyone who
   * can access it can create new repositories with the same files and directory structure.
   */
  template?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated return type of UpdateRepository */
export type GQLUpdateRepositoryPayload = {
  __typename?: 'UpdateRepositoryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated repository. */
  repository?: Maybe<GQLRepository>;
};

/** Autogenerated input type of UpdateSubscription */
export type GQLUpdateSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new state of the subscription. */
  state: GQLSubscriptionState;
  /** The Node ID of the subscribable object to modify. */
  subscribableId: Scalars['ID'];
};

/** Autogenerated return type of UpdateSubscription */
export type GQLUpdateSubscriptionPayload = {
  __typename?: 'UpdateSubscriptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The input subscribable entity. */
  subscribable?: Maybe<GQLSubscribable>;
};

/** Autogenerated input type of UpdateTeamDiscussionComment */
export type GQLUpdateTeamDiscussionCommentInput = {
  /** The updated text of the comment. */
  body: Scalars['String'];
  /** The current version of the body content. */
  bodyVersion?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the comment to modify. */
  id: Scalars['ID'];
};

/** Autogenerated return type of UpdateTeamDiscussionComment */
export type GQLUpdateTeamDiscussionCommentPayload = {
  __typename?: 'UpdateTeamDiscussionCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated comment. */
  teamDiscussionComment?: Maybe<GQLTeamDiscussionComment>;
};

/** Autogenerated input type of UpdateTeamDiscussion */
export type GQLUpdateTeamDiscussionInput = {
  /** The updated text of the discussion. */
  body?: Maybe<Scalars['String']>;
  /**
   * The current version of the body content. If provided, this update operation
   * will be rejected if the given version does not match the latest version on the server.
   */
  bodyVersion?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the discussion to modify. */
  id: Scalars['ID'];
  /** If provided, sets the pinned state of the updated discussion. */
  pinned?: Maybe<Scalars['Boolean']>;
  /** The updated title of the discussion. */
  title?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateTeamDiscussion */
export type GQLUpdateTeamDiscussionPayload = {
  __typename?: 'UpdateTeamDiscussionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated discussion. */
  teamDiscussion?: Maybe<GQLTeamDiscussion>;
};

/** Autogenerated input type of UpdateTeamReviewAssignment */
export type GQLUpdateTeamReviewAssignmentInput = {
  /** The algorithm to use for review assignment */
  algorithm?: Maybe<GQLTeamReviewAssignmentAlgorithm>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Turn on or off review assignment */
  enabled: Scalars['Boolean'];
  /** An array of team member IDs to exclude */
  excludedTeamMemberIds?: Maybe<Array<Scalars['ID']>>;
  /** The Node ID of the team to update review assginments of */
  id: Scalars['ID'];
  /** Notify the entire team of the PR if it is delegated */
  notifyTeam?: Maybe<Scalars['Boolean']>;
  /** The number of team members to assign */
  teamMemberCount?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of UpdateTeamReviewAssignment */
export type GQLUpdateTeamReviewAssignmentPayload = {
  __typename?: 'UpdateTeamReviewAssignmentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The team that was modified */
  team?: Maybe<GQLTeam>;
};

/** Autogenerated input type of UpdateTopics */
export type GQLUpdateTopicsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
  /** An array of topic names. */
  topicNames: Array<Scalars['String']>;
};

/** Autogenerated return type of UpdateTopics */
export type GQLUpdateTopicsPayload = {
  __typename?: 'UpdateTopicsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Names of the provided topics that are not valid. */
  invalidTopicNames?: Maybe<Array<Scalars['String']>>;
  /** The updated repository. */
  repository?: Maybe<GQLRepository>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUser = GQLActor & GQLNode & GQLPackageOwner & GQLProfileOwner & GQLProjectOwner & GQLRegistryPackageOwner & GQLRegistryPackageSearch & GQLRepositoryOwner & GQLSponsorable & GQLUniformResourceLocatable & {
  __typename?: 'User';
  /** Determine if this repository owner has any items that can be pinned to their profile. */
  anyPinnableItems: Scalars['Boolean'];
  /** A URL pointing to the user's public avatar. */
  avatarUrl: Scalars['URI'];
  /** The user's public profile bio. */
  bio?: Maybe<Scalars['String']>;
  /** The user's public profile bio as HTML. */
  bioHTML: Scalars['HTML'];
  /** A list of commit comments made by this user. */
  commitComments: GQLCommitCommentConnection;
  /** The user's public profile company. */
  company?: Maybe<Scalars['String']>;
  /** The user's public profile company as HTML. */
  companyHTML: Scalars['HTML'];
  /** The collection of contributions this user has made to different repositories. */
  contributionsCollection: GQLContributionsCollection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The user's publicly visible profile email. */
  email: Scalars['String'];
  /** A list of users the given user is followed by. */
  followers: GQLFollowerConnection;
  /** A list of users the given user is following. */
  following: GQLFollowingConnection;
  /** Find gist by repo name. */
  gist?: Maybe<GQLGist>;
  /** A list of gist comments made by this user. */
  gistComments: GQLGistCommentConnection;
  /** A list of the Gists the user has created. */
  gists: GQLGistConnection;
  /** The hovercard information for this user in a given context */
  hovercard: GQLHovercard;
  id: Scalars['ID'];
  /** Whether or not this user is a participant in the GitHub Security Bug Bounty. */
  isBountyHunter: Scalars['Boolean'];
  /** Whether or not this user is a participant in the GitHub Campus Experts Program. */
  isCampusExpert: Scalars['Boolean'];
  /** Whether or not this user is a GitHub Developer Program member. */
  isDeveloperProgramMember: Scalars['Boolean'];
  /** Whether or not this user is a GitHub employee. */
  isEmployee: Scalars['Boolean'];
  /** Whether or not the user has marked themselves as for hire. */
  isHireable: Scalars['Boolean'];
  /** Whether or not this user is a site administrator. */
  isSiteAdmin: Scalars['Boolean'];
  /** Whether or not this user is the viewing user. */
  isViewer: Scalars['Boolean'];
  /** A list of issue comments made by this user. */
  issueComments: GQLIssueCommentConnection;
  /** A list of issues associated with this user. */
  issues: GQLIssueConnection;
  /**
   * Showcases a selection of repositories and gists that the profile owner has
   * either curated or that have been selected automatically based on popularity.
   */
  itemShowcase: GQLProfileItemShowcase;
  /** The user's public profile location. */
  location?: Maybe<Scalars['String']>;
  /** The username used to login. */
  login: Scalars['String'];
  /** The user's public profile name. */
  name?: Maybe<Scalars['String']>;
  /** Find an organization by its login that the user belongs to. */
  organization?: Maybe<GQLOrganization>;
  /** Verified email addresses that match verified domains for a specified organization the user is a member of. */
  organizationVerifiedDomainEmails: Array<Scalars['String']>;
  /** A list of organizations the user belongs to. */
  organizations: GQLOrganizationConnection;
  /** A list of packages under the owner. */
  packages: GQLPackageConnection;
  /** A list of repositories and gists this profile owner can pin to their profile. */
  pinnableItems: GQLPinnableItemConnection;
  /** A list of repositories and gists this profile owner has pinned to their profile */
  pinnedItems: GQLPinnableItemConnection;
  /** Returns how many more items this profile owner can pin to their profile. */
  pinnedItemsRemaining: Scalars['Int'];
  /** Find project by number. */
  project?: Maybe<GQLProject>;
  /** A list of projects under the owner. */
  projects: GQLProjectConnection;
  /** The HTTP path listing user's projects */
  projectsResourcePath: Scalars['URI'];
  /** The HTTP URL listing user's projects */
  projectsUrl: Scalars['URI'];
  /** A list of public keys associated with this user. */
  publicKeys: GQLPublicKeyConnection;
  /** A list of pull requests associated with this user. */
  pullRequests: GQLPullRequestConnection;
  /**
   * A list of registry packages under the owner.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageOwner` object instead. Removal on 2020-04-01 UTC.
   */
  registryPackages: GQLRegistryPackageConnection;
  /**
   * A list of registry packages for a particular search query.
   * @deprecated Renaming GitHub Packages fields and objects. Use the `PackageSearch` object instead. Removal on 2020-04-01 UTC.
   */
  registryPackagesForQuery: GQLRegistryPackageConnection;
  /** A list of repositories that the user owns. */
  repositories: GQLRepositoryConnection;
  /** A list of repositories that the user recently contributed to. */
  repositoriesContributedTo: GQLRepositoryConnection;
  /** Find Repository. */
  repository?: Maybe<GQLRepository>;
  /** The HTTP path for this user */
  resourcePath: Scalars['URI'];
  /** Replies this user has saved */
  savedReplies?: Maybe<GQLSavedReplyConnection>;
  /** The GitHub Sponsors listing for this user. */
  sponsorsListing?: Maybe<GQLSponsorsListing>;
  /** This object's sponsorships as the maintainer. */
  sponsorshipsAsMaintainer: GQLSponsorshipConnection;
  /** This object's sponsorships as the sponsor. */
  sponsorshipsAsSponsor: GQLSponsorshipConnection;
  /** Repositories the user has starred. */
  starredRepositories: GQLStarredRepositoryConnection;
  /** The user's description of what they're currently doing. */
  status?: Maybe<GQLUserStatus>;
  /** Repositories the user has contributed to, ordered by contribution rank, plus repositories the user has created */
  topRepositories: GQLRepositoryConnection;
  /** The user's Twitter username. */
  twitterUsername?: Maybe<Scalars['String']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this user */
  url: Scalars['URI'];
  /** Can the viewer pin repositories and gists to the profile? */
  viewerCanChangePinnedItems: Scalars['Boolean'];
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean'];
  /** Whether or not the viewer is able to follow the user. */
  viewerCanFollow: Scalars['Boolean'];
  /** Whether or not this user is followed by the viewer. */
  viewerIsFollowing: Scalars['Boolean'];
  /** A list of repositories the given user is watching. */
  watching: GQLRepositoryConnection;
  /** A URL pointing to the user's public website/blog. */
  websiteUrl?: Maybe<Scalars['URI']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserAnyPinnableItemsArgs = {
  type?: Maybe<GQLPinnableItemType>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserAvatarUrlArgs = {
  size?: Maybe<Scalars['Int']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserCommitCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserContributionsCollectionArgs = {
  from?: Maybe<Scalars['DateTime']>;
  organizationID?: Maybe<Scalars['ID']>;
  to?: Maybe<Scalars['DateTime']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserFollowersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserFollowingArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserGistArgs = {
  name: Scalars['String'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserGistCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserGistsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLGistOrder>;
  privacy?: Maybe<GQLGistPrivacy>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserHovercardArgs = {
  primarySubjectId?: Maybe<Scalars['ID']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserIssueCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserIssuesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  filterBy?: Maybe<GQLIssueFilters>;
  first?: Maybe<Scalars['Int']>;
  labels?: Maybe<Array<Scalars['String']>>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLIssueOrder>;
  states?: Maybe<Array<GQLIssueState>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserOrganizationArgs = {
  login: Scalars['String'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserOrganizationVerifiedDomainEmailsArgs = {
  login: Scalars['String'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserOrganizationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserPackagesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  names?: Maybe<Array<Maybe<Scalars['String']>>>;
  orderBy?: Maybe<GQLPackageOrder>;
  repositoryId?: Maybe<Scalars['ID']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserPinnableItemsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  types?: Maybe<Array<GQLPinnableItemType>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserPinnedItemsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  types?: Maybe<Array<GQLPinnableItemType>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserProjectArgs = {
  number: Scalars['Int'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserProjectsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLProjectOrder>;
  search?: Maybe<Scalars['String']>;
  states?: Maybe<Array<GQLProjectState>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserPublicKeysArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserPullRequestsArgs = {
  after?: Maybe<Scalars['String']>;
  baseRefName?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  headRefName?: Maybe<Scalars['String']>;
  labels?: Maybe<Array<Scalars['String']>>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLIssueOrder>;
  states?: Maybe<Array<GQLPullRequestState>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserRegistryPackagesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  names?: Maybe<Array<Maybe<Scalars['String']>>>;
  packageType?: Maybe<GQLRegistryPackageType>;
  publicOnly?: Maybe<Scalars['Boolean']>;
  registryPackageType?: Maybe<Scalars['String']>;
  repositoryId?: Maybe<Scalars['ID']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserRegistryPackagesForQueryArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  packageType?: Maybe<GQLRegistryPackageType>;
  query?: Maybe<Scalars['String']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserRepositoriesArgs = {
  affiliations?: Maybe<Array<Maybe<GQLRepositoryAffiliation>>>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  isFork?: Maybe<Scalars['Boolean']>;
  isLocked?: Maybe<Scalars['Boolean']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLRepositoryOrder>;
  ownerAffiliations?: Maybe<Array<Maybe<GQLRepositoryAffiliation>>>;
  privacy?: Maybe<GQLRepositoryPrivacy>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserRepositoriesContributedToArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  contributionTypes?: Maybe<Array<Maybe<GQLRepositoryContributionType>>>;
  first?: Maybe<Scalars['Int']>;
  includeUserRepositories?: Maybe<Scalars['Boolean']>;
  isLocked?: Maybe<Scalars['Boolean']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLRepositoryOrder>;
  privacy?: Maybe<GQLRepositoryPrivacy>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserRepositoryArgs = {
  name: Scalars['String'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserSavedRepliesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLSavedReplyOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserSponsorshipsAsMaintainerArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  includePrivate?: Maybe<Scalars['Boolean']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLSponsorshipOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserSponsorshipsAsSponsorArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLSponsorshipOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserStarredRepositoriesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLStarOrder>;
  ownedByViewer?: Maybe<Scalars['Boolean']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserTopRepositoriesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  orderBy: GQLRepositoryOrder;
  since?: Maybe<Scalars['DateTime']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type GQLUserWatchingArgs = {
  affiliations?: Maybe<Array<Maybe<GQLRepositoryAffiliation>>>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  isLocked?: Maybe<Scalars['Boolean']>;
  last?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<GQLRepositoryOrder>;
  ownerAffiliations?: Maybe<Array<Maybe<GQLRepositoryAffiliation>>>;
  privacy?: Maybe<GQLRepositoryPrivacy>;
};

/** The possible durations that a user can be blocked for. */
export enum GQLUserBlockDuration {
  /** The user was blocked for 1 day */
  OneDay = 'ONE_DAY',
  /** The user was blocked for 30 days */
  OneMonth = 'ONE_MONTH',
  /** The user was blocked for 7 days */
  OneWeek = 'ONE_WEEK',
  /** The user was blocked permanently */
  Permanent = 'PERMANENT',
  /** The user was blocked for 3 days */
  ThreeDays = 'THREE_DAYS'
}

/** Represents a 'user_blocked' event on a given user. */
export type GQLUserBlockedEvent = GQLNode & {
  __typename?: 'UserBlockedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<GQLActor>;
  /** Number of days that the user was blocked for. */
  blockDuration: GQLUserBlockDuration;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** The user who was blocked. */
  subject?: Maybe<GQLUser>;
};

/** The connection type for User. */
export type GQLUserConnection = {
  __typename?: 'UserConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLUserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLUser>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edit on user content */
export type GQLUserContentEdit = GQLNode & {
  __typename?: 'UserContentEdit';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the date and time when the object was deleted. */
  deletedAt?: Maybe<Scalars['DateTime']>;
  /** The actor who deleted this content */
  deletedBy?: Maybe<GQLActor>;
  /** A summary of the changes for this edit */
  diff?: Maybe<Scalars['String']>;
  /** When this content was edited */
  editedAt: Scalars['DateTime'];
  /** The actor who edited this content */
  editor?: Maybe<GQLActor>;
  id: Scalars['ID'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** A list of edits to content. */
export type GQLUserContentEditConnection = {
  __typename?: 'UserContentEditConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLUserContentEditEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLUserContentEdit>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLUserContentEditEdge = {
  __typename?: 'UserContentEditEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLUserContentEdit>;
};

/** Represents a user. */
export type GQLUserEdge = {
  __typename?: 'UserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLUser>;
};

/** The user's description of what they're currently doing. */
export type GQLUserStatus = GQLNode & {
  __typename?: 'UserStatus';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** An emoji summarizing the user's status. */
  emoji?: Maybe<Scalars['String']>;
  /** The status emoji as HTML. */
  emojiHTML?: Maybe<Scalars['HTML']>;
  /** If set, the status will not be shown after this date. */
  expiresAt?: Maybe<Scalars['DateTime']>;
  /** ID of the object. */
  id: Scalars['ID'];
  /** Whether this status indicates the user is not fully available on GitHub. */
  indicatesLimitedAvailability: Scalars['Boolean'];
  /** A brief message describing what the user is doing. */
  message?: Maybe<Scalars['String']>;
  /** The organization whose members can see this status. If null, this status is publicly visible. */
  organization?: Maybe<GQLOrganization>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The user who has this status. */
  user: GQLUser;
};

/** The connection type for UserStatus. */
export type GQLUserStatusConnection = {
  __typename?: 'UserStatusConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GQLUserStatusEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GQLUserStatus>>>;
  /** Information to aid in pagination. */
  pageInfo: GQLPageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GQLUserStatusEdge = {
  __typename?: 'UserStatusEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GQLUserStatus>;
};

/** Ordering options for user status connections. */
export type GQLUserStatusOrder = {
  /** The ordering direction. */
  direction: GQLOrderDirection;
  /** The field to order user statuses by. */
  field: GQLUserStatusOrderField;
};

/** Properties by which user status connections can be ordered. */
export enum GQLUserStatusOrderField {
  /** Order user statuses by when they were updated. */
  UpdatedAt = 'UPDATED_AT'
}

/** A hovercard context with a message describing how the viewer is related. */
export type GQLViewerHovercardContext = GQLHovercardContext & {
  __typename?: 'ViewerHovercardContext';
  /** A string describing this context */
  message: Scalars['String'];
  /** An octicon to accompany this context */
  octicon: Scalars['String'];
  /** Identifies the user who is related to this context. */
  viewer: GQLUser;
};




export type ResolverTypeWrapper<T> = Promise<T> | T;


export type LegacyStitchingResolver<TResult, TParent, TContext, TArgs> = {
  fragment: string;
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type NewStitchingResolver<TResult, TParent, TContext, TArgs> = {
  selectionSet: string;
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type StitchingResolver<TResult, TParent, TContext, TArgs> = LegacyStitchingResolver<TResult, TParent, TContext, TArgs> | NewStitchingResolver<TResult, TParent, TContext, TArgs>;
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | StitchingResolver<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterator<TResult> | Promise<AsyncIterator<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}> = (obj: T, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type GQLResolversTypes = {
  AcceptEnterpriseAdministratorInvitationInput: GQLAcceptEnterpriseAdministratorInvitationInput;
  String: ResolverTypeWrapper<Scalars['String']>;
  ID: ResolverTypeWrapper<Scalars['ID']>;
  AcceptEnterpriseAdministratorInvitationPayload: ResolverTypeWrapper<GQLAcceptEnterpriseAdministratorInvitationPayload>;
  AcceptTopicSuggestionInput: GQLAcceptTopicSuggestionInput;
  AcceptTopicSuggestionPayload: ResolverTypeWrapper<GQLAcceptTopicSuggestionPayload>;
  ActionExecutionCapabilitySetting: GQLActionExecutionCapabilitySetting;
  Actor: GQLResolversTypes['Bot'] | GQLResolversTypes['EnterpriseUserAccount'] | GQLResolversTypes['Mannequin'] | GQLResolversTypes['Organization'] | GQLResolversTypes['User'];
  Int: ResolverTypeWrapper<Scalars['Int']>;
  ActorLocation: ResolverTypeWrapper<GQLActorLocation>;
  AddAssigneesToAssignableInput: GQLAddAssigneesToAssignableInput;
  AddAssigneesToAssignablePayload: ResolverTypeWrapper<GQLAddAssigneesToAssignablePayload>;
  AddCommentInput: GQLAddCommentInput;
  AddCommentPayload: ResolverTypeWrapper<GQLAddCommentPayload>;
  AddLabelsToLabelableInput: GQLAddLabelsToLabelableInput;
  AddLabelsToLabelablePayload: ResolverTypeWrapper<GQLAddLabelsToLabelablePayload>;
  AddProjectCardInput: GQLAddProjectCardInput;
  AddProjectCardPayload: ResolverTypeWrapper<GQLAddProjectCardPayload>;
  AddProjectColumnInput: GQLAddProjectColumnInput;
  AddProjectColumnPayload: ResolverTypeWrapper<GQLAddProjectColumnPayload>;
  AddPullRequestReviewCommentInput: GQLAddPullRequestReviewCommentInput;
  AddPullRequestReviewCommentPayload: ResolverTypeWrapper<GQLAddPullRequestReviewCommentPayload>;
  AddPullRequestReviewInput: GQLAddPullRequestReviewInput;
  AddPullRequestReviewPayload: ResolverTypeWrapper<GQLAddPullRequestReviewPayload>;
  AddPullRequestReviewThreadInput: GQLAddPullRequestReviewThreadInput;
  AddPullRequestReviewThreadPayload: ResolverTypeWrapper<GQLAddPullRequestReviewThreadPayload>;
  AddReactionInput: GQLAddReactionInput;
  AddReactionPayload: ResolverTypeWrapper<GQLAddReactionPayload>;
  AddStarInput: GQLAddStarInput;
  AddStarPayload: ResolverTypeWrapper<GQLAddStarPayload>;
  AddedToProjectEvent: ResolverTypeWrapper<GQLAddedToProjectEvent>;
  App: ResolverTypeWrapper<GQLApp>;
  ArchiveRepositoryInput: GQLArchiveRepositoryInput;
  ArchiveRepositoryPayload: ResolverTypeWrapper<GQLArchiveRepositoryPayload>;
  Assignable: GQLResolversTypes['Issue'] | GQLResolversTypes['PullRequest'];
  AssignedEvent: ResolverTypeWrapper<Omit<GQLAssignedEvent, 'assignee'> & { assignee?: Maybe<GQLResolversTypes['Assignee']> }>;
  Assignee: GQLResolversTypes['Bot'] | GQLResolversTypes['Mannequin'] | GQLResolversTypes['Organization'] | GQLResolversTypes['User'];
  AuditEntry: GQLResolversTypes['MembersCanDeleteReposClearAuditEntry'] | GQLResolversTypes['MembersCanDeleteReposDisableAuditEntry'] | GQLResolversTypes['MembersCanDeleteReposEnableAuditEntry'] | GQLResolversTypes['OauthApplicationCreateAuditEntry'] | GQLResolversTypes['OrgAddBillingManagerAuditEntry'] | GQLResolversTypes['OrgAddMemberAuditEntry'] | GQLResolversTypes['OrgBlockUserAuditEntry'] | GQLResolversTypes['OrgConfigDisableCollaboratorsOnlyAuditEntry'] | GQLResolversTypes['OrgConfigEnableCollaboratorsOnlyAuditEntry'] | GQLResolversTypes['OrgCreateAuditEntry'] | GQLResolversTypes['OrgDisableOauthAppRestrictionsAuditEntry'] | GQLResolversTypes['OrgDisableSamlAuditEntry'] | GQLResolversTypes['OrgDisableTwoFactorRequirementAuditEntry'] | GQLResolversTypes['OrgEnableOauthAppRestrictionsAuditEntry'] | GQLResolversTypes['OrgEnableSamlAuditEntry'] | GQLResolversTypes['OrgEnableTwoFactorRequirementAuditEntry'] | GQLResolversTypes['OrgInviteMemberAuditEntry'] | GQLResolversTypes['OrgInviteToBusinessAuditEntry'] | GQLResolversTypes['OrgOauthAppAccessApprovedAuditEntry'] | GQLResolversTypes['OrgOauthAppAccessDeniedAuditEntry'] | GQLResolversTypes['OrgOauthAppAccessRequestedAuditEntry'] | GQLResolversTypes['OrgRemoveBillingManagerAuditEntry'] | GQLResolversTypes['OrgRemoveMemberAuditEntry'] | GQLResolversTypes['OrgRemoveOutsideCollaboratorAuditEntry'] | GQLResolversTypes['OrgRestoreMemberAuditEntry'] | GQLResolversTypes['OrgUnblockUserAuditEntry'] | GQLResolversTypes['OrgUpdateDefaultRepositoryPermissionAuditEntry'] | GQLResolversTypes['OrgUpdateMemberAuditEntry'] | GQLResolversTypes['OrgUpdateMemberRepositoryCreationPermissionAuditEntry'] | GQLResolversTypes['OrgUpdateMemberRepositoryInvitationPermissionAuditEntry'] | GQLResolversTypes['PrivateRepositoryForkingDisableAuditEntry'] | GQLResolversTypes['PrivateRepositoryForkingEnableAuditEntry'] | GQLResolversTypes['RepoAccessAuditEntry'] | GQLResolversTypes['RepoAddMemberAuditEntry'] | GQLResolversTypes['RepoAddTopicAuditEntry'] | GQLResolversTypes['RepoArchivedAuditEntry'] | GQLResolversTypes['RepoChangeMergeSettingAuditEntry'] | GQLResolversTypes['RepoConfigDisableAnonymousGitAccessAuditEntry'] | GQLResolversTypes['RepoConfigDisableCollaboratorsOnlyAuditEntry'] | GQLResolversTypes['RepoConfigDisableContributorsOnlyAuditEntry'] | GQLResolversTypes['RepoConfigDisableSockpuppetDisallowedAuditEntry'] | GQLResolversTypes['RepoConfigEnableAnonymousGitAccessAuditEntry'] | GQLResolversTypes['RepoConfigEnableCollaboratorsOnlyAuditEntry'] | GQLResolversTypes['RepoConfigEnableContributorsOnlyAuditEntry'] | GQLResolversTypes['RepoConfigEnableSockpuppetDisallowedAuditEntry'] | GQLResolversTypes['RepoConfigLockAnonymousGitAccessAuditEntry'] | GQLResolversTypes['RepoConfigUnlockAnonymousGitAccessAuditEntry'] | GQLResolversTypes['RepoCreateAuditEntry'] | GQLResolversTypes['RepoDestroyAuditEntry'] | GQLResolversTypes['RepoRemoveMemberAuditEntry'] | GQLResolversTypes['RepoRemoveTopicAuditEntry'] | GQLResolversTypes['RepositoryVisibilityChangeDisableAuditEntry'] | GQLResolversTypes['RepositoryVisibilityChangeEnableAuditEntry'] | GQLResolversTypes['TeamAddMemberAuditEntry'] | GQLResolversTypes['TeamAddRepositoryAuditEntry'] | GQLResolversTypes['TeamChangeParentTeamAuditEntry'] | GQLResolversTypes['TeamRemoveMemberAuditEntry'] | GQLResolversTypes['TeamRemoveRepositoryAuditEntry'];
  AuditEntryActor: GQLResolversTypes['Bot'] | GQLResolversTypes['Organization'] | GQLResolversTypes['User'];
  AuditLogOrder: GQLAuditLogOrder;
  AuditLogOrderField: GQLAuditLogOrderField;
  AutomaticBaseChangeFailedEvent: ResolverTypeWrapper<GQLAutomaticBaseChangeFailedEvent>;
  AutomaticBaseChangeSucceededEvent: ResolverTypeWrapper<GQLAutomaticBaseChangeSucceededEvent>;
  BaseRefChangedEvent: ResolverTypeWrapper<GQLBaseRefChangedEvent>;
  BaseRefForcePushedEvent: ResolverTypeWrapper<GQLBaseRefForcePushedEvent>;
  Blame: ResolverTypeWrapper<GQLBlame>;
  BlameRange: ResolverTypeWrapper<GQLBlameRange>;
  Blob: ResolverTypeWrapper<GQLBlob>;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
  Bot: ResolverTypeWrapper<GQLBot>;
  BranchProtectionRule: ResolverTypeWrapper<GQLBranchProtectionRule>;
  BranchProtectionRuleConflict: ResolverTypeWrapper<GQLBranchProtectionRuleConflict>;
  BranchProtectionRuleConflictConnection: ResolverTypeWrapper<GQLBranchProtectionRuleConflictConnection>;
  BranchProtectionRuleConflictEdge: ResolverTypeWrapper<GQLBranchProtectionRuleConflictEdge>;
  BranchProtectionRuleConnection: ResolverTypeWrapper<GQLBranchProtectionRuleConnection>;
  BranchProtectionRuleEdge: ResolverTypeWrapper<GQLBranchProtectionRuleEdge>;
  CancelEnterpriseAdminInvitationInput: GQLCancelEnterpriseAdminInvitationInput;
  CancelEnterpriseAdminInvitationPayload: ResolverTypeWrapper<GQLCancelEnterpriseAdminInvitationPayload>;
  ChangeUserStatusInput: GQLChangeUserStatusInput;
  ChangeUserStatusPayload: ResolverTypeWrapper<GQLChangeUserStatusPayload>;
  CheckAnnotation: ResolverTypeWrapper<GQLCheckAnnotation>;
  CheckAnnotationConnection: ResolverTypeWrapper<GQLCheckAnnotationConnection>;
  CheckAnnotationData: GQLCheckAnnotationData;
  CheckAnnotationEdge: ResolverTypeWrapper<GQLCheckAnnotationEdge>;
  CheckAnnotationLevel: GQLCheckAnnotationLevel;
  CheckAnnotationPosition: ResolverTypeWrapper<GQLCheckAnnotationPosition>;
  CheckAnnotationRange: GQLCheckAnnotationRange;
  CheckAnnotationSpan: ResolverTypeWrapper<GQLCheckAnnotationSpan>;
  CheckConclusionState: GQLCheckConclusionState;
  CheckRun: ResolverTypeWrapper<GQLCheckRun>;
  CheckRunAction: GQLCheckRunAction;
  CheckRunConnection: ResolverTypeWrapper<GQLCheckRunConnection>;
  CheckRunEdge: ResolverTypeWrapper<GQLCheckRunEdge>;
  CheckRunFilter: GQLCheckRunFilter;
  CheckRunOutput: GQLCheckRunOutput;
  CheckRunOutputImage: GQLCheckRunOutputImage;
  CheckRunType: GQLCheckRunType;
  CheckStatusState: GQLCheckStatusState;
  CheckSuite: ResolverTypeWrapper<GQLCheckSuite>;
  CheckSuiteAutoTriggerPreference: GQLCheckSuiteAutoTriggerPreference;
  CheckSuiteConnection: ResolverTypeWrapper<GQLCheckSuiteConnection>;
  CheckSuiteEdge: ResolverTypeWrapper<GQLCheckSuiteEdge>;
  CheckSuiteFilter: GQLCheckSuiteFilter;
  ClearLabelsFromLabelableInput: GQLClearLabelsFromLabelableInput;
  ClearLabelsFromLabelablePayload: ResolverTypeWrapper<GQLClearLabelsFromLabelablePayload>;
  CloneProjectInput: GQLCloneProjectInput;
  CloneProjectPayload: ResolverTypeWrapper<GQLCloneProjectPayload>;
  CloneTemplateRepositoryInput: GQLCloneTemplateRepositoryInput;
  CloneTemplateRepositoryPayload: ResolverTypeWrapper<GQLCloneTemplateRepositoryPayload>;
  Closable: GQLResolversTypes['Issue'] | GQLResolversTypes['Milestone'] | GQLResolversTypes['Project'] | GQLResolversTypes['PullRequest'];
  CloseIssueInput: GQLCloseIssueInput;
  CloseIssuePayload: ResolverTypeWrapper<GQLCloseIssuePayload>;
  ClosePullRequestInput: GQLClosePullRequestInput;
  ClosePullRequestPayload: ResolverTypeWrapper<GQLClosePullRequestPayload>;
  ClosedEvent: ResolverTypeWrapper<Omit<GQLClosedEvent, 'closer'> & { closer?: Maybe<GQLResolversTypes['Closer']> }>;
  Closer: GQLResolversTypes['Commit'] | GQLResolversTypes['PullRequest'];
  CodeOfConduct: ResolverTypeWrapper<GQLCodeOfConduct>;
  CollaboratorAffiliation: GQLCollaboratorAffiliation;
  Comment: GQLResolversTypes['CommitComment'] | GQLResolversTypes['GistComment'] | GQLResolversTypes['Issue'] | GQLResolversTypes['IssueComment'] | GQLResolversTypes['PullRequest'] | GQLResolversTypes['PullRequestReview'] | GQLResolversTypes['PullRequestReviewComment'] | GQLResolversTypes['TeamDiscussion'] | GQLResolversTypes['TeamDiscussionComment'];
  CommentAuthorAssociation: GQLCommentAuthorAssociation;
  CommentCannotUpdateReason: GQLCommentCannotUpdateReason;
  CommentDeletedEvent: ResolverTypeWrapper<GQLCommentDeletedEvent>;
  Commit: ResolverTypeWrapper<GQLCommit>;
  CommitAuthor: GQLCommitAuthor;
  CommitComment: ResolverTypeWrapper<GQLCommitComment>;
  CommitCommentConnection: ResolverTypeWrapper<GQLCommitCommentConnection>;
  CommitCommentEdge: ResolverTypeWrapper<GQLCommitCommentEdge>;
  CommitCommentThread: ResolverTypeWrapper<GQLCommitCommentThread>;
  CommitConnection: ResolverTypeWrapper<GQLCommitConnection>;
  CommitContributionOrder: GQLCommitContributionOrder;
  CommitContributionOrderField: GQLCommitContributionOrderField;
  CommitContributionsByRepository: ResolverTypeWrapper<GQLCommitContributionsByRepository>;
  CommitEdge: ResolverTypeWrapper<GQLCommitEdge>;
  CommitHistoryConnection: ResolverTypeWrapper<GQLCommitHistoryConnection>;
  ConnectedEvent: ResolverTypeWrapper<Omit<GQLConnectedEvent, 'source' | 'subject'> & { source: GQLResolversTypes['ReferencedSubject'], subject: GQLResolversTypes['ReferencedSubject'] }>;
  ContentAttachment: ResolverTypeWrapper<GQLContentAttachment>;
  ContentReference: ResolverTypeWrapper<GQLContentReference>;
  Contribution: GQLResolversTypes['CreatedCommitContribution'] | GQLResolversTypes['CreatedIssueContribution'] | GQLResolversTypes['CreatedPullRequestContribution'] | GQLResolversTypes['CreatedPullRequestReviewContribution'] | GQLResolversTypes['CreatedRepositoryContribution'] | GQLResolversTypes['JoinedGitHubContribution'] | GQLResolversTypes['RestrictedContribution'];
  ContributionCalendar: ResolverTypeWrapper<GQLContributionCalendar>;
  ContributionCalendarDay: ResolverTypeWrapper<GQLContributionCalendarDay>;
  ContributionCalendarMonth: ResolverTypeWrapper<GQLContributionCalendarMonth>;
  ContributionCalendarWeek: ResolverTypeWrapper<GQLContributionCalendarWeek>;
  ContributionOrder: GQLContributionOrder;
  ContributionsCollection: ResolverTypeWrapper<Omit<GQLContributionsCollection, 'firstIssueContribution' | 'firstPullRequestContribution' | 'firstRepositoryContribution'> & { firstIssueContribution?: Maybe<GQLResolversTypes['CreatedIssueOrRestrictedContribution']>, firstPullRequestContribution?: Maybe<GQLResolversTypes['CreatedPullRequestOrRestrictedContribution']>, firstRepositoryContribution?: Maybe<GQLResolversTypes['CreatedRepositoryOrRestrictedContribution']> }>;
  ConvertProjectCardNoteToIssueInput: GQLConvertProjectCardNoteToIssueInput;
  ConvertProjectCardNoteToIssuePayload: ResolverTypeWrapper<GQLConvertProjectCardNoteToIssuePayload>;
  ConvertToDraftEvent: ResolverTypeWrapper<GQLConvertToDraftEvent>;
  ConvertedNoteToIssueEvent: ResolverTypeWrapper<GQLConvertedNoteToIssueEvent>;
  CreateBranchProtectionRuleInput: GQLCreateBranchProtectionRuleInput;
  CreateBranchProtectionRulePayload: ResolverTypeWrapper<GQLCreateBranchProtectionRulePayload>;
  CreateCheckRunInput: GQLCreateCheckRunInput;
  CreateCheckRunPayload: ResolverTypeWrapper<GQLCreateCheckRunPayload>;
  CreateCheckSuiteInput: GQLCreateCheckSuiteInput;
  CreateCheckSuitePayload: ResolverTypeWrapper<GQLCreateCheckSuitePayload>;
  CreateContentAttachmentInput: GQLCreateContentAttachmentInput;
  CreateContentAttachmentPayload: ResolverTypeWrapper<GQLCreateContentAttachmentPayload>;
  CreateDeploymentInput: GQLCreateDeploymentInput;
  CreateDeploymentPayload: ResolverTypeWrapper<GQLCreateDeploymentPayload>;
  CreateDeploymentStatusInput: GQLCreateDeploymentStatusInput;
  CreateDeploymentStatusPayload: ResolverTypeWrapper<GQLCreateDeploymentStatusPayload>;
  CreateEnterpriseOrganizationInput: GQLCreateEnterpriseOrganizationInput;
  CreateEnterpriseOrganizationPayload: ResolverTypeWrapper<GQLCreateEnterpriseOrganizationPayload>;
  CreateIpAllowListEntryInput: GQLCreateIpAllowListEntryInput;
  CreateIpAllowListEntryPayload: ResolverTypeWrapper<GQLCreateIpAllowListEntryPayload>;
  CreateIssueInput: GQLCreateIssueInput;
  CreateIssuePayload: ResolverTypeWrapper<GQLCreateIssuePayload>;
  CreateLabelInput: GQLCreateLabelInput;
  CreateLabelPayload: ResolverTypeWrapper<GQLCreateLabelPayload>;
  CreateProjectInput: GQLCreateProjectInput;
  CreateProjectPayload: ResolverTypeWrapper<GQLCreateProjectPayload>;
  CreatePullRequestInput: GQLCreatePullRequestInput;
  CreatePullRequestPayload: ResolverTypeWrapper<GQLCreatePullRequestPayload>;
  CreateRefInput: GQLCreateRefInput;
  CreateRefPayload: ResolverTypeWrapper<GQLCreateRefPayload>;
  CreateRepositoryInput: GQLCreateRepositoryInput;
  CreateRepositoryPayload: ResolverTypeWrapper<GQLCreateRepositoryPayload>;
  CreateTeamDiscussionCommentInput: GQLCreateTeamDiscussionCommentInput;
  CreateTeamDiscussionCommentPayload: ResolverTypeWrapper<GQLCreateTeamDiscussionCommentPayload>;
  CreateTeamDiscussionInput: GQLCreateTeamDiscussionInput;
  CreateTeamDiscussionPayload: ResolverTypeWrapper<GQLCreateTeamDiscussionPayload>;
  CreatedCommitContribution: ResolverTypeWrapper<GQLCreatedCommitContribution>;
  CreatedCommitContributionConnection: ResolverTypeWrapper<GQLCreatedCommitContributionConnection>;
  CreatedCommitContributionEdge: ResolverTypeWrapper<GQLCreatedCommitContributionEdge>;
  CreatedIssueContribution: ResolverTypeWrapper<GQLCreatedIssueContribution>;
  CreatedIssueContributionConnection: ResolverTypeWrapper<GQLCreatedIssueContributionConnection>;
  CreatedIssueContributionEdge: ResolverTypeWrapper<GQLCreatedIssueContributionEdge>;
  CreatedIssueOrRestrictedContribution: GQLResolversTypes['CreatedIssueContribution'] | GQLResolversTypes['RestrictedContribution'];
  CreatedPullRequestContribution: ResolverTypeWrapper<GQLCreatedPullRequestContribution>;
  CreatedPullRequestContributionConnection: ResolverTypeWrapper<GQLCreatedPullRequestContributionConnection>;
  CreatedPullRequestContributionEdge: ResolverTypeWrapper<GQLCreatedPullRequestContributionEdge>;
  CreatedPullRequestOrRestrictedContribution: GQLResolversTypes['CreatedPullRequestContribution'] | GQLResolversTypes['RestrictedContribution'];
  CreatedPullRequestReviewContribution: ResolverTypeWrapper<GQLCreatedPullRequestReviewContribution>;
  CreatedPullRequestReviewContributionConnection: ResolverTypeWrapper<GQLCreatedPullRequestReviewContributionConnection>;
  CreatedPullRequestReviewContributionEdge: ResolverTypeWrapper<GQLCreatedPullRequestReviewContributionEdge>;
  CreatedRepositoryContribution: ResolverTypeWrapper<GQLCreatedRepositoryContribution>;
  CreatedRepositoryContributionConnection: ResolverTypeWrapper<GQLCreatedRepositoryContributionConnection>;
  CreatedRepositoryContributionEdge: ResolverTypeWrapper<GQLCreatedRepositoryContributionEdge>;
  CreatedRepositoryOrRestrictedContribution: GQLResolversTypes['CreatedRepositoryContribution'] | GQLResolversTypes['RestrictedContribution'];
  CrossReferencedEvent: ResolverTypeWrapper<Omit<GQLCrossReferencedEvent, 'source' | 'target'> & { source: GQLResolversTypes['ReferencedSubject'], target: GQLResolversTypes['ReferencedSubject'] }>;
  Date: ResolverTypeWrapper<Scalars['Date']>;
  DateTime: ResolverTypeWrapper<Scalars['DateTime']>;
  DeclineTopicSuggestionInput: GQLDeclineTopicSuggestionInput;
  DeclineTopicSuggestionPayload: ResolverTypeWrapper<GQLDeclineTopicSuggestionPayload>;
  DefaultRepositoryPermissionField: GQLDefaultRepositoryPermissionField;
  Deletable: GQLResolversTypes['CommitComment'] | GQLResolversTypes['GistComment'] | GQLResolversTypes['IssueComment'] | GQLResolversTypes['PullRequestReview'] | GQLResolversTypes['PullRequestReviewComment'] | GQLResolversTypes['TeamDiscussion'] | GQLResolversTypes['TeamDiscussionComment'];
  DeleteBranchProtectionRuleInput: GQLDeleteBranchProtectionRuleInput;
  DeleteBranchProtectionRulePayload: ResolverTypeWrapper<GQLDeleteBranchProtectionRulePayload>;
  DeleteDeploymentInput: GQLDeleteDeploymentInput;
  DeleteDeploymentPayload: ResolverTypeWrapper<GQLDeleteDeploymentPayload>;
  DeleteIpAllowListEntryInput: GQLDeleteIpAllowListEntryInput;
  DeleteIpAllowListEntryPayload: ResolverTypeWrapper<GQLDeleteIpAllowListEntryPayload>;
  DeleteIssueCommentInput: GQLDeleteIssueCommentInput;
  DeleteIssueCommentPayload: ResolverTypeWrapper<GQLDeleteIssueCommentPayload>;
  DeleteIssueInput: GQLDeleteIssueInput;
  DeleteIssuePayload: ResolverTypeWrapper<GQLDeleteIssuePayload>;
  DeleteLabelInput: GQLDeleteLabelInput;
  DeleteLabelPayload: ResolverTypeWrapper<GQLDeleteLabelPayload>;
  DeletePackageVersionInput: GQLDeletePackageVersionInput;
  DeletePackageVersionPayload: ResolverTypeWrapper<GQLDeletePackageVersionPayload>;
  DeleteProjectCardInput: GQLDeleteProjectCardInput;
  DeleteProjectCardPayload: ResolverTypeWrapper<GQLDeleteProjectCardPayload>;
  DeleteProjectColumnInput: GQLDeleteProjectColumnInput;
  DeleteProjectColumnPayload: ResolverTypeWrapper<GQLDeleteProjectColumnPayload>;
  DeleteProjectInput: GQLDeleteProjectInput;
  DeleteProjectPayload: ResolverTypeWrapper<GQLDeleteProjectPayload>;
  DeletePullRequestReviewCommentInput: GQLDeletePullRequestReviewCommentInput;
  DeletePullRequestReviewCommentPayload: ResolverTypeWrapper<GQLDeletePullRequestReviewCommentPayload>;
  DeletePullRequestReviewInput: GQLDeletePullRequestReviewInput;
  DeletePullRequestReviewPayload: ResolverTypeWrapper<GQLDeletePullRequestReviewPayload>;
  DeleteRefInput: GQLDeleteRefInput;
  DeleteRefPayload: ResolverTypeWrapper<GQLDeleteRefPayload>;
  DeleteTeamDiscussionCommentInput: GQLDeleteTeamDiscussionCommentInput;
  DeleteTeamDiscussionCommentPayload: ResolverTypeWrapper<GQLDeleteTeamDiscussionCommentPayload>;
  DeleteTeamDiscussionInput: GQLDeleteTeamDiscussionInput;
  DeleteTeamDiscussionPayload: ResolverTypeWrapper<GQLDeleteTeamDiscussionPayload>;
  DemilestonedEvent: ResolverTypeWrapper<Omit<GQLDemilestonedEvent, 'subject'> & { subject: GQLResolversTypes['MilestoneItem'] }>;
  DependencyGraphDependency: ResolverTypeWrapper<GQLDependencyGraphDependency>;
  DependencyGraphDependencyConnection: ResolverTypeWrapper<GQLDependencyGraphDependencyConnection>;
  DependencyGraphDependencyEdge: ResolverTypeWrapper<GQLDependencyGraphDependencyEdge>;
  DependencyGraphManifest: ResolverTypeWrapper<GQLDependencyGraphManifest>;
  DependencyGraphManifestConnection: ResolverTypeWrapper<GQLDependencyGraphManifestConnection>;
  DependencyGraphManifestEdge: ResolverTypeWrapper<GQLDependencyGraphManifestEdge>;
  DeployKey: ResolverTypeWrapper<GQLDeployKey>;
  DeployKeyConnection: ResolverTypeWrapper<GQLDeployKeyConnection>;
  DeployKeyEdge: ResolverTypeWrapper<GQLDeployKeyEdge>;
  DeployedEvent: ResolverTypeWrapper<GQLDeployedEvent>;
  Deployment: ResolverTypeWrapper<GQLDeployment>;
  DeploymentConnection: ResolverTypeWrapper<GQLDeploymentConnection>;
  DeploymentEdge: ResolverTypeWrapper<GQLDeploymentEdge>;
  DeploymentEnvironmentChangedEvent: ResolverTypeWrapper<GQLDeploymentEnvironmentChangedEvent>;
  DeploymentOrder: GQLDeploymentOrder;
  DeploymentOrderField: GQLDeploymentOrderField;
  DeploymentState: GQLDeploymentState;
  DeploymentStatus: ResolverTypeWrapper<GQLDeploymentStatus>;
  DeploymentStatusConnection: ResolverTypeWrapper<GQLDeploymentStatusConnection>;
  DeploymentStatusEdge: ResolverTypeWrapper<GQLDeploymentStatusEdge>;
  DeploymentStatusState: GQLDeploymentStatusState;
  DiffSide: GQLDiffSide;
  DisconnectedEvent: ResolverTypeWrapper<Omit<GQLDisconnectedEvent, 'source' | 'subject'> & { source: GQLResolversTypes['ReferencedSubject'], subject: GQLResolversTypes['ReferencedSubject'] }>;
  DismissPullRequestReviewInput: GQLDismissPullRequestReviewInput;
  DismissPullRequestReviewPayload: ResolverTypeWrapper<GQLDismissPullRequestReviewPayload>;
  DraftPullRequestReviewComment: GQLDraftPullRequestReviewComment;
  DraftPullRequestReviewThread: GQLDraftPullRequestReviewThread;
  Enterprise: ResolverTypeWrapper<GQLEnterprise>;
  EnterpriseAdministratorConnection: ResolverTypeWrapper<GQLEnterpriseAdministratorConnection>;
  EnterpriseAdministratorEdge: ResolverTypeWrapper<GQLEnterpriseAdministratorEdge>;
  EnterpriseAdministratorInvitation: ResolverTypeWrapper<GQLEnterpriseAdministratorInvitation>;
  EnterpriseAdministratorInvitationConnection: ResolverTypeWrapper<GQLEnterpriseAdministratorInvitationConnection>;
  EnterpriseAdministratorInvitationEdge: ResolverTypeWrapper<GQLEnterpriseAdministratorInvitationEdge>;
  EnterpriseAdministratorInvitationOrder: GQLEnterpriseAdministratorInvitationOrder;
  EnterpriseAdministratorInvitationOrderField: GQLEnterpriseAdministratorInvitationOrderField;
  EnterpriseAdministratorRole: GQLEnterpriseAdministratorRole;
  EnterpriseAuditEntryData: GQLResolversTypes['MembersCanDeleteReposClearAuditEntry'] | GQLResolversTypes['MembersCanDeleteReposDisableAuditEntry'] | GQLResolversTypes['MembersCanDeleteReposEnableAuditEntry'] | GQLResolversTypes['OrgInviteToBusinessAuditEntry'] | GQLResolversTypes['PrivateRepositoryForkingDisableAuditEntry'] | GQLResolversTypes['PrivateRepositoryForkingEnableAuditEntry'] | GQLResolversTypes['RepositoryVisibilityChangeDisableAuditEntry'] | GQLResolversTypes['RepositoryVisibilityChangeEnableAuditEntry'];
  EnterpriseBillingInfo: ResolverTypeWrapper<GQLEnterpriseBillingInfo>;
  Float: ResolverTypeWrapper<Scalars['Float']>;
  EnterpriseDefaultRepositoryPermissionSettingValue: GQLEnterpriseDefaultRepositoryPermissionSettingValue;
  EnterpriseEnabledDisabledSettingValue: GQLEnterpriseEnabledDisabledSettingValue;
  EnterpriseEnabledSettingValue: GQLEnterpriseEnabledSettingValue;
  EnterpriseIdentityProvider: ResolverTypeWrapper<GQLEnterpriseIdentityProvider>;
  EnterpriseMember: GQLResolversTypes['EnterpriseUserAccount'] | GQLResolversTypes['User'];
  EnterpriseMemberConnection: ResolverTypeWrapper<Omit<GQLEnterpriseMemberConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<GQLResolversTypes['EnterpriseMember']>>> }>;
  EnterpriseMemberEdge: ResolverTypeWrapper<Omit<GQLEnterpriseMemberEdge, 'node'> & { node?: Maybe<GQLResolversTypes['EnterpriseMember']> }>;
  EnterpriseMemberOrder: GQLEnterpriseMemberOrder;
  EnterpriseMemberOrderField: GQLEnterpriseMemberOrderField;
  EnterpriseMembersCanCreateRepositoriesSettingValue: GQLEnterpriseMembersCanCreateRepositoriesSettingValue;
  EnterpriseMembersCanMakePurchasesSettingValue: GQLEnterpriseMembersCanMakePurchasesSettingValue;
  EnterpriseOrganizationMembershipConnection: ResolverTypeWrapper<GQLEnterpriseOrganizationMembershipConnection>;
  EnterpriseOrganizationMembershipEdge: ResolverTypeWrapper<GQLEnterpriseOrganizationMembershipEdge>;
  EnterpriseOutsideCollaboratorConnection: ResolverTypeWrapper<GQLEnterpriseOutsideCollaboratorConnection>;
  EnterpriseOutsideCollaboratorEdge: ResolverTypeWrapper<GQLEnterpriseOutsideCollaboratorEdge>;
  EnterpriseOwnerInfo: ResolverTypeWrapper<GQLEnterpriseOwnerInfo>;
  EnterprisePendingCollaboratorConnection: ResolverTypeWrapper<GQLEnterprisePendingCollaboratorConnection>;
  EnterprisePendingCollaboratorEdge: ResolverTypeWrapper<GQLEnterprisePendingCollaboratorEdge>;
  EnterprisePendingMemberInvitationConnection: ResolverTypeWrapper<GQLEnterprisePendingMemberInvitationConnection>;
  EnterprisePendingMemberInvitationEdge: ResolverTypeWrapper<GQLEnterprisePendingMemberInvitationEdge>;
  EnterpriseRepositoryInfo: ResolverTypeWrapper<GQLEnterpriseRepositoryInfo>;
  EnterpriseRepositoryInfoConnection: ResolverTypeWrapper<GQLEnterpriseRepositoryInfoConnection>;
  EnterpriseRepositoryInfoEdge: ResolverTypeWrapper<GQLEnterpriseRepositoryInfoEdge>;
  EnterpriseServerInstallation: ResolverTypeWrapper<GQLEnterpriseServerInstallation>;
  EnterpriseServerInstallationConnection: ResolverTypeWrapper<GQLEnterpriseServerInstallationConnection>;
  EnterpriseServerInstallationEdge: ResolverTypeWrapper<GQLEnterpriseServerInstallationEdge>;
  EnterpriseServerInstallationOrder: GQLEnterpriseServerInstallationOrder;
  EnterpriseServerInstallationOrderField: GQLEnterpriseServerInstallationOrderField;
  EnterpriseServerUserAccount: ResolverTypeWrapper<GQLEnterpriseServerUserAccount>;
  EnterpriseServerUserAccountConnection: ResolverTypeWrapper<GQLEnterpriseServerUserAccountConnection>;
  EnterpriseServerUserAccountEdge: ResolverTypeWrapper<GQLEnterpriseServerUserAccountEdge>;
  EnterpriseServerUserAccountEmail: ResolverTypeWrapper<GQLEnterpriseServerUserAccountEmail>;
  EnterpriseServerUserAccountEmailConnection: ResolverTypeWrapper<GQLEnterpriseServerUserAccountEmailConnection>;
  EnterpriseServerUserAccountEmailEdge: ResolverTypeWrapper<GQLEnterpriseServerUserAccountEmailEdge>;
  EnterpriseServerUserAccountEmailOrder: GQLEnterpriseServerUserAccountEmailOrder;
  EnterpriseServerUserAccountEmailOrderField: GQLEnterpriseServerUserAccountEmailOrderField;
  EnterpriseServerUserAccountOrder: GQLEnterpriseServerUserAccountOrder;
  EnterpriseServerUserAccountOrderField: GQLEnterpriseServerUserAccountOrderField;
  EnterpriseServerUserAccountsUpload: ResolverTypeWrapper<GQLEnterpriseServerUserAccountsUpload>;
  EnterpriseServerUserAccountsUploadConnection: ResolverTypeWrapper<GQLEnterpriseServerUserAccountsUploadConnection>;
  EnterpriseServerUserAccountsUploadEdge: ResolverTypeWrapper<GQLEnterpriseServerUserAccountsUploadEdge>;
  EnterpriseServerUserAccountsUploadOrder: GQLEnterpriseServerUserAccountsUploadOrder;
  EnterpriseServerUserAccountsUploadOrderField: GQLEnterpriseServerUserAccountsUploadOrderField;
  EnterpriseServerUserAccountsUploadSyncState: GQLEnterpriseServerUserAccountsUploadSyncState;
  EnterpriseUserAccount: ResolverTypeWrapper<GQLEnterpriseUserAccount>;
  EnterpriseUserAccountConnection: ResolverTypeWrapper<GQLEnterpriseUserAccountConnection>;
  EnterpriseUserAccountEdge: ResolverTypeWrapper<GQLEnterpriseUserAccountEdge>;
  EnterpriseUserAccountMembershipRole: GQLEnterpriseUserAccountMembershipRole;
  EnterpriseUserDeployment: GQLEnterpriseUserDeployment;
  ExternalIdentity: ResolverTypeWrapper<GQLExternalIdentity>;
  ExternalIdentityConnection: ResolverTypeWrapper<GQLExternalIdentityConnection>;
  ExternalIdentityEdge: ResolverTypeWrapper<GQLExternalIdentityEdge>;
  ExternalIdentitySamlAttributes: ResolverTypeWrapper<GQLExternalIdentitySamlAttributes>;
  ExternalIdentityScimAttributes: ResolverTypeWrapper<GQLExternalIdentityScimAttributes>;
  FollowUserInput: GQLFollowUserInput;
  FollowUserPayload: ResolverTypeWrapper<GQLFollowUserPayload>;
  FollowerConnection: ResolverTypeWrapper<GQLFollowerConnection>;
  FollowingConnection: ResolverTypeWrapper<GQLFollowingConnection>;
  FundingLink: ResolverTypeWrapper<GQLFundingLink>;
  FundingPlatform: GQLFundingPlatform;
  GenericHovercardContext: ResolverTypeWrapper<GQLGenericHovercardContext>;
  Gist: ResolverTypeWrapper<GQLGist>;
  GistComment: ResolverTypeWrapper<GQLGistComment>;
  GistCommentConnection: ResolverTypeWrapper<GQLGistCommentConnection>;
  GistCommentEdge: ResolverTypeWrapper<GQLGistCommentEdge>;
  GistConnection: ResolverTypeWrapper<GQLGistConnection>;
  GistEdge: ResolverTypeWrapper<GQLGistEdge>;
  GistFile: ResolverTypeWrapper<GQLGistFile>;
  GistOrder: GQLGistOrder;
  GistOrderField: GQLGistOrderField;
  GistPrivacy: GQLGistPrivacy;
  GitActor: ResolverTypeWrapper<GQLGitActor>;
  GitHubMetadata: ResolverTypeWrapper<GQLGitHubMetadata>;
  GitObject: GQLResolversTypes['Blob'] | GQLResolversTypes['Commit'] | GQLResolversTypes['Tag'] | GQLResolversTypes['Tree'];
  GitObjectID: ResolverTypeWrapper<Scalars['GitObjectID']>;
  GitRefname: ResolverTypeWrapper<Scalars['GitRefname']>;
  GitSSHRemote: ResolverTypeWrapper<Scalars['GitSSHRemote']>;
  GitSignature: GQLResolversTypes['GpgSignature'] | GQLResolversTypes['SmimeSignature'] | GQLResolversTypes['UnknownSignature'];
  GitSignatureState: GQLGitSignatureState;
  GitTimestamp: ResolverTypeWrapper<Scalars['GitTimestamp']>;
  GpgSignature: ResolverTypeWrapper<GQLGpgSignature>;
  HTML: ResolverTypeWrapper<Scalars['HTML']>;
  HeadRefDeletedEvent: ResolverTypeWrapper<GQLHeadRefDeletedEvent>;
  HeadRefForcePushedEvent: ResolverTypeWrapper<GQLHeadRefForcePushedEvent>;
  HeadRefRestoredEvent: ResolverTypeWrapper<GQLHeadRefRestoredEvent>;
  Hovercard: ResolverTypeWrapper<GQLHovercard>;
  HovercardContext: GQLResolversTypes['GenericHovercardContext'] | GQLResolversTypes['OrganizationTeamsHovercardContext'] | GQLResolversTypes['OrganizationsHovercardContext'] | GQLResolversTypes['ReviewStatusHovercardContext'] | GQLResolversTypes['ViewerHovercardContext'];
  IdentityProviderConfigurationState: GQLIdentityProviderConfigurationState;
  ImportProjectInput: GQLImportProjectInput;
  ImportProjectPayload: ResolverTypeWrapper<GQLImportProjectPayload>;
  InviteEnterpriseAdminInput: GQLInviteEnterpriseAdminInput;
  InviteEnterpriseAdminPayload: ResolverTypeWrapper<GQLInviteEnterpriseAdminPayload>;
  IpAllowListEnabledSettingValue: GQLIpAllowListEnabledSettingValue;
  IpAllowListEntry: ResolverTypeWrapper<Omit<GQLIpAllowListEntry, 'owner'> & { owner: GQLResolversTypes['IpAllowListOwner'] }>;
  IpAllowListEntryConnection: ResolverTypeWrapper<GQLIpAllowListEntryConnection>;
  IpAllowListEntryEdge: ResolverTypeWrapper<GQLIpAllowListEntryEdge>;
  IpAllowListEntryOrder: GQLIpAllowListEntryOrder;
  IpAllowListEntryOrderField: GQLIpAllowListEntryOrderField;
  IpAllowListOwner: GQLResolversTypes['Enterprise'] | GQLResolversTypes['Organization'];
  Issue: ResolverTypeWrapper<GQLIssue>;
  IssueComment: ResolverTypeWrapper<GQLIssueComment>;
  IssueCommentConnection: ResolverTypeWrapper<GQLIssueCommentConnection>;
  IssueCommentEdge: ResolverTypeWrapper<GQLIssueCommentEdge>;
  IssueConnection: ResolverTypeWrapper<GQLIssueConnection>;
  IssueContributionsByRepository: ResolverTypeWrapper<GQLIssueContributionsByRepository>;
  IssueEdge: ResolverTypeWrapper<GQLIssueEdge>;
  IssueFilters: GQLIssueFilters;
  IssueOrPullRequest: GQLResolversTypes['Issue'] | GQLResolversTypes['PullRequest'];
  IssueOrder: GQLIssueOrder;
  IssueOrderField: GQLIssueOrderField;
  IssueState: GQLIssueState;
  IssueTimelineConnection: ResolverTypeWrapper<Omit<GQLIssueTimelineConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<GQLResolversTypes['IssueTimelineItem']>>> }>;
  IssueTimelineItem: GQLResolversTypes['AssignedEvent'] | GQLResolversTypes['ClosedEvent'] | GQLResolversTypes['Commit'] | GQLResolversTypes['CrossReferencedEvent'] | GQLResolversTypes['DemilestonedEvent'] | GQLResolversTypes['IssueComment'] | GQLResolversTypes['LabeledEvent'] | GQLResolversTypes['LockedEvent'] | GQLResolversTypes['MilestonedEvent'] | GQLResolversTypes['ReferencedEvent'] | GQLResolversTypes['RenamedTitleEvent'] | GQLResolversTypes['ReopenedEvent'] | GQLResolversTypes['SubscribedEvent'] | GQLResolversTypes['TransferredEvent'] | GQLResolversTypes['UnassignedEvent'] | GQLResolversTypes['UnlabeledEvent'] | GQLResolversTypes['UnlockedEvent'] | GQLResolversTypes['UnsubscribedEvent'] | GQLResolversTypes['UserBlockedEvent'];
  IssueTimelineItemEdge: ResolverTypeWrapper<Omit<GQLIssueTimelineItemEdge, 'node'> & { node?: Maybe<GQLResolversTypes['IssueTimelineItem']> }>;
  IssueTimelineItems: GQLResolversTypes['AddedToProjectEvent'] | GQLResolversTypes['AssignedEvent'] | GQLResolversTypes['ClosedEvent'] | GQLResolversTypes['CommentDeletedEvent'] | GQLResolversTypes['ConnectedEvent'] | GQLResolversTypes['ConvertedNoteToIssueEvent'] | GQLResolversTypes['CrossReferencedEvent'] | GQLResolversTypes['DemilestonedEvent'] | GQLResolversTypes['DisconnectedEvent'] | GQLResolversTypes['IssueComment'] | GQLResolversTypes['LabeledEvent'] | GQLResolversTypes['LockedEvent'] | GQLResolversTypes['MarkedAsDuplicateEvent'] | GQLResolversTypes['MentionedEvent'] | GQLResolversTypes['MilestonedEvent'] | GQLResolversTypes['MovedColumnsInProjectEvent'] | GQLResolversTypes['PinnedEvent'] | GQLResolversTypes['ReferencedEvent'] | GQLResolversTypes['RemovedFromProjectEvent'] | GQLResolversTypes['RenamedTitleEvent'] | GQLResolversTypes['ReopenedEvent'] | GQLResolversTypes['SubscribedEvent'] | GQLResolversTypes['TransferredEvent'] | GQLResolversTypes['UnassignedEvent'] | GQLResolversTypes['UnlabeledEvent'] | GQLResolversTypes['UnlockedEvent'] | GQLResolversTypes['UnmarkedAsDuplicateEvent'] | GQLResolversTypes['UnpinnedEvent'] | GQLResolversTypes['UnsubscribedEvent'] | GQLResolversTypes['UserBlockedEvent'];
  IssueTimelineItemsConnection: ResolverTypeWrapper<Omit<GQLIssueTimelineItemsConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<GQLResolversTypes['IssueTimelineItems']>>> }>;
  IssueTimelineItemsEdge: ResolverTypeWrapper<Omit<GQLIssueTimelineItemsEdge, 'node'> & { node?: Maybe<GQLResolversTypes['IssueTimelineItems']> }>;
  IssueTimelineItemsItemType: GQLIssueTimelineItemsItemType;
  JoinedGitHubContribution: ResolverTypeWrapper<GQLJoinedGitHubContribution>;
  Label: ResolverTypeWrapper<GQLLabel>;
  LabelConnection: ResolverTypeWrapper<GQLLabelConnection>;
  LabelEdge: ResolverTypeWrapper<GQLLabelEdge>;
  LabelOrder: GQLLabelOrder;
  LabelOrderField: GQLLabelOrderField;
  Labelable: GQLResolversTypes['Issue'] | GQLResolversTypes['PullRequest'];
  LabeledEvent: ResolverTypeWrapper<GQLLabeledEvent>;
  Language: ResolverTypeWrapper<GQLLanguage>;
  LanguageConnection: ResolverTypeWrapper<GQLLanguageConnection>;
  LanguageEdge: ResolverTypeWrapper<GQLLanguageEdge>;
  LanguageOrder: GQLLanguageOrder;
  LanguageOrderField: GQLLanguageOrderField;
  License: ResolverTypeWrapper<GQLLicense>;
  LicenseRule: ResolverTypeWrapper<GQLLicenseRule>;
  LinkRepositoryToProjectInput: GQLLinkRepositoryToProjectInput;
  LinkRepositoryToProjectPayload: ResolverTypeWrapper<GQLLinkRepositoryToProjectPayload>;
  LockLockableInput: GQLLockLockableInput;
  LockLockablePayload: ResolverTypeWrapper<GQLLockLockablePayload>;
  LockReason: GQLLockReason;
  Lockable: GQLResolversTypes['Issue'] | GQLResolversTypes['PullRequest'];
  LockedEvent: ResolverTypeWrapper<GQLLockedEvent>;
  Mannequin: ResolverTypeWrapper<GQLMannequin>;
  MarkPullRequestReadyForReviewInput: GQLMarkPullRequestReadyForReviewInput;
  MarkPullRequestReadyForReviewPayload: ResolverTypeWrapper<GQLMarkPullRequestReadyForReviewPayload>;
  MarkedAsDuplicateEvent: ResolverTypeWrapper<GQLMarkedAsDuplicateEvent>;
  MarketplaceCategory: ResolverTypeWrapper<GQLMarketplaceCategory>;
  MarketplaceListing: ResolverTypeWrapper<GQLMarketplaceListing>;
  MarketplaceListingConnection: ResolverTypeWrapper<GQLMarketplaceListingConnection>;
  MarketplaceListingEdge: ResolverTypeWrapper<GQLMarketplaceListingEdge>;
  MemberStatusable: GQLResolversTypes['Organization'] | GQLResolversTypes['Team'];
  MembersCanDeleteReposClearAuditEntry: ResolverTypeWrapper<Omit<GQLMembersCanDeleteReposClearAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  MembersCanDeleteReposDisableAuditEntry: ResolverTypeWrapper<Omit<GQLMembersCanDeleteReposDisableAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  MembersCanDeleteReposEnableAuditEntry: ResolverTypeWrapper<Omit<GQLMembersCanDeleteReposEnableAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  MentionedEvent: ResolverTypeWrapper<GQLMentionedEvent>;
  MergeBranchInput: GQLMergeBranchInput;
  MergeBranchPayload: ResolverTypeWrapper<GQLMergeBranchPayload>;
  MergePullRequestInput: GQLMergePullRequestInput;
  MergePullRequestPayload: ResolverTypeWrapper<GQLMergePullRequestPayload>;
  MergeStateStatus: GQLMergeStateStatus;
  MergeableState: GQLMergeableState;
  MergedEvent: ResolverTypeWrapper<GQLMergedEvent>;
  Milestone: ResolverTypeWrapper<GQLMilestone>;
  MilestoneConnection: ResolverTypeWrapper<GQLMilestoneConnection>;
  MilestoneEdge: ResolverTypeWrapper<GQLMilestoneEdge>;
  MilestoneItem: GQLResolversTypes['Issue'] | GQLResolversTypes['PullRequest'];
  MilestoneOrder: GQLMilestoneOrder;
  MilestoneOrderField: GQLMilestoneOrderField;
  MilestoneState: GQLMilestoneState;
  MilestonedEvent: ResolverTypeWrapper<Omit<GQLMilestonedEvent, 'subject'> & { subject: GQLResolversTypes['MilestoneItem'] }>;
  Minimizable: GQLResolversTypes['CommitComment'] | GQLResolversTypes['GistComment'] | GQLResolversTypes['IssueComment'] | GQLResolversTypes['PullRequestReviewComment'];
  MinimizeCommentInput: GQLMinimizeCommentInput;
  MinimizeCommentPayload: ResolverTypeWrapper<GQLMinimizeCommentPayload>;
  MoveProjectCardInput: GQLMoveProjectCardInput;
  MoveProjectCardPayload: ResolverTypeWrapper<GQLMoveProjectCardPayload>;
  MoveProjectColumnInput: GQLMoveProjectColumnInput;
  MoveProjectColumnPayload: ResolverTypeWrapper<GQLMoveProjectColumnPayload>;
  MovedColumnsInProjectEvent: ResolverTypeWrapper<GQLMovedColumnsInProjectEvent>;
  Mutation: ResolverTypeWrapper<{}>;
  Node: GQLResolversTypes['AddedToProjectEvent'] | GQLResolversTypes['App'] | GQLResolversTypes['AssignedEvent'] | GQLResolversTypes['AutomaticBaseChangeFailedEvent'] | GQLResolversTypes['AutomaticBaseChangeSucceededEvent'] | GQLResolversTypes['BaseRefChangedEvent'] | GQLResolversTypes['BaseRefForcePushedEvent'] | GQLResolversTypes['Blob'] | GQLResolversTypes['Bot'] | GQLResolversTypes['BranchProtectionRule'] | GQLResolversTypes['CheckRun'] | GQLResolversTypes['CheckSuite'] | GQLResolversTypes['ClosedEvent'] | GQLResolversTypes['CodeOfConduct'] | GQLResolversTypes['CommentDeletedEvent'] | GQLResolversTypes['Commit'] | GQLResolversTypes['CommitComment'] | GQLResolversTypes['CommitCommentThread'] | GQLResolversTypes['ConnectedEvent'] | GQLResolversTypes['ConvertToDraftEvent'] | GQLResolversTypes['ConvertedNoteToIssueEvent'] | GQLResolversTypes['CrossReferencedEvent'] | GQLResolversTypes['DemilestonedEvent'] | GQLResolversTypes['DependencyGraphManifest'] | GQLResolversTypes['DeployKey'] | GQLResolversTypes['DeployedEvent'] | GQLResolversTypes['Deployment'] | GQLResolversTypes['DeploymentEnvironmentChangedEvent'] | GQLResolversTypes['DeploymentStatus'] | GQLResolversTypes['DisconnectedEvent'] | GQLResolversTypes['Enterprise'] | GQLResolversTypes['EnterpriseAdministratorInvitation'] | GQLResolversTypes['EnterpriseIdentityProvider'] | GQLResolversTypes['EnterpriseRepositoryInfo'] | GQLResolversTypes['EnterpriseServerInstallation'] | GQLResolversTypes['EnterpriseServerUserAccount'] | GQLResolversTypes['EnterpriseServerUserAccountEmail'] | GQLResolversTypes['EnterpriseServerUserAccountsUpload'] | GQLResolversTypes['EnterpriseUserAccount'] | GQLResolversTypes['ExternalIdentity'] | GQLResolversTypes['Gist'] | GQLResolversTypes['GistComment'] | GQLResolversTypes['HeadRefDeletedEvent'] | GQLResolversTypes['HeadRefForcePushedEvent'] | GQLResolversTypes['HeadRefRestoredEvent'] | GQLResolversTypes['IpAllowListEntry'] | GQLResolversTypes['Issue'] | GQLResolversTypes['IssueComment'] | GQLResolversTypes['Label'] | GQLResolversTypes['LabeledEvent'] | GQLResolversTypes['Language'] | GQLResolversTypes['License'] | GQLResolversTypes['LockedEvent'] | GQLResolversTypes['Mannequin'] | GQLResolversTypes['MarkedAsDuplicateEvent'] | GQLResolversTypes['MarketplaceCategory'] | GQLResolversTypes['MarketplaceListing'] | GQLResolversTypes['MembersCanDeleteReposClearAuditEntry'] | GQLResolversTypes['MembersCanDeleteReposDisableAuditEntry'] | GQLResolversTypes['MembersCanDeleteReposEnableAuditEntry'] | GQLResolversTypes['MentionedEvent'] | GQLResolversTypes['MergedEvent'] | GQLResolversTypes['Milestone'] | GQLResolversTypes['MilestonedEvent'] | GQLResolversTypes['MovedColumnsInProjectEvent'] | GQLResolversTypes['OauthApplicationCreateAuditEntry'] | GQLResolversTypes['OrgAddBillingManagerAuditEntry'] | GQLResolversTypes['OrgAddMemberAuditEntry'] | GQLResolversTypes['OrgBlockUserAuditEntry'] | GQLResolversTypes['OrgConfigDisableCollaboratorsOnlyAuditEntry'] | GQLResolversTypes['OrgConfigEnableCollaboratorsOnlyAuditEntry'] | GQLResolversTypes['OrgCreateAuditEntry'] | GQLResolversTypes['OrgDisableOauthAppRestrictionsAuditEntry'] | GQLResolversTypes['OrgDisableSamlAuditEntry'] | GQLResolversTypes['OrgDisableTwoFactorRequirementAuditEntry'] | GQLResolversTypes['OrgEnableOauthAppRestrictionsAuditEntry'] | GQLResolversTypes['OrgEnableSamlAuditEntry'] | GQLResolversTypes['OrgEnableTwoFactorRequirementAuditEntry'] | GQLResolversTypes['OrgInviteMemberAuditEntry'] | GQLResolversTypes['OrgInviteToBusinessAuditEntry'] | GQLResolversTypes['OrgOauthAppAccessApprovedAuditEntry'] | GQLResolversTypes['OrgOauthAppAccessDeniedAuditEntry'] | GQLResolversTypes['OrgOauthAppAccessRequestedAuditEntry'] | GQLResolversTypes['OrgRemoveBillingManagerAuditEntry'] | GQLResolversTypes['OrgRemoveMemberAuditEntry'] | GQLResolversTypes['OrgRemoveOutsideCollaboratorAuditEntry'] | GQLResolversTypes['OrgRestoreMemberAuditEntry'] | GQLResolversTypes['OrgUnblockUserAuditEntry'] | GQLResolversTypes['OrgUpdateDefaultRepositoryPermissionAuditEntry'] | GQLResolversTypes['OrgUpdateMemberAuditEntry'] | GQLResolversTypes['OrgUpdateMemberRepositoryCreationPermissionAuditEntry'] | GQLResolversTypes['OrgUpdateMemberRepositoryInvitationPermissionAuditEntry'] | GQLResolversTypes['Organization'] | GQLResolversTypes['OrganizationIdentityProvider'] | GQLResolversTypes['OrganizationInvitation'] | GQLResolversTypes['Package'] | GQLResolversTypes['PackageFile'] | GQLResolversTypes['PackageTag'] | GQLResolversTypes['PackageVersion'] | GQLResolversTypes['PinnedEvent'] | GQLResolversTypes['PinnedIssue'] | GQLResolversTypes['PrivateRepositoryForkingDisableAuditEntry'] | GQLResolversTypes['PrivateRepositoryForkingEnableAuditEntry'] | GQLResolversTypes['Project'] | GQLResolversTypes['ProjectCard'] | GQLResolversTypes['ProjectColumn'] | GQLResolversTypes['PublicKey'] | GQLResolversTypes['PullRequest'] | GQLResolversTypes['PullRequestCommit'] | GQLResolversTypes['PullRequestCommitCommentThread'] | GQLResolversTypes['PullRequestReview'] | GQLResolversTypes['PullRequestReviewComment'] | GQLResolversTypes['PullRequestReviewThread'] | GQLResolversTypes['Push'] | GQLResolversTypes['PushAllowance'] | GQLResolversTypes['Reaction'] | GQLResolversTypes['ReadyForReviewEvent'] | GQLResolversTypes['Ref'] | GQLResolversTypes['ReferencedEvent'] | GQLResolversTypes['RegistryPackage'] | GQLResolversTypes['RegistryPackageDependency'] | GQLResolversTypes['RegistryPackageFile'] | GQLResolversTypes['RegistryPackageTag'] | GQLResolversTypes['RegistryPackageVersion'] | GQLResolversTypes['Release'] | GQLResolversTypes['ReleaseAsset'] | GQLResolversTypes['RemovedFromProjectEvent'] | GQLResolversTypes['RenamedTitleEvent'] | GQLResolversTypes['ReopenedEvent'] | GQLResolversTypes['RepoAccessAuditEntry'] | GQLResolversTypes['RepoAddMemberAuditEntry'] | GQLResolversTypes['RepoAddTopicAuditEntry'] | GQLResolversTypes['RepoArchivedAuditEntry'] | GQLResolversTypes['RepoChangeMergeSettingAuditEntry'] | GQLResolversTypes['RepoConfigDisableAnonymousGitAccessAuditEntry'] | GQLResolversTypes['RepoConfigDisableCollaboratorsOnlyAuditEntry'] | GQLResolversTypes['RepoConfigDisableContributorsOnlyAuditEntry'] | GQLResolversTypes['RepoConfigDisableSockpuppetDisallowedAuditEntry'] | GQLResolversTypes['RepoConfigEnableAnonymousGitAccessAuditEntry'] | GQLResolversTypes['RepoConfigEnableCollaboratorsOnlyAuditEntry'] | GQLResolversTypes['RepoConfigEnableContributorsOnlyAuditEntry'] | GQLResolversTypes['RepoConfigEnableSockpuppetDisallowedAuditEntry'] | GQLResolversTypes['RepoConfigLockAnonymousGitAccessAuditEntry'] | GQLResolversTypes['RepoConfigUnlockAnonymousGitAccessAuditEntry'] | GQLResolversTypes['RepoCreateAuditEntry'] | GQLResolversTypes['RepoDestroyAuditEntry'] | GQLResolversTypes['RepoRemoveMemberAuditEntry'] | GQLResolversTypes['RepoRemoveTopicAuditEntry'] | GQLResolversTypes['Repository'] | GQLResolversTypes['RepositoryInvitation'] | GQLResolversTypes['RepositoryTopic'] | GQLResolversTypes['RepositoryVisibilityChangeDisableAuditEntry'] | GQLResolversTypes['RepositoryVisibilityChangeEnableAuditEntry'] | GQLResolversTypes['RepositoryVulnerabilityAlert'] | GQLResolversTypes['ReviewDismissalAllowance'] | GQLResolversTypes['ReviewDismissedEvent'] | GQLResolversTypes['ReviewRequest'] | GQLResolversTypes['ReviewRequestRemovedEvent'] | GQLResolversTypes['ReviewRequestedEvent'] | GQLResolversTypes['SavedReply'] | GQLResolversTypes['SecurityAdvisory'] | GQLResolversTypes['SponsorsListing'] | GQLResolversTypes['SponsorsTier'] | GQLResolversTypes['Sponsorship'] | GQLResolversTypes['Status'] | GQLResolversTypes['StatusCheckRollup'] | GQLResolversTypes['StatusContext'] | GQLResolversTypes['SubscribedEvent'] | GQLResolversTypes['Tag'] | GQLResolversTypes['Team'] | GQLResolversTypes['TeamAddMemberAuditEntry'] | GQLResolversTypes['TeamAddRepositoryAuditEntry'] | GQLResolversTypes['TeamChangeParentTeamAuditEntry'] | GQLResolversTypes['TeamDiscussion'] | GQLResolversTypes['TeamDiscussionComment'] | GQLResolversTypes['TeamRemoveMemberAuditEntry'] | GQLResolversTypes['TeamRemoveRepositoryAuditEntry'] | GQLResolversTypes['Topic'] | GQLResolversTypes['TransferredEvent'] | GQLResolversTypes['Tree'] | GQLResolversTypes['UnassignedEvent'] | GQLResolversTypes['UnlabeledEvent'] | GQLResolversTypes['UnlockedEvent'] | GQLResolversTypes['UnmarkedAsDuplicateEvent'] | GQLResolversTypes['UnpinnedEvent'] | GQLResolversTypes['UnsubscribedEvent'] | GQLResolversTypes['User'] | GQLResolversTypes['UserBlockedEvent'] | GQLResolversTypes['UserContentEdit'] | GQLResolversTypes['UserStatus'];
  OauthApplicationAuditEntryData: GQLResolversTypes['OauthApplicationCreateAuditEntry'] | GQLResolversTypes['OrgOauthAppAccessApprovedAuditEntry'] | GQLResolversTypes['OrgOauthAppAccessDeniedAuditEntry'] | GQLResolversTypes['OrgOauthAppAccessRequestedAuditEntry'];
  OauthApplicationCreateAuditEntry: ResolverTypeWrapper<Omit<GQLOauthApplicationCreateAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OauthApplicationCreateAuditEntryState: GQLOauthApplicationCreateAuditEntryState;
  OperationType: GQLOperationType;
  OrderDirection: GQLOrderDirection;
  OrgAddBillingManagerAuditEntry: ResolverTypeWrapper<Omit<GQLOrgAddBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OrgAddMemberAuditEntry: ResolverTypeWrapper<Omit<GQLOrgAddMemberAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OrgAddMemberAuditEntryPermission: GQLOrgAddMemberAuditEntryPermission;
  OrgBlockUserAuditEntry: ResolverTypeWrapper<Omit<GQLOrgBlockUserAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OrgConfigDisableCollaboratorsOnlyAuditEntry: ResolverTypeWrapper<Omit<GQLOrgConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OrgConfigEnableCollaboratorsOnlyAuditEntry: ResolverTypeWrapper<Omit<GQLOrgConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OrgCreateAuditEntry: ResolverTypeWrapper<Omit<GQLOrgCreateAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OrgCreateAuditEntryBillingPlan: GQLOrgCreateAuditEntryBillingPlan;
  OrgDisableOauthAppRestrictionsAuditEntry: ResolverTypeWrapper<Omit<GQLOrgDisableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OrgDisableSamlAuditEntry: ResolverTypeWrapper<Omit<GQLOrgDisableSamlAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OrgDisableTwoFactorRequirementAuditEntry: ResolverTypeWrapper<Omit<GQLOrgDisableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OrgEnableOauthAppRestrictionsAuditEntry: ResolverTypeWrapper<Omit<GQLOrgEnableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OrgEnableSamlAuditEntry: ResolverTypeWrapper<Omit<GQLOrgEnableSamlAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OrgEnableTwoFactorRequirementAuditEntry: ResolverTypeWrapper<Omit<GQLOrgEnableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OrgInviteMemberAuditEntry: ResolverTypeWrapper<Omit<GQLOrgInviteMemberAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OrgInviteToBusinessAuditEntry: ResolverTypeWrapper<Omit<GQLOrgInviteToBusinessAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OrgOauthAppAccessApprovedAuditEntry: ResolverTypeWrapper<Omit<GQLOrgOauthAppAccessApprovedAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OrgOauthAppAccessDeniedAuditEntry: ResolverTypeWrapper<Omit<GQLOrgOauthAppAccessDeniedAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OrgOauthAppAccessRequestedAuditEntry: ResolverTypeWrapper<Omit<GQLOrgOauthAppAccessRequestedAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OrgRemoveBillingManagerAuditEntry: ResolverTypeWrapper<Omit<GQLOrgRemoveBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OrgRemoveBillingManagerAuditEntryReason: GQLOrgRemoveBillingManagerAuditEntryReason;
  OrgRemoveMemberAuditEntry: ResolverTypeWrapper<Omit<GQLOrgRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OrgRemoveMemberAuditEntryMembershipType: GQLOrgRemoveMemberAuditEntryMembershipType;
  OrgRemoveMemberAuditEntryReason: GQLOrgRemoveMemberAuditEntryReason;
  OrgRemoveOutsideCollaboratorAuditEntry: ResolverTypeWrapper<Omit<GQLOrgRemoveOutsideCollaboratorAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OrgRemoveOutsideCollaboratorAuditEntryMembershipType: GQLOrgRemoveOutsideCollaboratorAuditEntryMembershipType;
  OrgRemoveOutsideCollaboratorAuditEntryReason: GQLOrgRemoveOutsideCollaboratorAuditEntryReason;
  OrgRestoreMemberAuditEntry: ResolverTypeWrapper<Omit<GQLOrgRestoreMemberAuditEntry, 'actor' | 'restoredMemberships'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']>, restoredMemberships?: Maybe<Array<GQLResolversTypes['OrgRestoreMemberAuditEntryMembership']>> }>;
  OrgRestoreMemberAuditEntryMembership: GQLResolversTypes['OrgRestoreMemberMembershipOrganizationAuditEntryData'] | GQLResolversTypes['OrgRestoreMemberMembershipRepositoryAuditEntryData'] | GQLResolversTypes['OrgRestoreMemberMembershipTeamAuditEntryData'];
  OrgRestoreMemberMembershipOrganizationAuditEntryData: ResolverTypeWrapper<GQLOrgRestoreMemberMembershipOrganizationAuditEntryData>;
  OrgRestoreMemberMembershipRepositoryAuditEntryData: ResolverTypeWrapper<GQLOrgRestoreMemberMembershipRepositoryAuditEntryData>;
  OrgRestoreMemberMembershipTeamAuditEntryData: ResolverTypeWrapper<GQLOrgRestoreMemberMembershipTeamAuditEntryData>;
  OrgUnblockUserAuditEntry: ResolverTypeWrapper<Omit<GQLOrgUnblockUserAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OrgUpdateDefaultRepositoryPermissionAuditEntry: ResolverTypeWrapper<Omit<GQLOrgUpdateDefaultRepositoryPermissionAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OrgUpdateDefaultRepositoryPermissionAuditEntryPermission: GQLOrgUpdateDefaultRepositoryPermissionAuditEntryPermission;
  OrgUpdateMemberAuditEntry: ResolverTypeWrapper<Omit<GQLOrgUpdateMemberAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OrgUpdateMemberAuditEntryPermission: GQLOrgUpdateMemberAuditEntryPermission;
  OrgUpdateMemberRepositoryCreationPermissionAuditEntry: ResolverTypeWrapper<Omit<GQLOrgUpdateMemberRepositoryCreationPermissionAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility: GQLOrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility;
  OrgUpdateMemberRepositoryInvitationPermissionAuditEntry: ResolverTypeWrapper<Omit<GQLOrgUpdateMemberRepositoryInvitationPermissionAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  Organization: ResolverTypeWrapper<GQLOrganization>;
  OrganizationAuditEntry: GQLResolversTypes['MembersCanDeleteReposClearAuditEntry'] | GQLResolversTypes['MembersCanDeleteReposDisableAuditEntry'] | GQLResolversTypes['MembersCanDeleteReposEnableAuditEntry'] | GQLResolversTypes['OauthApplicationCreateAuditEntry'] | GQLResolversTypes['OrgAddBillingManagerAuditEntry'] | GQLResolversTypes['OrgAddMemberAuditEntry'] | GQLResolversTypes['OrgBlockUserAuditEntry'] | GQLResolversTypes['OrgConfigDisableCollaboratorsOnlyAuditEntry'] | GQLResolversTypes['OrgConfigEnableCollaboratorsOnlyAuditEntry'] | GQLResolversTypes['OrgCreateAuditEntry'] | GQLResolversTypes['OrgDisableOauthAppRestrictionsAuditEntry'] | GQLResolversTypes['OrgDisableSamlAuditEntry'] | GQLResolversTypes['OrgDisableTwoFactorRequirementAuditEntry'] | GQLResolversTypes['OrgEnableOauthAppRestrictionsAuditEntry'] | GQLResolversTypes['OrgEnableSamlAuditEntry'] | GQLResolversTypes['OrgEnableTwoFactorRequirementAuditEntry'] | GQLResolversTypes['OrgInviteMemberAuditEntry'] | GQLResolversTypes['OrgInviteToBusinessAuditEntry'] | GQLResolversTypes['OrgOauthAppAccessApprovedAuditEntry'] | GQLResolversTypes['OrgOauthAppAccessDeniedAuditEntry'] | GQLResolversTypes['OrgOauthAppAccessRequestedAuditEntry'] | GQLResolversTypes['OrgRemoveBillingManagerAuditEntry'] | GQLResolversTypes['OrgRemoveMemberAuditEntry'] | GQLResolversTypes['OrgRemoveOutsideCollaboratorAuditEntry'] | GQLResolversTypes['OrgRestoreMemberAuditEntry'] | GQLResolversTypes['OrgUnblockUserAuditEntry'] | GQLResolversTypes['OrgUpdateDefaultRepositoryPermissionAuditEntry'] | GQLResolversTypes['OrgUpdateMemberAuditEntry'] | GQLResolversTypes['OrgUpdateMemberRepositoryCreationPermissionAuditEntry'] | GQLResolversTypes['OrgUpdateMemberRepositoryInvitationPermissionAuditEntry'] | GQLResolversTypes['PrivateRepositoryForkingDisableAuditEntry'] | GQLResolversTypes['PrivateRepositoryForkingEnableAuditEntry'] | GQLResolversTypes['RepoAccessAuditEntry'] | GQLResolversTypes['RepoAddMemberAuditEntry'] | GQLResolversTypes['RepoAddTopicAuditEntry'] | GQLResolversTypes['RepoArchivedAuditEntry'] | GQLResolversTypes['RepoChangeMergeSettingAuditEntry'] | GQLResolversTypes['RepoConfigDisableAnonymousGitAccessAuditEntry'] | GQLResolversTypes['RepoConfigDisableCollaboratorsOnlyAuditEntry'] | GQLResolversTypes['RepoConfigDisableContributorsOnlyAuditEntry'] | GQLResolversTypes['RepoConfigDisableSockpuppetDisallowedAuditEntry'] | GQLResolversTypes['RepoConfigEnableAnonymousGitAccessAuditEntry'] | GQLResolversTypes['RepoConfigEnableCollaboratorsOnlyAuditEntry'] | GQLResolversTypes['RepoConfigEnableContributorsOnlyAuditEntry'] | GQLResolversTypes['RepoConfigEnableSockpuppetDisallowedAuditEntry'] | GQLResolversTypes['RepoConfigLockAnonymousGitAccessAuditEntry'] | GQLResolversTypes['RepoConfigUnlockAnonymousGitAccessAuditEntry'] | GQLResolversTypes['RepoCreateAuditEntry'] | GQLResolversTypes['RepoDestroyAuditEntry'] | GQLResolversTypes['RepoRemoveMemberAuditEntry'] | GQLResolversTypes['RepoRemoveTopicAuditEntry'] | GQLResolversTypes['RepositoryVisibilityChangeDisableAuditEntry'] | GQLResolversTypes['RepositoryVisibilityChangeEnableAuditEntry'] | GQLResolversTypes['TeamAddMemberAuditEntry'] | GQLResolversTypes['TeamAddRepositoryAuditEntry'] | GQLResolversTypes['TeamChangeParentTeamAuditEntry'] | GQLResolversTypes['TeamRemoveMemberAuditEntry'] | GQLResolversTypes['TeamRemoveRepositoryAuditEntry'];
  OrganizationAuditEntryConnection: ResolverTypeWrapper<Omit<GQLOrganizationAuditEntryConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<GQLResolversTypes['OrganizationAuditEntry']>>> }>;
  OrganizationAuditEntryData: GQLResolversTypes['MembersCanDeleteReposClearAuditEntry'] | GQLResolversTypes['MembersCanDeleteReposDisableAuditEntry'] | GQLResolversTypes['MembersCanDeleteReposEnableAuditEntry'] | GQLResolversTypes['OauthApplicationCreateAuditEntry'] | GQLResolversTypes['OrgAddBillingManagerAuditEntry'] | GQLResolversTypes['OrgAddMemberAuditEntry'] | GQLResolversTypes['OrgBlockUserAuditEntry'] | GQLResolversTypes['OrgConfigDisableCollaboratorsOnlyAuditEntry'] | GQLResolversTypes['OrgConfigEnableCollaboratorsOnlyAuditEntry'] | GQLResolversTypes['OrgCreateAuditEntry'] | GQLResolversTypes['OrgDisableOauthAppRestrictionsAuditEntry'] | GQLResolversTypes['OrgDisableSamlAuditEntry'] | GQLResolversTypes['OrgDisableTwoFactorRequirementAuditEntry'] | GQLResolversTypes['OrgEnableOauthAppRestrictionsAuditEntry'] | GQLResolversTypes['OrgEnableSamlAuditEntry'] | GQLResolversTypes['OrgEnableTwoFactorRequirementAuditEntry'] | GQLResolversTypes['OrgInviteMemberAuditEntry'] | GQLResolversTypes['OrgInviteToBusinessAuditEntry'] | GQLResolversTypes['OrgOauthAppAccessApprovedAuditEntry'] | GQLResolversTypes['OrgOauthAppAccessDeniedAuditEntry'] | GQLResolversTypes['OrgOauthAppAccessRequestedAuditEntry'] | GQLResolversTypes['OrgRemoveBillingManagerAuditEntry'] | GQLResolversTypes['OrgRemoveMemberAuditEntry'] | GQLResolversTypes['OrgRemoveOutsideCollaboratorAuditEntry'] | GQLResolversTypes['OrgRestoreMemberAuditEntry'] | GQLResolversTypes['OrgRestoreMemberMembershipOrganizationAuditEntryData'] | GQLResolversTypes['OrgUnblockUserAuditEntry'] | GQLResolversTypes['OrgUpdateDefaultRepositoryPermissionAuditEntry'] | GQLResolversTypes['OrgUpdateMemberAuditEntry'] | GQLResolversTypes['OrgUpdateMemberRepositoryCreationPermissionAuditEntry'] | GQLResolversTypes['OrgUpdateMemberRepositoryInvitationPermissionAuditEntry'] | GQLResolversTypes['PrivateRepositoryForkingDisableAuditEntry'] | GQLResolversTypes['PrivateRepositoryForkingEnableAuditEntry'] | GQLResolversTypes['RepoAccessAuditEntry'] | GQLResolversTypes['RepoAddMemberAuditEntry'] | GQLResolversTypes['RepoAddTopicAuditEntry'] | GQLResolversTypes['RepoArchivedAuditEntry'] | GQLResolversTypes['RepoChangeMergeSettingAuditEntry'] | GQLResolversTypes['RepoConfigDisableAnonymousGitAccessAuditEntry'] | GQLResolversTypes['RepoConfigDisableCollaboratorsOnlyAuditEntry'] | GQLResolversTypes['RepoConfigDisableContributorsOnlyAuditEntry'] | GQLResolversTypes['RepoConfigDisableSockpuppetDisallowedAuditEntry'] | GQLResolversTypes['RepoConfigEnableAnonymousGitAccessAuditEntry'] | GQLResolversTypes['RepoConfigEnableCollaboratorsOnlyAuditEntry'] | GQLResolversTypes['RepoConfigEnableContributorsOnlyAuditEntry'] | GQLResolversTypes['RepoConfigEnableSockpuppetDisallowedAuditEntry'] | GQLResolversTypes['RepoConfigLockAnonymousGitAccessAuditEntry'] | GQLResolversTypes['RepoConfigUnlockAnonymousGitAccessAuditEntry'] | GQLResolversTypes['RepoCreateAuditEntry'] | GQLResolversTypes['RepoDestroyAuditEntry'] | GQLResolversTypes['RepoRemoveMemberAuditEntry'] | GQLResolversTypes['RepoRemoveTopicAuditEntry'] | GQLResolversTypes['RepositoryVisibilityChangeDisableAuditEntry'] | GQLResolversTypes['RepositoryVisibilityChangeEnableAuditEntry'] | GQLResolversTypes['TeamAddMemberAuditEntry'] | GQLResolversTypes['TeamAddRepositoryAuditEntry'] | GQLResolversTypes['TeamChangeParentTeamAuditEntry'] | GQLResolversTypes['TeamRemoveMemberAuditEntry'] | GQLResolversTypes['TeamRemoveRepositoryAuditEntry'];
  OrganizationAuditEntryEdge: ResolverTypeWrapper<Omit<GQLOrganizationAuditEntryEdge, 'node'> & { node?: Maybe<GQLResolversTypes['OrganizationAuditEntry']> }>;
  OrganizationConnection: ResolverTypeWrapper<GQLOrganizationConnection>;
  OrganizationEdge: ResolverTypeWrapper<GQLOrganizationEdge>;
  OrganizationIdentityProvider: ResolverTypeWrapper<GQLOrganizationIdentityProvider>;
  OrganizationInvitation: ResolverTypeWrapper<GQLOrganizationInvitation>;
  OrganizationInvitationConnection: ResolverTypeWrapper<GQLOrganizationInvitationConnection>;
  OrganizationInvitationEdge: ResolverTypeWrapper<GQLOrganizationInvitationEdge>;
  OrganizationInvitationRole: GQLOrganizationInvitationRole;
  OrganizationInvitationType: GQLOrganizationInvitationType;
  OrganizationMemberConnection: ResolverTypeWrapper<GQLOrganizationMemberConnection>;
  OrganizationMemberEdge: ResolverTypeWrapper<GQLOrganizationMemberEdge>;
  OrganizationMemberRole: GQLOrganizationMemberRole;
  OrganizationMembersCanCreateRepositoriesSettingValue: GQLOrganizationMembersCanCreateRepositoriesSettingValue;
  OrganizationOrder: GQLOrganizationOrder;
  OrganizationOrderField: GQLOrganizationOrderField;
  OrganizationTeamsHovercardContext: ResolverTypeWrapper<GQLOrganizationTeamsHovercardContext>;
  OrganizationsHovercardContext: ResolverTypeWrapper<GQLOrganizationsHovercardContext>;
  Package: ResolverTypeWrapper<GQLPackage>;
  PackageConnection: ResolverTypeWrapper<GQLPackageConnection>;
  PackageEdge: ResolverTypeWrapper<GQLPackageEdge>;
  PackageFile: ResolverTypeWrapper<GQLPackageFile>;
  PackageFileConnection: ResolverTypeWrapper<GQLPackageFileConnection>;
  PackageFileEdge: ResolverTypeWrapper<GQLPackageFileEdge>;
  PackageFileOrder: GQLPackageFileOrder;
  PackageFileOrderField: GQLPackageFileOrderField;
  PackageOrder: GQLPackageOrder;
  PackageOrderField: GQLPackageOrderField;
  PackageOwner: GQLResolversTypes['Organization'] | GQLResolversTypes['Repository'] | GQLResolversTypes['User'];
  PackageStatistics: ResolverTypeWrapper<GQLPackageStatistics>;
  PackageTag: ResolverTypeWrapper<GQLPackageTag>;
  PackageType: GQLPackageType;
  PackageVersion: ResolverTypeWrapper<GQLPackageVersion>;
  PackageVersionConnection: ResolverTypeWrapper<GQLPackageVersionConnection>;
  PackageVersionEdge: ResolverTypeWrapper<GQLPackageVersionEdge>;
  PackageVersionOrder: GQLPackageVersionOrder;
  PackageVersionOrderField: GQLPackageVersionOrderField;
  PackageVersionStatistics: ResolverTypeWrapper<GQLPackageVersionStatistics>;
  PageInfo: ResolverTypeWrapper<GQLPageInfo>;
  PermissionGranter: GQLResolversTypes['Organization'] | GQLResolversTypes['Repository'] | GQLResolversTypes['Team'];
  PermissionSource: ResolverTypeWrapper<Omit<GQLPermissionSource, 'source'> & { source: GQLResolversTypes['PermissionGranter'] }>;
  PinIssueInput: GQLPinIssueInput;
  PinIssuePayload: ResolverTypeWrapper<GQLPinIssuePayload>;
  PinnableItem: GQLResolversTypes['Gist'] | GQLResolversTypes['Repository'];
  PinnableItemConnection: ResolverTypeWrapper<Omit<GQLPinnableItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<GQLResolversTypes['PinnableItem']>>> }>;
  PinnableItemEdge: ResolverTypeWrapper<Omit<GQLPinnableItemEdge, 'node'> & { node?: Maybe<GQLResolversTypes['PinnableItem']> }>;
  PinnableItemType: GQLPinnableItemType;
  PinnedEvent: ResolverTypeWrapper<GQLPinnedEvent>;
  PinnedIssue: ResolverTypeWrapper<GQLPinnedIssue>;
  PinnedIssueConnection: ResolverTypeWrapper<GQLPinnedIssueConnection>;
  PinnedIssueEdge: ResolverTypeWrapper<GQLPinnedIssueEdge>;
  PreciseDateTime: ResolverTypeWrapper<Scalars['PreciseDateTime']>;
  PrivateRepositoryForkingDisableAuditEntry: ResolverTypeWrapper<Omit<GQLPrivateRepositoryForkingDisableAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  PrivateRepositoryForkingEnableAuditEntry: ResolverTypeWrapper<Omit<GQLPrivateRepositoryForkingEnableAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  ProfileItemShowcase: ResolverTypeWrapper<GQLProfileItemShowcase>;
  ProfileOwner: GQLResolversTypes['Organization'] | GQLResolversTypes['User'];
  Project: ResolverTypeWrapper<GQLProject>;
  ProjectCard: ResolverTypeWrapper<Omit<GQLProjectCard, 'content'> & { content?: Maybe<GQLResolversTypes['ProjectCardItem']> }>;
  ProjectCardArchivedState: GQLProjectCardArchivedState;
  ProjectCardConnection: ResolverTypeWrapper<GQLProjectCardConnection>;
  ProjectCardEdge: ResolverTypeWrapper<GQLProjectCardEdge>;
  ProjectCardImport: GQLProjectCardImport;
  ProjectCardItem: GQLResolversTypes['Issue'] | GQLResolversTypes['PullRequest'];
  ProjectCardState: GQLProjectCardState;
  ProjectColumn: ResolverTypeWrapper<GQLProjectColumn>;
  ProjectColumnConnection: ResolverTypeWrapper<GQLProjectColumnConnection>;
  ProjectColumnEdge: ResolverTypeWrapper<GQLProjectColumnEdge>;
  ProjectColumnImport: GQLProjectColumnImport;
  ProjectColumnPurpose: GQLProjectColumnPurpose;
  ProjectConnection: ResolverTypeWrapper<GQLProjectConnection>;
  ProjectEdge: ResolverTypeWrapper<GQLProjectEdge>;
  ProjectOrder: GQLProjectOrder;
  ProjectOrderField: GQLProjectOrderField;
  ProjectOwner: GQLResolversTypes['Organization'] | GQLResolversTypes['Repository'] | GQLResolversTypes['User'];
  ProjectState: GQLProjectState;
  ProjectTemplate: GQLProjectTemplate;
  PublicKey: ResolverTypeWrapper<GQLPublicKey>;
  PublicKeyConnection: ResolverTypeWrapper<GQLPublicKeyConnection>;
  PublicKeyEdge: ResolverTypeWrapper<GQLPublicKeyEdge>;
  PullRequest: ResolverTypeWrapper<GQLPullRequest>;
  PullRequestChangedFile: ResolverTypeWrapper<GQLPullRequestChangedFile>;
  PullRequestChangedFileConnection: ResolverTypeWrapper<GQLPullRequestChangedFileConnection>;
  PullRequestChangedFileEdge: ResolverTypeWrapper<GQLPullRequestChangedFileEdge>;
  PullRequestCommit: ResolverTypeWrapper<GQLPullRequestCommit>;
  PullRequestCommitCommentThread: ResolverTypeWrapper<GQLPullRequestCommitCommentThread>;
  PullRequestCommitConnection: ResolverTypeWrapper<GQLPullRequestCommitConnection>;
  PullRequestCommitEdge: ResolverTypeWrapper<GQLPullRequestCommitEdge>;
  PullRequestConnection: ResolverTypeWrapper<GQLPullRequestConnection>;
  PullRequestContributionsByRepository: ResolverTypeWrapper<GQLPullRequestContributionsByRepository>;
  PullRequestEdge: ResolverTypeWrapper<GQLPullRequestEdge>;
  PullRequestMergeMethod: GQLPullRequestMergeMethod;
  PullRequestOrder: GQLPullRequestOrder;
  PullRequestOrderField: GQLPullRequestOrderField;
  PullRequestReview: ResolverTypeWrapper<GQLPullRequestReview>;
  PullRequestReviewComment: ResolverTypeWrapper<GQLPullRequestReviewComment>;
  PullRequestReviewCommentConnection: ResolverTypeWrapper<GQLPullRequestReviewCommentConnection>;
  PullRequestReviewCommentEdge: ResolverTypeWrapper<GQLPullRequestReviewCommentEdge>;
  PullRequestReviewCommentState: GQLPullRequestReviewCommentState;
  PullRequestReviewConnection: ResolverTypeWrapper<GQLPullRequestReviewConnection>;
  PullRequestReviewContributionsByRepository: ResolverTypeWrapper<GQLPullRequestReviewContributionsByRepository>;
  PullRequestReviewDecision: GQLPullRequestReviewDecision;
  PullRequestReviewEdge: ResolverTypeWrapper<GQLPullRequestReviewEdge>;
  PullRequestReviewEvent: GQLPullRequestReviewEvent;
  PullRequestReviewState: GQLPullRequestReviewState;
  PullRequestReviewThread: ResolverTypeWrapper<GQLPullRequestReviewThread>;
  PullRequestReviewThreadConnection: ResolverTypeWrapper<GQLPullRequestReviewThreadConnection>;
  PullRequestReviewThreadEdge: ResolverTypeWrapper<GQLPullRequestReviewThreadEdge>;
  PullRequestRevisionMarker: ResolverTypeWrapper<GQLPullRequestRevisionMarker>;
  PullRequestState: GQLPullRequestState;
  PullRequestTimelineConnection: ResolverTypeWrapper<Omit<GQLPullRequestTimelineConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<GQLResolversTypes['PullRequestTimelineItem']>>> }>;
  PullRequestTimelineItem: GQLResolversTypes['AssignedEvent'] | GQLResolversTypes['BaseRefForcePushedEvent'] | GQLResolversTypes['ClosedEvent'] | GQLResolversTypes['Commit'] | GQLResolversTypes['CommitCommentThread'] | GQLResolversTypes['CrossReferencedEvent'] | GQLResolversTypes['DemilestonedEvent'] | GQLResolversTypes['DeployedEvent'] | GQLResolversTypes['DeploymentEnvironmentChangedEvent'] | GQLResolversTypes['HeadRefDeletedEvent'] | GQLResolversTypes['HeadRefForcePushedEvent'] | GQLResolversTypes['HeadRefRestoredEvent'] | GQLResolversTypes['IssueComment'] | GQLResolversTypes['LabeledEvent'] | GQLResolversTypes['LockedEvent'] | GQLResolversTypes['MergedEvent'] | GQLResolversTypes['MilestonedEvent'] | GQLResolversTypes['PullRequestReview'] | GQLResolversTypes['PullRequestReviewComment'] | GQLResolversTypes['PullRequestReviewThread'] | GQLResolversTypes['ReferencedEvent'] | GQLResolversTypes['RenamedTitleEvent'] | GQLResolversTypes['ReopenedEvent'] | GQLResolversTypes['ReviewDismissedEvent'] | GQLResolversTypes['ReviewRequestRemovedEvent'] | GQLResolversTypes['ReviewRequestedEvent'] | GQLResolversTypes['SubscribedEvent'] | GQLResolversTypes['UnassignedEvent'] | GQLResolversTypes['UnlabeledEvent'] | GQLResolversTypes['UnlockedEvent'] | GQLResolversTypes['UnsubscribedEvent'] | GQLResolversTypes['UserBlockedEvent'];
  PullRequestTimelineItemEdge: ResolverTypeWrapper<Omit<GQLPullRequestTimelineItemEdge, 'node'> & { node?: Maybe<GQLResolversTypes['PullRequestTimelineItem']> }>;
  PullRequestTimelineItems: GQLResolversTypes['AddedToProjectEvent'] | GQLResolversTypes['AssignedEvent'] | GQLResolversTypes['AutomaticBaseChangeFailedEvent'] | GQLResolversTypes['AutomaticBaseChangeSucceededEvent'] | GQLResolversTypes['BaseRefChangedEvent'] | GQLResolversTypes['BaseRefForcePushedEvent'] | GQLResolversTypes['ClosedEvent'] | GQLResolversTypes['CommentDeletedEvent'] | GQLResolversTypes['ConnectedEvent'] | GQLResolversTypes['ConvertToDraftEvent'] | GQLResolversTypes['ConvertedNoteToIssueEvent'] | GQLResolversTypes['CrossReferencedEvent'] | GQLResolversTypes['DemilestonedEvent'] | GQLResolversTypes['DeployedEvent'] | GQLResolversTypes['DeploymentEnvironmentChangedEvent'] | GQLResolversTypes['DisconnectedEvent'] | GQLResolversTypes['HeadRefDeletedEvent'] | GQLResolversTypes['HeadRefForcePushedEvent'] | GQLResolversTypes['HeadRefRestoredEvent'] | GQLResolversTypes['IssueComment'] | GQLResolversTypes['LabeledEvent'] | GQLResolversTypes['LockedEvent'] | GQLResolversTypes['MarkedAsDuplicateEvent'] | GQLResolversTypes['MentionedEvent'] | GQLResolversTypes['MergedEvent'] | GQLResolversTypes['MilestonedEvent'] | GQLResolversTypes['MovedColumnsInProjectEvent'] | GQLResolversTypes['PinnedEvent'] | GQLResolversTypes['PullRequestCommit'] | GQLResolversTypes['PullRequestCommitCommentThread'] | GQLResolversTypes['PullRequestReview'] | GQLResolversTypes['PullRequestReviewThread'] | GQLResolversTypes['PullRequestRevisionMarker'] | GQLResolversTypes['ReadyForReviewEvent'] | GQLResolversTypes['ReferencedEvent'] | GQLResolversTypes['RemovedFromProjectEvent'] | GQLResolversTypes['RenamedTitleEvent'] | GQLResolversTypes['ReopenedEvent'] | GQLResolversTypes['ReviewDismissedEvent'] | GQLResolversTypes['ReviewRequestRemovedEvent'] | GQLResolversTypes['ReviewRequestedEvent'] | GQLResolversTypes['SubscribedEvent'] | GQLResolversTypes['TransferredEvent'] | GQLResolversTypes['UnassignedEvent'] | GQLResolversTypes['UnlabeledEvent'] | GQLResolversTypes['UnlockedEvent'] | GQLResolversTypes['UnmarkedAsDuplicateEvent'] | GQLResolversTypes['UnpinnedEvent'] | GQLResolversTypes['UnsubscribedEvent'] | GQLResolversTypes['UserBlockedEvent'];
  PullRequestTimelineItemsConnection: ResolverTypeWrapper<Omit<GQLPullRequestTimelineItemsConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<GQLResolversTypes['PullRequestTimelineItems']>>> }>;
  PullRequestTimelineItemsEdge: ResolverTypeWrapper<Omit<GQLPullRequestTimelineItemsEdge, 'node'> & { node?: Maybe<GQLResolversTypes['PullRequestTimelineItems']> }>;
  PullRequestTimelineItemsItemType: GQLPullRequestTimelineItemsItemType;
  PullRequestUpdateState: GQLPullRequestUpdateState;
  Push: ResolverTypeWrapper<GQLPush>;
  PushAllowance: ResolverTypeWrapper<Omit<GQLPushAllowance, 'actor'> & { actor?: Maybe<GQLResolversTypes['PushAllowanceActor']> }>;
  PushAllowanceActor: GQLResolversTypes['App'] | GQLResolversTypes['Team'] | GQLResolversTypes['User'];
  PushAllowanceConnection: ResolverTypeWrapper<GQLPushAllowanceConnection>;
  PushAllowanceEdge: ResolverTypeWrapper<GQLPushAllowanceEdge>;
  Query: ResolverTypeWrapper<{}>;
  RateLimit: ResolverTypeWrapper<GQLRateLimit>;
  Reactable: GQLResolversTypes['CommitComment'] | GQLResolversTypes['Issue'] | GQLResolversTypes['IssueComment'] | GQLResolversTypes['PullRequest'] | GQLResolversTypes['PullRequestReview'] | GQLResolversTypes['PullRequestReviewComment'] | GQLResolversTypes['TeamDiscussion'] | GQLResolversTypes['TeamDiscussionComment'];
  ReactingUserConnection: ResolverTypeWrapper<GQLReactingUserConnection>;
  ReactingUserEdge: ResolverTypeWrapper<GQLReactingUserEdge>;
  Reaction: ResolverTypeWrapper<GQLReaction>;
  ReactionConnection: ResolverTypeWrapper<GQLReactionConnection>;
  ReactionContent: GQLReactionContent;
  ReactionEdge: ResolverTypeWrapper<GQLReactionEdge>;
  ReactionGroup: ResolverTypeWrapper<GQLReactionGroup>;
  ReactionOrder: GQLReactionOrder;
  ReactionOrderField: GQLReactionOrderField;
  ReadyForReviewEvent: ResolverTypeWrapper<GQLReadyForReviewEvent>;
  Ref: ResolverTypeWrapper<GQLRef>;
  RefConnection: ResolverTypeWrapper<GQLRefConnection>;
  RefEdge: ResolverTypeWrapper<GQLRefEdge>;
  RefOrder: GQLRefOrder;
  RefOrderField: GQLRefOrderField;
  RefUpdate: GQLRefUpdate;
  ReferencedEvent: ResolverTypeWrapper<Omit<GQLReferencedEvent, 'subject'> & { subject: GQLResolversTypes['ReferencedSubject'] }>;
  ReferencedSubject: GQLResolversTypes['Issue'] | GQLResolversTypes['PullRequest'];
  RegenerateEnterpriseIdentityProviderRecoveryCodesInput: GQLRegenerateEnterpriseIdentityProviderRecoveryCodesInput;
  RegenerateEnterpriseIdentityProviderRecoveryCodesPayload: ResolverTypeWrapper<GQLRegenerateEnterpriseIdentityProviderRecoveryCodesPayload>;
  RegistryPackage: ResolverTypeWrapper<GQLRegistryPackage>;
  RegistryPackageConnection: ResolverTypeWrapper<GQLRegistryPackageConnection>;
  RegistryPackageDependency: ResolverTypeWrapper<GQLRegistryPackageDependency>;
  RegistryPackageDependencyConnection: ResolverTypeWrapper<GQLRegistryPackageDependencyConnection>;
  RegistryPackageDependencyEdge: ResolverTypeWrapper<GQLRegistryPackageDependencyEdge>;
  RegistryPackageDependencyType: GQLRegistryPackageDependencyType;
  RegistryPackageEdge: ResolverTypeWrapper<GQLRegistryPackageEdge>;
  RegistryPackageFile: ResolverTypeWrapper<GQLRegistryPackageFile>;
  RegistryPackageFileConnection: ResolverTypeWrapper<GQLRegistryPackageFileConnection>;
  RegistryPackageFileEdge: ResolverTypeWrapper<GQLRegistryPackageFileEdge>;
  RegistryPackageMetadatum: GQLRegistryPackageMetadatum;
  RegistryPackageOwner: GQLResolversTypes['Organization'] | GQLResolversTypes['Repository'] | GQLResolversTypes['User'];
  RegistryPackageSearch: GQLResolversTypes['Organization'] | GQLResolversTypes['Repository'] | GQLResolversTypes['User'];
  RegistryPackageStatistics: ResolverTypeWrapper<GQLRegistryPackageStatistics>;
  RegistryPackageTag: ResolverTypeWrapper<GQLRegistryPackageTag>;
  RegistryPackageTagConnection: ResolverTypeWrapper<GQLRegistryPackageTagConnection>;
  RegistryPackageTagEdge: ResolverTypeWrapper<GQLRegistryPackageTagEdge>;
  RegistryPackageType: GQLRegistryPackageType;
  RegistryPackageVersion: ResolverTypeWrapper<GQLRegistryPackageVersion>;
  RegistryPackageVersionConnection: ResolverTypeWrapper<GQLRegistryPackageVersionConnection>;
  RegistryPackageVersionEdge: ResolverTypeWrapper<GQLRegistryPackageVersionEdge>;
  RegistryPackageVersionStatistics: ResolverTypeWrapper<GQLRegistryPackageVersionStatistics>;
  Release: ResolverTypeWrapper<GQLRelease>;
  ReleaseAsset: ResolverTypeWrapper<GQLReleaseAsset>;
  ReleaseAssetConnection: ResolverTypeWrapper<GQLReleaseAssetConnection>;
  ReleaseAssetEdge: ResolverTypeWrapper<GQLReleaseAssetEdge>;
  ReleaseConnection: ResolverTypeWrapper<GQLReleaseConnection>;
  ReleaseEdge: ResolverTypeWrapper<GQLReleaseEdge>;
  ReleaseOrder: GQLReleaseOrder;
  ReleaseOrderField: GQLReleaseOrderField;
  RemoveAssigneesFromAssignableInput: GQLRemoveAssigneesFromAssignableInput;
  RemoveAssigneesFromAssignablePayload: ResolverTypeWrapper<GQLRemoveAssigneesFromAssignablePayload>;
  RemoveEnterpriseAdminInput: GQLRemoveEnterpriseAdminInput;
  RemoveEnterpriseAdminPayload: ResolverTypeWrapper<GQLRemoveEnterpriseAdminPayload>;
  RemoveEnterpriseIdentityProviderInput: GQLRemoveEnterpriseIdentityProviderInput;
  RemoveEnterpriseIdentityProviderPayload: ResolverTypeWrapper<GQLRemoveEnterpriseIdentityProviderPayload>;
  RemoveEnterpriseOrganizationInput: GQLRemoveEnterpriseOrganizationInput;
  RemoveEnterpriseOrganizationPayload: ResolverTypeWrapper<GQLRemoveEnterpriseOrganizationPayload>;
  RemoveLabelsFromLabelableInput: GQLRemoveLabelsFromLabelableInput;
  RemoveLabelsFromLabelablePayload: ResolverTypeWrapper<GQLRemoveLabelsFromLabelablePayload>;
  RemoveOutsideCollaboratorInput: GQLRemoveOutsideCollaboratorInput;
  RemoveOutsideCollaboratorPayload: ResolverTypeWrapper<GQLRemoveOutsideCollaboratorPayload>;
  RemoveReactionInput: GQLRemoveReactionInput;
  RemoveReactionPayload: ResolverTypeWrapper<GQLRemoveReactionPayload>;
  RemoveStarInput: GQLRemoveStarInput;
  RemoveStarPayload: ResolverTypeWrapper<GQLRemoveStarPayload>;
  RemovedFromProjectEvent: ResolverTypeWrapper<GQLRemovedFromProjectEvent>;
  RenamedTitleEvent: ResolverTypeWrapper<Omit<GQLRenamedTitleEvent, 'subject'> & { subject: GQLResolversTypes['RenamedTitleSubject'] }>;
  RenamedTitleSubject: GQLResolversTypes['Issue'] | GQLResolversTypes['PullRequest'];
  ReopenIssueInput: GQLReopenIssueInput;
  ReopenIssuePayload: ResolverTypeWrapper<GQLReopenIssuePayload>;
  ReopenPullRequestInput: GQLReopenPullRequestInput;
  ReopenPullRequestPayload: ResolverTypeWrapper<GQLReopenPullRequestPayload>;
  ReopenedEvent: ResolverTypeWrapper<GQLReopenedEvent>;
  RepoAccessAuditEntry: ResolverTypeWrapper<Omit<GQLRepoAccessAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  RepoAccessAuditEntryVisibility: GQLRepoAccessAuditEntryVisibility;
  RepoAddMemberAuditEntry: ResolverTypeWrapper<Omit<GQLRepoAddMemberAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  RepoAddMemberAuditEntryVisibility: GQLRepoAddMemberAuditEntryVisibility;
  RepoAddTopicAuditEntry: ResolverTypeWrapper<Omit<GQLRepoAddTopicAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  RepoArchivedAuditEntry: ResolverTypeWrapper<Omit<GQLRepoArchivedAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  RepoArchivedAuditEntryVisibility: GQLRepoArchivedAuditEntryVisibility;
  RepoChangeMergeSettingAuditEntry: ResolverTypeWrapper<Omit<GQLRepoChangeMergeSettingAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  RepoChangeMergeSettingAuditEntryMergeType: GQLRepoChangeMergeSettingAuditEntryMergeType;
  RepoConfigDisableAnonymousGitAccessAuditEntry: ResolverTypeWrapper<Omit<GQLRepoConfigDisableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  RepoConfigDisableCollaboratorsOnlyAuditEntry: ResolverTypeWrapper<Omit<GQLRepoConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  RepoConfigDisableContributorsOnlyAuditEntry: ResolverTypeWrapper<Omit<GQLRepoConfigDisableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  RepoConfigDisableSockpuppetDisallowedAuditEntry: ResolverTypeWrapper<Omit<GQLRepoConfigDisableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  RepoConfigEnableAnonymousGitAccessAuditEntry: ResolverTypeWrapper<Omit<GQLRepoConfigEnableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  RepoConfigEnableCollaboratorsOnlyAuditEntry: ResolverTypeWrapper<Omit<GQLRepoConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  RepoConfigEnableContributorsOnlyAuditEntry: ResolverTypeWrapper<Omit<GQLRepoConfigEnableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  RepoConfigEnableSockpuppetDisallowedAuditEntry: ResolverTypeWrapper<Omit<GQLRepoConfigEnableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  RepoConfigLockAnonymousGitAccessAuditEntry: ResolverTypeWrapper<Omit<GQLRepoConfigLockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  RepoConfigUnlockAnonymousGitAccessAuditEntry: ResolverTypeWrapper<Omit<GQLRepoConfigUnlockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  RepoCreateAuditEntry: ResolverTypeWrapper<Omit<GQLRepoCreateAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  RepoCreateAuditEntryVisibility: GQLRepoCreateAuditEntryVisibility;
  RepoDestroyAuditEntry: ResolverTypeWrapper<Omit<GQLRepoDestroyAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  RepoDestroyAuditEntryVisibility: GQLRepoDestroyAuditEntryVisibility;
  RepoRemoveMemberAuditEntry: ResolverTypeWrapper<Omit<GQLRepoRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  RepoRemoveMemberAuditEntryVisibility: GQLRepoRemoveMemberAuditEntryVisibility;
  RepoRemoveTopicAuditEntry: ResolverTypeWrapper<Omit<GQLRepoRemoveTopicAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  ReportedContentClassifiers: GQLReportedContentClassifiers;
  Repository: ResolverTypeWrapper<Omit<GQLRepository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<GQLResolversTypes['IssueOrPullRequest']> }>;
  RepositoryAffiliation: GQLRepositoryAffiliation;
  RepositoryAuditEntryData: GQLResolversTypes['OrgRestoreMemberMembershipRepositoryAuditEntryData'] | GQLResolversTypes['PrivateRepositoryForkingDisableAuditEntry'] | GQLResolversTypes['PrivateRepositoryForkingEnableAuditEntry'] | GQLResolversTypes['RepoAccessAuditEntry'] | GQLResolversTypes['RepoAddMemberAuditEntry'] | GQLResolversTypes['RepoAddTopicAuditEntry'] | GQLResolversTypes['RepoArchivedAuditEntry'] | GQLResolversTypes['RepoChangeMergeSettingAuditEntry'] | GQLResolversTypes['RepoConfigDisableAnonymousGitAccessAuditEntry'] | GQLResolversTypes['RepoConfigDisableCollaboratorsOnlyAuditEntry'] | GQLResolversTypes['RepoConfigDisableContributorsOnlyAuditEntry'] | GQLResolversTypes['RepoConfigDisableSockpuppetDisallowedAuditEntry'] | GQLResolversTypes['RepoConfigEnableAnonymousGitAccessAuditEntry'] | GQLResolversTypes['RepoConfigEnableCollaboratorsOnlyAuditEntry'] | GQLResolversTypes['RepoConfigEnableContributorsOnlyAuditEntry'] | GQLResolversTypes['RepoConfigEnableSockpuppetDisallowedAuditEntry'] | GQLResolversTypes['RepoConfigLockAnonymousGitAccessAuditEntry'] | GQLResolversTypes['RepoConfigUnlockAnonymousGitAccessAuditEntry'] | GQLResolversTypes['RepoCreateAuditEntry'] | GQLResolversTypes['RepoDestroyAuditEntry'] | GQLResolversTypes['RepoRemoveMemberAuditEntry'] | GQLResolversTypes['RepoRemoveTopicAuditEntry'] | GQLResolversTypes['TeamAddRepositoryAuditEntry'] | GQLResolversTypes['TeamRemoveRepositoryAuditEntry'];
  RepositoryCollaboratorConnection: ResolverTypeWrapper<GQLRepositoryCollaboratorConnection>;
  RepositoryCollaboratorEdge: ResolverTypeWrapper<GQLRepositoryCollaboratorEdge>;
  RepositoryConnection: ResolverTypeWrapper<GQLRepositoryConnection>;
  RepositoryContributionType: GQLRepositoryContributionType;
  RepositoryEdge: ResolverTypeWrapper<GQLRepositoryEdge>;
  RepositoryInfo: GQLResolversTypes['Repository'];
  RepositoryInvitation: ResolverTypeWrapper<GQLRepositoryInvitation>;
  RepositoryInvitationConnection: ResolverTypeWrapper<GQLRepositoryInvitationConnection>;
  RepositoryInvitationEdge: ResolverTypeWrapper<GQLRepositoryInvitationEdge>;
  RepositoryInvitationOrder: GQLRepositoryInvitationOrder;
  RepositoryInvitationOrderField: GQLRepositoryInvitationOrderField;
  RepositoryLockReason: GQLRepositoryLockReason;
  RepositoryNode: GQLResolversTypes['CommitComment'] | GQLResolversTypes['CommitCommentThread'] | GQLResolversTypes['Issue'] | GQLResolversTypes['IssueComment'] | GQLResolversTypes['PullRequest'] | GQLResolversTypes['PullRequestCommitCommentThread'] | GQLResolversTypes['PullRequestReview'] | GQLResolversTypes['PullRequestReviewComment'] | GQLResolversTypes['RepositoryVulnerabilityAlert'];
  RepositoryOrder: GQLRepositoryOrder;
  RepositoryOrderField: GQLRepositoryOrderField;
  RepositoryOwner: GQLResolversTypes['Organization'] | GQLResolversTypes['User'];
  RepositoryPermission: GQLRepositoryPermission;
  RepositoryPrivacy: GQLRepositoryPrivacy;
  RepositoryTopic: ResolverTypeWrapper<GQLRepositoryTopic>;
  RepositoryTopicConnection: ResolverTypeWrapper<GQLRepositoryTopicConnection>;
  RepositoryTopicEdge: ResolverTypeWrapper<GQLRepositoryTopicEdge>;
  RepositoryVisibility: GQLRepositoryVisibility;
  RepositoryVisibilityChangeDisableAuditEntry: ResolverTypeWrapper<Omit<GQLRepositoryVisibilityChangeDisableAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  RepositoryVisibilityChangeEnableAuditEntry: ResolverTypeWrapper<Omit<GQLRepositoryVisibilityChangeEnableAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  RepositoryVulnerabilityAlert: ResolverTypeWrapper<GQLRepositoryVulnerabilityAlert>;
  RepositoryVulnerabilityAlertConnection: ResolverTypeWrapper<GQLRepositoryVulnerabilityAlertConnection>;
  RepositoryVulnerabilityAlertEdge: ResolverTypeWrapper<GQLRepositoryVulnerabilityAlertEdge>;
  RequestReviewsInput: GQLRequestReviewsInput;
  RequestReviewsPayload: ResolverTypeWrapper<GQLRequestReviewsPayload>;
  RequestableCheckStatusState: GQLRequestableCheckStatusState;
  RequestedReviewer: GQLResolversTypes['Mannequin'] | GQLResolversTypes['Team'] | GQLResolversTypes['User'];
  RerequestCheckSuiteInput: GQLRerequestCheckSuiteInput;
  RerequestCheckSuitePayload: ResolverTypeWrapper<GQLRerequestCheckSuitePayload>;
  ResolveReviewThreadInput: GQLResolveReviewThreadInput;
  ResolveReviewThreadPayload: ResolverTypeWrapper<GQLResolveReviewThreadPayload>;
  RestrictedContribution: ResolverTypeWrapper<GQLRestrictedContribution>;
  ReviewDismissalAllowance: ResolverTypeWrapper<Omit<GQLReviewDismissalAllowance, 'actor'> & { actor?: Maybe<GQLResolversTypes['ReviewDismissalAllowanceActor']> }>;
  ReviewDismissalAllowanceActor: GQLResolversTypes['Team'] | GQLResolversTypes['User'];
  ReviewDismissalAllowanceConnection: ResolverTypeWrapper<GQLReviewDismissalAllowanceConnection>;
  ReviewDismissalAllowanceEdge: ResolverTypeWrapper<GQLReviewDismissalAllowanceEdge>;
  ReviewDismissedEvent: ResolverTypeWrapper<GQLReviewDismissedEvent>;
  ReviewRequest: ResolverTypeWrapper<Omit<GQLReviewRequest, 'requestedReviewer'> & { requestedReviewer?: Maybe<GQLResolversTypes['RequestedReviewer']> }>;
  ReviewRequestConnection: ResolverTypeWrapper<GQLReviewRequestConnection>;
  ReviewRequestEdge: ResolverTypeWrapper<GQLReviewRequestEdge>;
  ReviewRequestRemovedEvent: ResolverTypeWrapper<Omit<GQLReviewRequestRemovedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<GQLResolversTypes['RequestedReviewer']> }>;
  ReviewRequestedEvent: ResolverTypeWrapper<Omit<GQLReviewRequestedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<GQLResolversTypes['RequestedReviewer']> }>;
  ReviewStatusHovercardContext: ResolverTypeWrapper<GQLReviewStatusHovercardContext>;
  SamlDigestAlgorithm: GQLSamlDigestAlgorithm;
  SamlSignatureAlgorithm: GQLSamlSignatureAlgorithm;
  SavedReply: ResolverTypeWrapper<GQLSavedReply>;
  SavedReplyConnection: ResolverTypeWrapper<GQLSavedReplyConnection>;
  SavedReplyEdge: ResolverTypeWrapper<GQLSavedReplyEdge>;
  SavedReplyOrder: GQLSavedReplyOrder;
  SavedReplyOrderField: GQLSavedReplyOrderField;
  SearchResultItem: GQLResolversTypes['App'] | GQLResolversTypes['Issue'] | GQLResolversTypes['MarketplaceListing'] | GQLResolversTypes['Organization'] | GQLResolversTypes['PullRequest'] | GQLResolversTypes['Repository'] | GQLResolversTypes['User'];
  SearchResultItemConnection: ResolverTypeWrapper<Omit<GQLSearchResultItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<GQLResolversTypes['SearchResultItem']>>> }>;
  SearchResultItemEdge: ResolverTypeWrapper<Omit<GQLSearchResultItemEdge, 'node'> & { node?: Maybe<GQLResolversTypes['SearchResultItem']> }>;
  SearchType: GQLSearchType;
  SecurityAdvisory: ResolverTypeWrapper<GQLSecurityAdvisory>;
  SecurityAdvisoryConnection: ResolverTypeWrapper<GQLSecurityAdvisoryConnection>;
  SecurityAdvisoryEcosystem: GQLSecurityAdvisoryEcosystem;
  SecurityAdvisoryEdge: ResolverTypeWrapper<GQLSecurityAdvisoryEdge>;
  SecurityAdvisoryIdentifier: ResolverTypeWrapper<GQLSecurityAdvisoryIdentifier>;
  SecurityAdvisoryIdentifierFilter: GQLSecurityAdvisoryIdentifierFilter;
  SecurityAdvisoryIdentifierType: GQLSecurityAdvisoryIdentifierType;
  SecurityAdvisoryOrder: GQLSecurityAdvisoryOrder;
  SecurityAdvisoryOrderField: GQLSecurityAdvisoryOrderField;
  SecurityAdvisoryPackage: ResolverTypeWrapper<GQLSecurityAdvisoryPackage>;
  SecurityAdvisoryPackageVersion: ResolverTypeWrapper<GQLSecurityAdvisoryPackageVersion>;
  SecurityAdvisoryReference: ResolverTypeWrapper<GQLSecurityAdvisoryReference>;
  SecurityAdvisorySeverity: GQLSecurityAdvisorySeverity;
  SecurityVulnerability: ResolverTypeWrapper<GQLSecurityVulnerability>;
  SecurityVulnerabilityConnection: ResolverTypeWrapper<GQLSecurityVulnerabilityConnection>;
  SecurityVulnerabilityEdge: ResolverTypeWrapper<GQLSecurityVulnerabilityEdge>;
  SecurityVulnerabilityOrder: GQLSecurityVulnerabilityOrder;
  SecurityVulnerabilityOrderField: GQLSecurityVulnerabilityOrderField;
  SetEnterpriseIdentityProviderInput: GQLSetEnterpriseIdentityProviderInput;
  SetEnterpriseIdentityProviderPayload: ResolverTypeWrapper<GQLSetEnterpriseIdentityProviderPayload>;
  SmimeSignature: ResolverTypeWrapper<GQLSmimeSignature>;
  Sponsor: GQLResolversTypes['Organization'] | GQLResolversTypes['User'];
  Sponsorable: GQLResolversTypes['Organization'] | GQLResolversTypes['User'];
  SponsorsListing: ResolverTypeWrapper<GQLSponsorsListing>;
  SponsorsTier: ResolverTypeWrapper<GQLSponsorsTier>;
  SponsorsTierAdminInfo: ResolverTypeWrapper<GQLSponsorsTierAdminInfo>;
  SponsorsTierConnection: ResolverTypeWrapper<GQLSponsorsTierConnection>;
  SponsorsTierEdge: ResolverTypeWrapper<GQLSponsorsTierEdge>;
  SponsorsTierOrder: GQLSponsorsTierOrder;
  SponsorsTierOrderField: GQLSponsorsTierOrderField;
  Sponsorship: ResolverTypeWrapper<Omit<GQLSponsorship, 'sponsorEntity'> & { sponsorEntity?: Maybe<GQLResolversTypes['Sponsor']> }>;
  SponsorshipConnection: ResolverTypeWrapper<GQLSponsorshipConnection>;
  SponsorshipEdge: ResolverTypeWrapper<GQLSponsorshipEdge>;
  SponsorshipOrder: GQLSponsorshipOrder;
  SponsorshipOrderField: GQLSponsorshipOrderField;
  SponsorshipPrivacy: GQLSponsorshipPrivacy;
  StarOrder: GQLStarOrder;
  StarOrderField: GQLStarOrderField;
  StargazerConnection: ResolverTypeWrapper<GQLStargazerConnection>;
  StargazerEdge: ResolverTypeWrapper<GQLStargazerEdge>;
  Starrable: GQLResolversTypes['Gist'] | GQLResolversTypes['Repository'] | GQLResolversTypes['Topic'];
  StarredRepositoryConnection: ResolverTypeWrapper<GQLStarredRepositoryConnection>;
  StarredRepositoryEdge: ResolverTypeWrapper<GQLStarredRepositoryEdge>;
  Status: ResolverTypeWrapper<GQLStatus>;
  StatusCheckRollup: ResolverTypeWrapper<GQLStatusCheckRollup>;
  StatusCheckRollupContext: GQLResolversTypes['CheckRun'] | GQLResolversTypes['StatusContext'];
  StatusCheckRollupContextConnection: ResolverTypeWrapper<Omit<GQLStatusCheckRollupContextConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<GQLResolversTypes['StatusCheckRollupContext']>>> }>;
  StatusCheckRollupContextEdge: ResolverTypeWrapper<Omit<GQLStatusCheckRollupContextEdge, 'node'> & { node?: Maybe<GQLResolversTypes['StatusCheckRollupContext']> }>;
  StatusContext: ResolverTypeWrapper<GQLStatusContext>;
  StatusState: GQLStatusState;
  SubmitPullRequestReviewInput: GQLSubmitPullRequestReviewInput;
  SubmitPullRequestReviewPayload: ResolverTypeWrapper<GQLSubmitPullRequestReviewPayload>;
  Submodule: ResolverTypeWrapper<GQLSubmodule>;
  SubmoduleConnection: ResolverTypeWrapper<GQLSubmoduleConnection>;
  SubmoduleEdge: ResolverTypeWrapper<GQLSubmoduleEdge>;
  Subscribable: GQLResolversTypes['Commit'] | GQLResolversTypes['Issue'] | GQLResolversTypes['PullRequest'] | GQLResolversTypes['Repository'] | GQLResolversTypes['Team'] | GQLResolversTypes['TeamDiscussion'];
  SubscribedEvent: ResolverTypeWrapper<GQLSubscribedEvent>;
  SubscriptionState: GQLSubscriptionState;
  SuggestedReviewer: ResolverTypeWrapper<GQLSuggestedReviewer>;
  Tag: ResolverTypeWrapper<GQLTag>;
  Team: ResolverTypeWrapper<GQLTeam>;
  TeamAddMemberAuditEntry: ResolverTypeWrapper<Omit<GQLTeamAddMemberAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  TeamAddRepositoryAuditEntry: ResolverTypeWrapper<Omit<GQLTeamAddRepositoryAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  TeamAuditEntryData: GQLResolversTypes['OrgRestoreMemberMembershipTeamAuditEntryData'] | GQLResolversTypes['TeamAddMemberAuditEntry'] | GQLResolversTypes['TeamAddRepositoryAuditEntry'] | GQLResolversTypes['TeamChangeParentTeamAuditEntry'] | GQLResolversTypes['TeamRemoveMemberAuditEntry'] | GQLResolversTypes['TeamRemoveRepositoryAuditEntry'];
  TeamChangeParentTeamAuditEntry: ResolverTypeWrapper<Omit<GQLTeamChangeParentTeamAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  TeamConnection: ResolverTypeWrapper<GQLTeamConnection>;
  TeamDiscussion: ResolverTypeWrapper<GQLTeamDiscussion>;
  TeamDiscussionComment: ResolverTypeWrapper<GQLTeamDiscussionComment>;
  TeamDiscussionCommentConnection: ResolverTypeWrapper<GQLTeamDiscussionCommentConnection>;
  TeamDiscussionCommentEdge: ResolverTypeWrapper<GQLTeamDiscussionCommentEdge>;
  TeamDiscussionCommentOrder: GQLTeamDiscussionCommentOrder;
  TeamDiscussionCommentOrderField: GQLTeamDiscussionCommentOrderField;
  TeamDiscussionConnection: ResolverTypeWrapper<GQLTeamDiscussionConnection>;
  TeamDiscussionEdge: ResolverTypeWrapper<GQLTeamDiscussionEdge>;
  TeamDiscussionOrder: GQLTeamDiscussionOrder;
  TeamDiscussionOrderField: GQLTeamDiscussionOrderField;
  TeamEdge: ResolverTypeWrapper<GQLTeamEdge>;
  TeamMemberConnection: ResolverTypeWrapper<GQLTeamMemberConnection>;
  TeamMemberEdge: ResolverTypeWrapper<GQLTeamMemberEdge>;
  TeamMemberOrder: GQLTeamMemberOrder;
  TeamMemberOrderField: GQLTeamMemberOrderField;
  TeamMemberRole: GQLTeamMemberRole;
  TeamMembershipType: GQLTeamMembershipType;
  TeamOrder: GQLTeamOrder;
  TeamOrderField: GQLTeamOrderField;
  TeamPrivacy: GQLTeamPrivacy;
  TeamRemoveMemberAuditEntry: ResolverTypeWrapper<Omit<GQLTeamRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  TeamRemoveRepositoryAuditEntry: ResolverTypeWrapper<Omit<GQLTeamRemoveRepositoryAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversTypes['AuditEntryActor']> }>;
  TeamRepositoryConnection: ResolverTypeWrapper<GQLTeamRepositoryConnection>;
  TeamRepositoryEdge: ResolverTypeWrapper<GQLTeamRepositoryEdge>;
  TeamRepositoryOrder: GQLTeamRepositoryOrder;
  TeamRepositoryOrderField: GQLTeamRepositoryOrderField;
  TeamReviewAssignmentAlgorithm: GQLTeamReviewAssignmentAlgorithm;
  TeamRole: GQLTeamRole;
  TextMatch: ResolverTypeWrapper<GQLTextMatch>;
  TextMatchHighlight: ResolverTypeWrapper<GQLTextMatchHighlight>;
  Topic: ResolverTypeWrapper<GQLTopic>;
  TopicAuditEntryData: GQLResolversTypes['RepoAddTopicAuditEntry'] | GQLResolversTypes['RepoRemoveTopicAuditEntry'];
  TopicConnection: ResolverTypeWrapper<GQLTopicConnection>;
  TopicEdge: ResolverTypeWrapper<GQLTopicEdge>;
  TopicSuggestionDeclineReason: GQLTopicSuggestionDeclineReason;
  TransferIssueInput: GQLTransferIssueInput;
  TransferIssuePayload: ResolverTypeWrapper<GQLTransferIssuePayload>;
  TransferredEvent: ResolverTypeWrapper<GQLTransferredEvent>;
  Tree: ResolverTypeWrapper<GQLTree>;
  TreeEntry: ResolverTypeWrapper<GQLTreeEntry>;
  URI: ResolverTypeWrapper<Scalars['URI']>;
  UnarchiveRepositoryInput: GQLUnarchiveRepositoryInput;
  UnarchiveRepositoryPayload: ResolverTypeWrapper<GQLUnarchiveRepositoryPayload>;
  UnassignedEvent: ResolverTypeWrapper<Omit<GQLUnassignedEvent, 'assignee'> & { assignee?: Maybe<GQLResolversTypes['Assignee']> }>;
  UnfollowUserInput: GQLUnfollowUserInput;
  UnfollowUserPayload: ResolverTypeWrapper<GQLUnfollowUserPayload>;
  UniformResourceLocatable: GQLResolversTypes['Bot'] | GQLResolversTypes['CheckRun'] | GQLResolversTypes['ClosedEvent'] | GQLResolversTypes['Commit'] | GQLResolversTypes['ConvertToDraftEvent'] | GQLResolversTypes['CrossReferencedEvent'] | GQLResolversTypes['Gist'] | GQLResolversTypes['Issue'] | GQLResolversTypes['Mannequin'] | GQLResolversTypes['MergedEvent'] | GQLResolversTypes['Milestone'] | GQLResolversTypes['Organization'] | GQLResolversTypes['PullRequest'] | GQLResolversTypes['PullRequestCommit'] | GQLResolversTypes['ReadyForReviewEvent'] | GQLResolversTypes['Release'] | GQLResolversTypes['Repository'] | GQLResolversTypes['RepositoryTopic'] | GQLResolversTypes['ReviewDismissedEvent'] | GQLResolversTypes['TeamDiscussion'] | GQLResolversTypes['TeamDiscussionComment'] | GQLResolversTypes['User'];
  UnknownSignature: ResolverTypeWrapper<GQLUnknownSignature>;
  UnlabeledEvent: ResolverTypeWrapper<GQLUnlabeledEvent>;
  UnlinkRepositoryFromProjectInput: GQLUnlinkRepositoryFromProjectInput;
  UnlinkRepositoryFromProjectPayload: ResolverTypeWrapper<GQLUnlinkRepositoryFromProjectPayload>;
  UnlockLockableInput: GQLUnlockLockableInput;
  UnlockLockablePayload: ResolverTypeWrapper<GQLUnlockLockablePayload>;
  UnlockedEvent: ResolverTypeWrapper<GQLUnlockedEvent>;
  UnmarkIssueAsDuplicateInput: GQLUnmarkIssueAsDuplicateInput;
  UnmarkIssueAsDuplicatePayload: ResolverTypeWrapper<Omit<GQLUnmarkIssueAsDuplicatePayload, 'duplicate'> & { duplicate?: Maybe<GQLResolversTypes['IssueOrPullRequest']> }>;
  UnmarkedAsDuplicateEvent: ResolverTypeWrapper<GQLUnmarkedAsDuplicateEvent>;
  UnminimizeCommentInput: GQLUnminimizeCommentInput;
  UnminimizeCommentPayload: ResolverTypeWrapper<GQLUnminimizeCommentPayload>;
  UnpinIssueInput: GQLUnpinIssueInput;
  UnpinIssuePayload: ResolverTypeWrapper<GQLUnpinIssuePayload>;
  UnpinnedEvent: ResolverTypeWrapper<GQLUnpinnedEvent>;
  UnresolveReviewThreadInput: GQLUnresolveReviewThreadInput;
  UnresolveReviewThreadPayload: ResolverTypeWrapper<GQLUnresolveReviewThreadPayload>;
  UnsubscribedEvent: ResolverTypeWrapper<GQLUnsubscribedEvent>;
  Updatable: GQLResolversTypes['CommitComment'] | GQLResolversTypes['GistComment'] | GQLResolversTypes['Issue'] | GQLResolversTypes['IssueComment'] | GQLResolversTypes['Project'] | GQLResolversTypes['PullRequest'] | GQLResolversTypes['PullRequestReview'] | GQLResolversTypes['PullRequestReviewComment'] | GQLResolversTypes['TeamDiscussion'] | GQLResolversTypes['TeamDiscussionComment'];
  UpdatableComment: GQLResolversTypes['CommitComment'] | GQLResolversTypes['GistComment'] | GQLResolversTypes['Issue'] | GQLResolversTypes['IssueComment'] | GQLResolversTypes['PullRequest'] | GQLResolversTypes['PullRequestReview'] | GQLResolversTypes['PullRequestReviewComment'] | GQLResolversTypes['TeamDiscussion'] | GQLResolversTypes['TeamDiscussionComment'];
  UpdateBranchProtectionRuleInput: GQLUpdateBranchProtectionRuleInput;
  UpdateBranchProtectionRulePayload: ResolverTypeWrapper<GQLUpdateBranchProtectionRulePayload>;
  UpdateCheckRunInput: GQLUpdateCheckRunInput;
  UpdateCheckRunPayload: ResolverTypeWrapper<GQLUpdateCheckRunPayload>;
  UpdateCheckSuitePreferencesInput: GQLUpdateCheckSuitePreferencesInput;
  UpdateCheckSuitePreferencesPayload: ResolverTypeWrapper<GQLUpdateCheckSuitePreferencesPayload>;
  UpdateEnterpriseActionExecutionCapabilitySettingInput: GQLUpdateEnterpriseActionExecutionCapabilitySettingInput;
  UpdateEnterpriseActionExecutionCapabilitySettingPayload: ResolverTypeWrapper<GQLUpdateEnterpriseActionExecutionCapabilitySettingPayload>;
  UpdateEnterpriseAdministratorRoleInput: GQLUpdateEnterpriseAdministratorRoleInput;
  UpdateEnterpriseAdministratorRolePayload: ResolverTypeWrapper<GQLUpdateEnterpriseAdministratorRolePayload>;
  UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput: GQLUpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;
  UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload: ResolverTypeWrapper<GQLUpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload>;
  UpdateEnterpriseDefaultRepositoryPermissionSettingInput: GQLUpdateEnterpriseDefaultRepositoryPermissionSettingInput;
  UpdateEnterpriseDefaultRepositoryPermissionSettingPayload: ResolverTypeWrapper<GQLUpdateEnterpriseDefaultRepositoryPermissionSettingPayload>;
  UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput: GQLUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;
  UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload: ResolverTypeWrapper<GQLUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload>;
  UpdateEnterpriseMembersCanCreateRepositoriesSettingInput: GQLUpdateEnterpriseMembersCanCreateRepositoriesSettingInput;
  UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload: ResolverTypeWrapper<GQLUpdateEnterpriseMembersCanCreateRepositoriesSettingPayload>;
  UpdateEnterpriseMembersCanDeleteIssuesSettingInput: GQLUpdateEnterpriseMembersCanDeleteIssuesSettingInput;
  UpdateEnterpriseMembersCanDeleteIssuesSettingPayload: ResolverTypeWrapper<GQLUpdateEnterpriseMembersCanDeleteIssuesSettingPayload>;
  UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput: GQLUpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;
  UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload: ResolverTypeWrapper<GQLUpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload>;
  UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput: GQLUpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;
  UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload: ResolverTypeWrapper<GQLUpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload>;
  UpdateEnterpriseMembersCanMakePurchasesSettingInput: GQLUpdateEnterpriseMembersCanMakePurchasesSettingInput;
  UpdateEnterpriseMembersCanMakePurchasesSettingPayload: ResolverTypeWrapper<GQLUpdateEnterpriseMembersCanMakePurchasesSettingPayload>;
  UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput: GQLUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;
  UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload: ResolverTypeWrapper<GQLUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload>;
  UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput: GQLUpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;
  UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload: ResolverTypeWrapper<GQLUpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload>;
  UpdateEnterpriseOrganizationProjectsSettingInput: GQLUpdateEnterpriseOrganizationProjectsSettingInput;
  UpdateEnterpriseOrganizationProjectsSettingPayload: ResolverTypeWrapper<GQLUpdateEnterpriseOrganizationProjectsSettingPayload>;
  UpdateEnterpriseProfileInput: GQLUpdateEnterpriseProfileInput;
  UpdateEnterpriseProfilePayload: ResolverTypeWrapper<GQLUpdateEnterpriseProfilePayload>;
  UpdateEnterpriseRepositoryProjectsSettingInput: GQLUpdateEnterpriseRepositoryProjectsSettingInput;
  UpdateEnterpriseRepositoryProjectsSettingPayload: ResolverTypeWrapper<GQLUpdateEnterpriseRepositoryProjectsSettingPayload>;
  UpdateEnterpriseTeamDiscussionsSettingInput: GQLUpdateEnterpriseTeamDiscussionsSettingInput;
  UpdateEnterpriseTeamDiscussionsSettingPayload: ResolverTypeWrapper<GQLUpdateEnterpriseTeamDiscussionsSettingPayload>;
  UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput: GQLUpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;
  UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload: ResolverTypeWrapper<GQLUpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload>;
  UpdateIpAllowListEnabledSettingInput: GQLUpdateIpAllowListEnabledSettingInput;
  UpdateIpAllowListEnabledSettingPayload: ResolverTypeWrapper<Omit<GQLUpdateIpAllowListEnabledSettingPayload, 'owner'> & { owner?: Maybe<GQLResolversTypes['IpAllowListOwner']> }>;
  UpdateIpAllowListEntryInput: GQLUpdateIpAllowListEntryInput;
  UpdateIpAllowListEntryPayload: ResolverTypeWrapper<GQLUpdateIpAllowListEntryPayload>;
  UpdateIssueCommentInput: GQLUpdateIssueCommentInput;
  UpdateIssueCommentPayload: ResolverTypeWrapper<GQLUpdateIssueCommentPayload>;
  UpdateIssueInput: GQLUpdateIssueInput;
  UpdateIssuePayload: ResolverTypeWrapper<GQLUpdateIssuePayload>;
  UpdateLabelInput: GQLUpdateLabelInput;
  UpdateLabelPayload: ResolverTypeWrapper<GQLUpdateLabelPayload>;
  UpdateProjectCardInput: GQLUpdateProjectCardInput;
  UpdateProjectCardPayload: ResolverTypeWrapper<GQLUpdateProjectCardPayload>;
  UpdateProjectColumnInput: GQLUpdateProjectColumnInput;
  UpdateProjectColumnPayload: ResolverTypeWrapper<GQLUpdateProjectColumnPayload>;
  UpdateProjectInput: GQLUpdateProjectInput;
  UpdateProjectPayload: ResolverTypeWrapper<GQLUpdateProjectPayload>;
  UpdatePullRequestInput: GQLUpdatePullRequestInput;
  UpdatePullRequestPayload: ResolverTypeWrapper<GQLUpdatePullRequestPayload>;
  UpdatePullRequestReviewCommentInput: GQLUpdatePullRequestReviewCommentInput;
  UpdatePullRequestReviewCommentPayload: ResolverTypeWrapper<GQLUpdatePullRequestReviewCommentPayload>;
  UpdatePullRequestReviewInput: GQLUpdatePullRequestReviewInput;
  UpdatePullRequestReviewPayload: ResolverTypeWrapper<GQLUpdatePullRequestReviewPayload>;
  UpdateRefInput: GQLUpdateRefInput;
  UpdateRefPayload: ResolverTypeWrapper<GQLUpdateRefPayload>;
  UpdateRefsInput: GQLUpdateRefsInput;
  UpdateRefsPayload: ResolverTypeWrapper<GQLUpdateRefsPayload>;
  UpdateRepositoryInput: GQLUpdateRepositoryInput;
  UpdateRepositoryPayload: ResolverTypeWrapper<GQLUpdateRepositoryPayload>;
  UpdateSubscriptionInput: GQLUpdateSubscriptionInput;
  UpdateSubscriptionPayload: ResolverTypeWrapper<GQLUpdateSubscriptionPayload>;
  UpdateTeamDiscussionCommentInput: GQLUpdateTeamDiscussionCommentInput;
  UpdateTeamDiscussionCommentPayload: ResolverTypeWrapper<GQLUpdateTeamDiscussionCommentPayload>;
  UpdateTeamDiscussionInput: GQLUpdateTeamDiscussionInput;
  UpdateTeamDiscussionPayload: ResolverTypeWrapper<GQLUpdateTeamDiscussionPayload>;
  UpdateTeamReviewAssignmentInput: GQLUpdateTeamReviewAssignmentInput;
  UpdateTeamReviewAssignmentPayload: ResolverTypeWrapper<GQLUpdateTeamReviewAssignmentPayload>;
  UpdateTopicsInput: GQLUpdateTopicsInput;
  UpdateTopicsPayload: ResolverTypeWrapper<GQLUpdateTopicsPayload>;
  User: ResolverTypeWrapper<GQLUser>;
  UserBlockDuration: GQLUserBlockDuration;
  UserBlockedEvent: ResolverTypeWrapper<GQLUserBlockedEvent>;
  UserConnection: ResolverTypeWrapper<GQLUserConnection>;
  UserContentEdit: ResolverTypeWrapper<GQLUserContentEdit>;
  UserContentEditConnection: ResolverTypeWrapper<GQLUserContentEditConnection>;
  UserContentEditEdge: ResolverTypeWrapper<GQLUserContentEditEdge>;
  UserEdge: ResolverTypeWrapper<GQLUserEdge>;
  UserStatus: ResolverTypeWrapper<GQLUserStatus>;
  UserStatusConnection: ResolverTypeWrapper<GQLUserStatusConnection>;
  UserStatusEdge: ResolverTypeWrapper<GQLUserStatusEdge>;
  UserStatusOrder: GQLUserStatusOrder;
  UserStatusOrderField: GQLUserStatusOrderField;
  ViewerHovercardContext: ResolverTypeWrapper<GQLViewerHovercardContext>;
  X509Certificate: ResolverTypeWrapper<Scalars['X509Certificate']>;
};

/** Mapping between all available schema types and the resolvers parents */
export type GQLResolversParentTypes = {
  AcceptEnterpriseAdministratorInvitationInput: GQLAcceptEnterpriseAdministratorInvitationInput;
  String: Scalars['String'];
  ID: Scalars['ID'];
  AcceptEnterpriseAdministratorInvitationPayload: GQLAcceptEnterpriseAdministratorInvitationPayload;
  AcceptTopicSuggestionInput: GQLAcceptTopicSuggestionInput;
  AcceptTopicSuggestionPayload: GQLAcceptTopicSuggestionPayload;
  Actor: GQLResolversParentTypes['Bot'] | GQLResolversParentTypes['EnterpriseUserAccount'] | GQLResolversParentTypes['Mannequin'] | GQLResolversParentTypes['Organization'] | GQLResolversParentTypes['User'];
  Int: Scalars['Int'];
  ActorLocation: GQLActorLocation;
  AddAssigneesToAssignableInput: GQLAddAssigneesToAssignableInput;
  AddAssigneesToAssignablePayload: GQLAddAssigneesToAssignablePayload;
  AddCommentInput: GQLAddCommentInput;
  AddCommentPayload: GQLAddCommentPayload;
  AddLabelsToLabelableInput: GQLAddLabelsToLabelableInput;
  AddLabelsToLabelablePayload: GQLAddLabelsToLabelablePayload;
  AddProjectCardInput: GQLAddProjectCardInput;
  AddProjectCardPayload: GQLAddProjectCardPayload;
  AddProjectColumnInput: GQLAddProjectColumnInput;
  AddProjectColumnPayload: GQLAddProjectColumnPayload;
  AddPullRequestReviewCommentInput: GQLAddPullRequestReviewCommentInput;
  AddPullRequestReviewCommentPayload: GQLAddPullRequestReviewCommentPayload;
  AddPullRequestReviewInput: GQLAddPullRequestReviewInput;
  AddPullRequestReviewPayload: GQLAddPullRequestReviewPayload;
  AddPullRequestReviewThreadInput: GQLAddPullRequestReviewThreadInput;
  AddPullRequestReviewThreadPayload: GQLAddPullRequestReviewThreadPayload;
  AddReactionInput: GQLAddReactionInput;
  AddReactionPayload: GQLAddReactionPayload;
  AddStarInput: GQLAddStarInput;
  AddStarPayload: GQLAddStarPayload;
  AddedToProjectEvent: GQLAddedToProjectEvent;
  App: GQLApp;
  ArchiveRepositoryInput: GQLArchiveRepositoryInput;
  ArchiveRepositoryPayload: GQLArchiveRepositoryPayload;
  Assignable: GQLResolversParentTypes['Issue'] | GQLResolversParentTypes['PullRequest'];
  AssignedEvent: Omit<GQLAssignedEvent, 'assignee'> & { assignee?: Maybe<GQLResolversParentTypes['Assignee']> };
  Assignee: GQLResolversParentTypes['Bot'] | GQLResolversParentTypes['Mannequin'] | GQLResolversParentTypes['Organization'] | GQLResolversParentTypes['User'];
  AuditEntry: GQLResolversParentTypes['MembersCanDeleteReposClearAuditEntry'] | GQLResolversParentTypes['MembersCanDeleteReposDisableAuditEntry'] | GQLResolversParentTypes['MembersCanDeleteReposEnableAuditEntry'] | GQLResolversParentTypes['OauthApplicationCreateAuditEntry'] | GQLResolversParentTypes['OrgAddBillingManagerAuditEntry'] | GQLResolversParentTypes['OrgAddMemberAuditEntry'] | GQLResolversParentTypes['OrgBlockUserAuditEntry'] | GQLResolversParentTypes['OrgConfigDisableCollaboratorsOnlyAuditEntry'] | GQLResolversParentTypes['OrgConfigEnableCollaboratorsOnlyAuditEntry'] | GQLResolversParentTypes['OrgCreateAuditEntry'] | GQLResolversParentTypes['OrgDisableOauthAppRestrictionsAuditEntry'] | GQLResolversParentTypes['OrgDisableSamlAuditEntry'] | GQLResolversParentTypes['OrgDisableTwoFactorRequirementAuditEntry'] | GQLResolversParentTypes['OrgEnableOauthAppRestrictionsAuditEntry'] | GQLResolversParentTypes['OrgEnableSamlAuditEntry'] | GQLResolversParentTypes['OrgEnableTwoFactorRequirementAuditEntry'] | GQLResolversParentTypes['OrgInviteMemberAuditEntry'] | GQLResolversParentTypes['OrgInviteToBusinessAuditEntry'] | GQLResolversParentTypes['OrgOauthAppAccessApprovedAuditEntry'] | GQLResolversParentTypes['OrgOauthAppAccessDeniedAuditEntry'] | GQLResolversParentTypes['OrgOauthAppAccessRequestedAuditEntry'] | GQLResolversParentTypes['OrgRemoveBillingManagerAuditEntry'] | GQLResolversParentTypes['OrgRemoveMemberAuditEntry'] | GQLResolversParentTypes['OrgRemoveOutsideCollaboratorAuditEntry'] | GQLResolversParentTypes['OrgRestoreMemberAuditEntry'] | GQLResolversParentTypes['OrgUnblockUserAuditEntry'] | GQLResolversParentTypes['OrgUpdateDefaultRepositoryPermissionAuditEntry'] | GQLResolversParentTypes['OrgUpdateMemberAuditEntry'] | GQLResolversParentTypes['OrgUpdateMemberRepositoryCreationPermissionAuditEntry'] | GQLResolversParentTypes['OrgUpdateMemberRepositoryInvitationPermissionAuditEntry'] | GQLResolversParentTypes['PrivateRepositoryForkingDisableAuditEntry'] | GQLResolversParentTypes['PrivateRepositoryForkingEnableAuditEntry'] | GQLResolversParentTypes['RepoAccessAuditEntry'] | GQLResolversParentTypes['RepoAddMemberAuditEntry'] | GQLResolversParentTypes['RepoAddTopicAuditEntry'] | GQLResolversParentTypes['RepoArchivedAuditEntry'] | GQLResolversParentTypes['RepoChangeMergeSettingAuditEntry'] | GQLResolversParentTypes['RepoConfigDisableAnonymousGitAccessAuditEntry'] | GQLResolversParentTypes['RepoConfigDisableCollaboratorsOnlyAuditEntry'] | GQLResolversParentTypes['RepoConfigDisableContributorsOnlyAuditEntry'] | GQLResolversParentTypes['RepoConfigDisableSockpuppetDisallowedAuditEntry'] | GQLResolversParentTypes['RepoConfigEnableAnonymousGitAccessAuditEntry'] | GQLResolversParentTypes['RepoConfigEnableCollaboratorsOnlyAuditEntry'] | GQLResolversParentTypes['RepoConfigEnableContributorsOnlyAuditEntry'] | GQLResolversParentTypes['RepoConfigEnableSockpuppetDisallowedAuditEntry'] | GQLResolversParentTypes['RepoConfigLockAnonymousGitAccessAuditEntry'] | GQLResolversParentTypes['RepoConfigUnlockAnonymousGitAccessAuditEntry'] | GQLResolversParentTypes['RepoCreateAuditEntry'] | GQLResolversParentTypes['RepoDestroyAuditEntry'] | GQLResolversParentTypes['RepoRemoveMemberAuditEntry'] | GQLResolversParentTypes['RepoRemoveTopicAuditEntry'] | GQLResolversParentTypes['RepositoryVisibilityChangeDisableAuditEntry'] | GQLResolversParentTypes['RepositoryVisibilityChangeEnableAuditEntry'] | GQLResolversParentTypes['TeamAddMemberAuditEntry'] | GQLResolversParentTypes['TeamAddRepositoryAuditEntry'] | GQLResolversParentTypes['TeamChangeParentTeamAuditEntry'] | GQLResolversParentTypes['TeamRemoveMemberAuditEntry'] | GQLResolversParentTypes['TeamRemoveRepositoryAuditEntry'];
  AuditEntryActor: GQLResolversParentTypes['Bot'] | GQLResolversParentTypes['Organization'] | GQLResolversParentTypes['User'];
  AuditLogOrder: GQLAuditLogOrder;
  AutomaticBaseChangeFailedEvent: GQLAutomaticBaseChangeFailedEvent;
  AutomaticBaseChangeSucceededEvent: GQLAutomaticBaseChangeSucceededEvent;
  BaseRefChangedEvent: GQLBaseRefChangedEvent;
  BaseRefForcePushedEvent: GQLBaseRefForcePushedEvent;
  Blame: GQLBlame;
  BlameRange: GQLBlameRange;
  Blob: GQLBlob;
  Boolean: Scalars['Boolean'];
  Bot: GQLBot;
  BranchProtectionRule: GQLBranchProtectionRule;
  BranchProtectionRuleConflict: GQLBranchProtectionRuleConflict;
  BranchProtectionRuleConflictConnection: GQLBranchProtectionRuleConflictConnection;
  BranchProtectionRuleConflictEdge: GQLBranchProtectionRuleConflictEdge;
  BranchProtectionRuleConnection: GQLBranchProtectionRuleConnection;
  BranchProtectionRuleEdge: GQLBranchProtectionRuleEdge;
  CancelEnterpriseAdminInvitationInput: GQLCancelEnterpriseAdminInvitationInput;
  CancelEnterpriseAdminInvitationPayload: GQLCancelEnterpriseAdminInvitationPayload;
  ChangeUserStatusInput: GQLChangeUserStatusInput;
  ChangeUserStatusPayload: GQLChangeUserStatusPayload;
  CheckAnnotation: GQLCheckAnnotation;
  CheckAnnotationConnection: GQLCheckAnnotationConnection;
  CheckAnnotationData: GQLCheckAnnotationData;
  CheckAnnotationEdge: GQLCheckAnnotationEdge;
  CheckAnnotationPosition: GQLCheckAnnotationPosition;
  CheckAnnotationRange: GQLCheckAnnotationRange;
  CheckAnnotationSpan: GQLCheckAnnotationSpan;
  CheckRun: GQLCheckRun;
  CheckRunAction: GQLCheckRunAction;
  CheckRunConnection: GQLCheckRunConnection;
  CheckRunEdge: GQLCheckRunEdge;
  CheckRunFilter: GQLCheckRunFilter;
  CheckRunOutput: GQLCheckRunOutput;
  CheckRunOutputImage: GQLCheckRunOutputImage;
  CheckSuite: GQLCheckSuite;
  CheckSuiteAutoTriggerPreference: GQLCheckSuiteAutoTriggerPreference;
  CheckSuiteConnection: GQLCheckSuiteConnection;
  CheckSuiteEdge: GQLCheckSuiteEdge;
  CheckSuiteFilter: GQLCheckSuiteFilter;
  ClearLabelsFromLabelableInput: GQLClearLabelsFromLabelableInput;
  ClearLabelsFromLabelablePayload: GQLClearLabelsFromLabelablePayload;
  CloneProjectInput: GQLCloneProjectInput;
  CloneProjectPayload: GQLCloneProjectPayload;
  CloneTemplateRepositoryInput: GQLCloneTemplateRepositoryInput;
  CloneTemplateRepositoryPayload: GQLCloneTemplateRepositoryPayload;
  Closable: GQLResolversParentTypes['Issue'] | GQLResolversParentTypes['Milestone'] | GQLResolversParentTypes['Project'] | GQLResolversParentTypes['PullRequest'];
  CloseIssueInput: GQLCloseIssueInput;
  CloseIssuePayload: GQLCloseIssuePayload;
  ClosePullRequestInput: GQLClosePullRequestInput;
  ClosePullRequestPayload: GQLClosePullRequestPayload;
  ClosedEvent: Omit<GQLClosedEvent, 'closer'> & { closer?: Maybe<GQLResolversParentTypes['Closer']> };
  Closer: GQLResolversParentTypes['Commit'] | GQLResolversParentTypes['PullRequest'];
  CodeOfConduct: GQLCodeOfConduct;
  Comment: GQLResolversParentTypes['CommitComment'] | GQLResolversParentTypes['GistComment'] | GQLResolversParentTypes['Issue'] | GQLResolversParentTypes['IssueComment'] | GQLResolversParentTypes['PullRequest'] | GQLResolversParentTypes['PullRequestReview'] | GQLResolversParentTypes['PullRequestReviewComment'] | GQLResolversParentTypes['TeamDiscussion'] | GQLResolversParentTypes['TeamDiscussionComment'];
  CommentDeletedEvent: GQLCommentDeletedEvent;
  Commit: GQLCommit;
  CommitAuthor: GQLCommitAuthor;
  CommitComment: GQLCommitComment;
  CommitCommentConnection: GQLCommitCommentConnection;
  CommitCommentEdge: GQLCommitCommentEdge;
  CommitCommentThread: GQLCommitCommentThread;
  CommitConnection: GQLCommitConnection;
  CommitContributionOrder: GQLCommitContributionOrder;
  CommitContributionsByRepository: GQLCommitContributionsByRepository;
  CommitEdge: GQLCommitEdge;
  CommitHistoryConnection: GQLCommitHistoryConnection;
  ConnectedEvent: Omit<GQLConnectedEvent, 'source' | 'subject'> & { source: GQLResolversParentTypes['ReferencedSubject'], subject: GQLResolversParentTypes['ReferencedSubject'] };
  ContentAttachment: GQLContentAttachment;
  ContentReference: GQLContentReference;
  Contribution: GQLResolversParentTypes['CreatedCommitContribution'] | GQLResolversParentTypes['CreatedIssueContribution'] | GQLResolversParentTypes['CreatedPullRequestContribution'] | GQLResolversParentTypes['CreatedPullRequestReviewContribution'] | GQLResolversParentTypes['CreatedRepositoryContribution'] | GQLResolversParentTypes['JoinedGitHubContribution'] | GQLResolversParentTypes['RestrictedContribution'];
  ContributionCalendar: GQLContributionCalendar;
  ContributionCalendarDay: GQLContributionCalendarDay;
  ContributionCalendarMonth: GQLContributionCalendarMonth;
  ContributionCalendarWeek: GQLContributionCalendarWeek;
  ContributionOrder: GQLContributionOrder;
  ContributionsCollection: Omit<GQLContributionsCollection, 'firstIssueContribution' | 'firstPullRequestContribution' | 'firstRepositoryContribution'> & { firstIssueContribution?: Maybe<GQLResolversParentTypes['CreatedIssueOrRestrictedContribution']>, firstPullRequestContribution?: Maybe<GQLResolversParentTypes['CreatedPullRequestOrRestrictedContribution']>, firstRepositoryContribution?: Maybe<GQLResolversParentTypes['CreatedRepositoryOrRestrictedContribution']> };
  ConvertProjectCardNoteToIssueInput: GQLConvertProjectCardNoteToIssueInput;
  ConvertProjectCardNoteToIssuePayload: GQLConvertProjectCardNoteToIssuePayload;
  ConvertToDraftEvent: GQLConvertToDraftEvent;
  ConvertedNoteToIssueEvent: GQLConvertedNoteToIssueEvent;
  CreateBranchProtectionRuleInput: GQLCreateBranchProtectionRuleInput;
  CreateBranchProtectionRulePayload: GQLCreateBranchProtectionRulePayload;
  CreateCheckRunInput: GQLCreateCheckRunInput;
  CreateCheckRunPayload: GQLCreateCheckRunPayload;
  CreateCheckSuiteInput: GQLCreateCheckSuiteInput;
  CreateCheckSuitePayload: GQLCreateCheckSuitePayload;
  CreateContentAttachmentInput: GQLCreateContentAttachmentInput;
  CreateContentAttachmentPayload: GQLCreateContentAttachmentPayload;
  CreateDeploymentInput: GQLCreateDeploymentInput;
  CreateDeploymentPayload: GQLCreateDeploymentPayload;
  CreateDeploymentStatusInput: GQLCreateDeploymentStatusInput;
  CreateDeploymentStatusPayload: GQLCreateDeploymentStatusPayload;
  CreateEnterpriseOrganizationInput: GQLCreateEnterpriseOrganizationInput;
  CreateEnterpriseOrganizationPayload: GQLCreateEnterpriseOrganizationPayload;
  CreateIpAllowListEntryInput: GQLCreateIpAllowListEntryInput;
  CreateIpAllowListEntryPayload: GQLCreateIpAllowListEntryPayload;
  CreateIssueInput: GQLCreateIssueInput;
  CreateIssuePayload: GQLCreateIssuePayload;
  CreateLabelInput: GQLCreateLabelInput;
  CreateLabelPayload: GQLCreateLabelPayload;
  CreateProjectInput: GQLCreateProjectInput;
  CreateProjectPayload: GQLCreateProjectPayload;
  CreatePullRequestInput: GQLCreatePullRequestInput;
  CreatePullRequestPayload: GQLCreatePullRequestPayload;
  CreateRefInput: GQLCreateRefInput;
  CreateRefPayload: GQLCreateRefPayload;
  CreateRepositoryInput: GQLCreateRepositoryInput;
  CreateRepositoryPayload: GQLCreateRepositoryPayload;
  CreateTeamDiscussionCommentInput: GQLCreateTeamDiscussionCommentInput;
  CreateTeamDiscussionCommentPayload: GQLCreateTeamDiscussionCommentPayload;
  CreateTeamDiscussionInput: GQLCreateTeamDiscussionInput;
  CreateTeamDiscussionPayload: GQLCreateTeamDiscussionPayload;
  CreatedCommitContribution: GQLCreatedCommitContribution;
  CreatedCommitContributionConnection: GQLCreatedCommitContributionConnection;
  CreatedCommitContributionEdge: GQLCreatedCommitContributionEdge;
  CreatedIssueContribution: GQLCreatedIssueContribution;
  CreatedIssueContributionConnection: GQLCreatedIssueContributionConnection;
  CreatedIssueContributionEdge: GQLCreatedIssueContributionEdge;
  CreatedIssueOrRestrictedContribution: GQLResolversParentTypes['CreatedIssueContribution'] | GQLResolversParentTypes['RestrictedContribution'];
  CreatedPullRequestContribution: GQLCreatedPullRequestContribution;
  CreatedPullRequestContributionConnection: GQLCreatedPullRequestContributionConnection;
  CreatedPullRequestContributionEdge: GQLCreatedPullRequestContributionEdge;
  CreatedPullRequestOrRestrictedContribution: GQLResolversParentTypes['CreatedPullRequestContribution'] | GQLResolversParentTypes['RestrictedContribution'];
  CreatedPullRequestReviewContribution: GQLCreatedPullRequestReviewContribution;
  CreatedPullRequestReviewContributionConnection: GQLCreatedPullRequestReviewContributionConnection;
  CreatedPullRequestReviewContributionEdge: GQLCreatedPullRequestReviewContributionEdge;
  CreatedRepositoryContribution: GQLCreatedRepositoryContribution;
  CreatedRepositoryContributionConnection: GQLCreatedRepositoryContributionConnection;
  CreatedRepositoryContributionEdge: GQLCreatedRepositoryContributionEdge;
  CreatedRepositoryOrRestrictedContribution: GQLResolversParentTypes['CreatedRepositoryContribution'] | GQLResolversParentTypes['RestrictedContribution'];
  CrossReferencedEvent: Omit<GQLCrossReferencedEvent, 'source' | 'target'> & { source: GQLResolversParentTypes['ReferencedSubject'], target: GQLResolversParentTypes['ReferencedSubject'] };
  Date: Scalars['Date'];
  DateTime: Scalars['DateTime'];
  DeclineTopicSuggestionInput: GQLDeclineTopicSuggestionInput;
  DeclineTopicSuggestionPayload: GQLDeclineTopicSuggestionPayload;
  Deletable: GQLResolversParentTypes['CommitComment'] | GQLResolversParentTypes['GistComment'] | GQLResolversParentTypes['IssueComment'] | GQLResolversParentTypes['PullRequestReview'] | GQLResolversParentTypes['PullRequestReviewComment'] | GQLResolversParentTypes['TeamDiscussion'] | GQLResolversParentTypes['TeamDiscussionComment'];
  DeleteBranchProtectionRuleInput: GQLDeleteBranchProtectionRuleInput;
  DeleteBranchProtectionRulePayload: GQLDeleteBranchProtectionRulePayload;
  DeleteDeploymentInput: GQLDeleteDeploymentInput;
  DeleteDeploymentPayload: GQLDeleteDeploymentPayload;
  DeleteIpAllowListEntryInput: GQLDeleteIpAllowListEntryInput;
  DeleteIpAllowListEntryPayload: GQLDeleteIpAllowListEntryPayload;
  DeleteIssueCommentInput: GQLDeleteIssueCommentInput;
  DeleteIssueCommentPayload: GQLDeleteIssueCommentPayload;
  DeleteIssueInput: GQLDeleteIssueInput;
  DeleteIssuePayload: GQLDeleteIssuePayload;
  DeleteLabelInput: GQLDeleteLabelInput;
  DeleteLabelPayload: GQLDeleteLabelPayload;
  DeletePackageVersionInput: GQLDeletePackageVersionInput;
  DeletePackageVersionPayload: GQLDeletePackageVersionPayload;
  DeleteProjectCardInput: GQLDeleteProjectCardInput;
  DeleteProjectCardPayload: GQLDeleteProjectCardPayload;
  DeleteProjectColumnInput: GQLDeleteProjectColumnInput;
  DeleteProjectColumnPayload: GQLDeleteProjectColumnPayload;
  DeleteProjectInput: GQLDeleteProjectInput;
  DeleteProjectPayload: GQLDeleteProjectPayload;
  DeletePullRequestReviewCommentInput: GQLDeletePullRequestReviewCommentInput;
  DeletePullRequestReviewCommentPayload: GQLDeletePullRequestReviewCommentPayload;
  DeletePullRequestReviewInput: GQLDeletePullRequestReviewInput;
  DeletePullRequestReviewPayload: GQLDeletePullRequestReviewPayload;
  DeleteRefInput: GQLDeleteRefInput;
  DeleteRefPayload: GQLDeleteRefPayload;
  DeleteTeamDiscussionCommentInput: GQLDeleteTeamDiscussionCommentInput;
  DeleteTeamDiscussionCommentPayload: GQLDeleteTeamDiscussionCommentPayload;
  DeleteTeamDiscussionInput: GQLDeleteTeamDiscussionInput;
  DeleteTeamDiscussionPayload: GQLDeleteTeamDiscussionPayload;
  DemilestonedEvent: Omit<GQLDemilestonedEvent, 'subject'> & { subject: GQLResolversParentTypes['MilestoneItem'] };
  DependencyGraphDependency: GQLDependencyGraphDependency;
  DependencyGraphDependencyConnection: GQLDependencyGraphDependencyConnection;
  DependencyGraphDependencyEdge: GQLDependencyGraphDependencyEdge;
  DependencyGraphManifest: GQLDependencyGraphManifest;
  DependencyGraphManifestConnection: GQLDependencyGraphManifestConnection;
  DependencyGraphManifestEdge: GQLDependencyGraphManifestEdge;
  DeployKey: GQLDeployKey;
  DeployKeyConnection: GQLDeployKeyConnection;
  DeployKeyEdge: GQLDeployKeyEdge;
  DeployedEvent: GQLDeployedEvent;
  Deployment: GQLDeployment;
  DeploymentConnection: GQLDeploymentConnection;
  DeploymentEdge: GQLDeploymentEdge;
  DeploymentEnvironmentChangedEvent: GQLDeploymentEnvironmentChangedEvent;
  DeploymentOrder: GQLDeploymentOrder;
  DeploymentStatus: GQLDeploymentStatus;
  DeploymentStatusConnection: GQLDeploymentStatusConnection;
  DeploymentStatusEdge: GQLDeploymentStatusEdge;
  DisconnectedEvent: Omit<GQLDisconnectedEvent, 'source' | 'subject'> & { source: GQLResolversParentTypes['ReferencedSubject'], subject: GQLResolversParentTypes['ReferencedSubject'] };
  DismissPullRequestReviewInput: GQLDismissPullRequestReviewInput;
  DismissPullRequestReviewPayload: GQLDismissPullRequestReviewPayload;
  DraftPullRequestReviewComment: GQLDraftPullRequestReviewComment;
  DraftPullRequestReviewThread: GQLDraftPullRequestReviewThread;
  Enterprise: GQLEnterprise;
  EnterpriseAdministratorConnection: GQLEnterpriseAdministratorConnection;
  EnterpriseAdministratorEdge: GQLEnterpriseAdministratorEdge;
  EnterpriseAdministratorInvitation: GQLEnterpriseAdministratorInvitation;
  EnterpriseAdministratorInvitationConnection: GQLEnterpriseAdministratorInvitationConnection;
  EnterpriseAdministratorInvitationEdge: GQLEnterpriseAdministratorInvitationEdge;
  EnterpriseAdministratorInvitationOrder: GQLEnterpriseAdministratorInvitationOrder;
  EnterpriseAuditEntryData: GQLResolversParentTypes['MembersCanDeleteReposClearAuditEntry'] | GQLResolversParentTypes['MembersCanDeleteReposDisableAuditEntry'] | GQLResolversParentTypes['MembersCanDeleteReposEnableAuditEntry'] | GQLResolversParentTypes['OrgInviteToBusinessAuditEntry'] | GQLResolversParentTypes['PrivateRepositoryForkingDisableAuditEntry'] | GQLResolversParentTypes['PrivateRepositoryForkingEnableAuditEntry'] | GQLResolversParentTypes['RepositoryVisibilityChangeDisableAuditEntry'] | GQLResolversParentTypes['RepositoryVisibilityChangeEnableAuditEntry'];
  EnterpriseBillingInfo: GQLEnterpriseBillingInfo;
  Float: Scalars['Float'];
  EnterpriseIdentityProvider: GQLEnterpriseIdentityProvider;
  EnterpriseMember: GQLResolversParentTypes['EnterpriseUserAccount'] | GQLResolversParentTypes['User'];
  EnterpriseMemberConnection: Omit<GQLEnterpriseMemberConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<GQLResolversParentTypes['EnterpriseMember']>>> };
  EnterpriseMemberEdge: Omit<GQLEnterpriseMemberEdge, 'node'> & { node?: Maybe<GQLResolversParentTypes['EnterpriseMember']> };
  EnterpriseMemberOrder: GQLEnterpriseMemberOrder;
  EnterpriseOrganizationMembershipConnection: GQLEnterpriseOrganizationMembershipConnection;
  EnterpriseOrganizationMembershipEdge: GQLEnterpriseOrganizationMembershipEdge;
  EnterpriseOutsideCollaboratorConnection: GQLEnterpriseOutsideCollaboratorConnection;
  EnterpriseOutsideCollaboratorEdge: GQLEnterpriseOutsideCollaboratorEdge;
  EnterpriseOwnerInfo: GQLEnterpriseOwnerInfo;
  EnterprisePendingCollaboratorConnection: GQLEnterprisePendingCollaboratorConnection;
  EnterprisePendingCollaboratorEdge: GQLEnterprisePendingCollaboratorEdge;
  EnterprisePendingMemberInvitationConnection: GQLEnterprisePendingMemberInvitationConnection;
  EnterprisePendingMemberInvitationEdge: GQLEnterprisePendingMemberInvitationEdge;
  EnterpriseRepositoryInfo: GQLEnterpriseRepositoryInfo;
  EnterpriseRepositoryInfoConnection: GQLEnterpriseRepositoryInfoConnection;
  EnterpriseRepositoryInfoEdge: GQLEnterpriseRepositoryInfoEdge;
  EnterpriseServerInstallation: GQLEnterpriseServerInstallation;
  EnterpriseServerInstallationConnection: GQLEnterpriseServerInstallationConnection;
  EnterpriseServerInstallationEdge: GQLEnterpriseServerInstallationEdge;
  EnterpriseServerInstallationOrder: GQLEnterpriseServerInstallationOrder;
  EnterpriseServerUserAccount: GQLEnterpriseServerUserAccount;
  EnterpriseServerUserAccountConnection: GQLEnterpriseServerUserAccountConnection;
  EnterpriseServerUserAccountEdge: GQLEnterpriseServerUserAccountEdge;
  EnterpriseServerUserAccountEmail: GQLEnterpriseServerUserAccountEmail;
  EnterpriseServerUserAccountEmailConnection: GQLEnterpriseServerUserAccountEmailConnection;
  EnterpriseServerUserAccountEmailEdge: GQLEnterpriseServerUserAccountEmailEdge;
  EnterpriseServerUserAccountEmailOrder: GQLEnterpriseServerUserAccountEmailOrder;
  EnterpriseServerUserAccountOrder: GQLEnterpriseServerUserAccountOrder;
  EnterpriseServerUserAccountsUpload: GQLEnterpriseServerUserAccountsUpload;
  EnterpriseServerUserAccountsUploadConnection: GQLEnterpriseServerUserAccountsUploadConnection;
  EnterpriseServerUserAccountsUploadEdge: GQLEnterpriseServerUserAccountsUploadEdge;
  EnterpriseServerUserAccountsUploadOrder: GQLEnterpriseServerUserAccountsUploadOrder;
  EnterpriseUserAccount: GQLEnterpriseUserAccount;
  EnterpriseUserAccountConnection: GQLEnterpriseUserAccountConnection;
  EnterpriseUserAccountEdge: GQLEnterpriseUserAccountEdge;
  ExternalIdentity: GQLExternalIdentity;
  ExternalIdentityConnection: GQLExternalIdentityConnection;
  ExternalIdentityEdge: GQLExternalIdentityEdge;
  ExternalIdentitySamlAttributes: GQLExternalIdentitySamlAttributes;
  ExternalIdentityScimAttributes: GQLExternalIdentityScimAttributes;
  FollowUserInput: GQLFollowUserInput;
  FollowUserPayload: GQLFollowUserPayload;
  FollowerConnection: GQLFollowerConnection;
  FollowingConnection: GQLFollowingConnection;
  FundingLink: GQLFundingLink;
  GenericHovercardContext: GQLGenericHovercardContext;
  Gist: GQLGist;
  GistComment: GQLGistComment;
  GistCommentConnection: GQLGistCommentConnection;
  GistCommentEdge: GQLGistCommentEdge;
  GistConnection: GQLGistConnection;
  GistEdge: GQLGistEdge;
  GistFile: GQLGistFile;
  GistOrder: GQLGistOrder;
  GitActor: GQLGitActor;
  GitHubMetadata: GQLGitHubMetadata;
  GitObject: GQLResolversParentTypes['Blob'] | GQLResolversParentTypes['Commit'] | GQLResolversParentTypes['Tag'] | GQLResolversParentTypes['Tree'];
  GitObjectID: Scalars['GitObjectID'];
  GitRefname: Scalars['GitRefname'];
  GitSSHRemote: Scalars['GitSSHRemote'];
  GitSignature: GQLResolversParentTypes['GpgSignature'] | GQLResolversParentTypes['SmimeSignature'] | GQLResolversParentTypes['UnknownSignature'];
  GitTimestamp: Scalars['GitTimestamp'];
  GpgSignature: GQLGpgSignature;
  HTML: Scalars['HTML'];
  HeadRefDeletedEvent: GQLHeadRefDeletedEvent;
  HeadRefForcePushedEvent: GQLHeadRefForcePushedEvent;
  HeadRefRestoredEvent: GQLHeadRefRestoredEvent;
  Hovercard: GQLHovercard;
  HovercardContext: GQLResolversParentTypes['GenericHovercardContext'] | GQLResolversParentTypes['OrganizationTeamsHovercardContext'] | GQLResolversParentTypes['OrganizationsHovercardContext'] | GQLResolversParentTypes['ReviewStatusHovercardContext'] | GQLResolversParentTypes['ViewerHovercardContext'];
  ImportProjectInput: GQLImportProjectInput;
  ImportProjectPayload: GQLImportProjectPayload;
  InviteEnterpriseAdminInput: GQLInviteEnterpriseAdminInput;
  InviteEnterpriseAdminPayload: GQLInviteEnterpriseAdminPayload;
  IpAllowListEntry: Omit<GQLIpAllowListEntry, 'owner'> & { owner: GQLResolversParentTypes['IpAllowListOwner'] };
  IpAllowListEntryConnection: GQLIpAllowListEntryConnection;
  IpAllowListEntryEdge: GQLIpAllowListEntryEdge;
  IpAllowListEntryOrder: GQLIpAllowListEntryOrder;
  IpAllowListOwner: GQLResolversParentTypes['Enterprise'] | GQLResolversParentTypes['Organization'];
  Issue: GQLIssue;
  IssueComment: GQLIssueComment;
  IssueCommentConnection: GQLIssueCommentConnection;
  IssueCommentEdge: GQLIssueCommentEdge;
  IssueConnection: GQLIssueConnection;
  IssueContributionsByRepository: GQLIssueContributionsByRepository;
  IssueEdge: GQLIssueEdge;
  IssueFilters: GQLIssueFilters;
  IssueOrPullRequest: GQLResolversParentTypes['Issue'] | GQLResolversParentTypes['PullRequest'];
  IssueOrder: GQLIssueOrder;
  IssueTimelineConnection: Omit<GQLIssueTimelineConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<GQLResolversParentTypes['IssueTimelineItem']>>> };
  IssueTimelineItem: GQLResolversParentTypes['AssignedEvent'] | GQLResolversParentTypes['ClosedEvent'] | GQLResolversParentTypes['Commit'] | GQLResolversParentTypes['CrossReferencedEvent'] | GQLResolversParentTypes['DemilestonedEvent'] | GQLResolversParentTypes['IssueComment'] | GQLResolversParentTypes['LabeledEvent'] | GQLResolversParentTypes['LockedEvent'] | GQLResolversParentTypes['MilestonedEvent'] | GQLResolversParentTypes['ReferencedEvent'] | GQLResolversParentTypes['RenamedTitleEvent'] | GQLResolversParentTypes['ReopenedEvent'] | GQLResolversParentTypes['SubscribedEvent'] | GQLResolversParentTypes['TransferredEvent'] | GQLResolversParentTypes['UnassignedEvent'] | GQLResolversParentTypes['UnlabeledEvent'] | GQLResolversParentTypes['UnlockedEvent'] | GQLResolversParentTypes['UnsubscribedEvent'] | GQLResolversParentTypes['UserBlockedEvent'];
  IssueTimelineItemEdge: Omit<GQLIssueTimelineItemEdge, 'node'> & { node?: Maybe<GQLResolversParentTypes['IssueTimelineItem']> };
  IssueTimelineItems: GQLResolversParentTypes['AddedToProjectEvent'] | GQLResolversParentTypes['AssignedEvent'] | GQLResolversParentTypes['ClosedEvent'] | GQLResolversParentTypes['CommentDeletedEvent'] | GQLResolversParentTypes['ConnectedEvent'] | GQLResolversParentTypes['ConvertedNoteToIssueEvent'] | GQLResolversParentTypes['CrossReferencedEvent'] | GQLResolversParentTypes['DemilestonedEvent'] | GQLResolversParentTypes['DisconnectedEvent'] | GQLResolversParentTypes['IssueComment'] | GQLResolversParentTypes['LabeledEvent'] | GQLResolversParentTypes['LockedEvent'] | GQLResolversParentTypes['MarkedAsDuplicateEvent'] | GQLResolversParentTypes['MentionedEvent'] | GQLResolversParentTypes['MilestonedEvent'] | GQLResolversParentTypes['MovedColumnsInProjectEvent'] | GQLResolversParentTypes['PinnedEvent'] | GQLResolversParentTypes['ReferencedEvent'] | GQLResolversParentTypes['RemovedFromProjectEvent'] | GQLResolversParentTypes['RenamedTitleEvent'] | GQLResolversParentTypes['ReopenedEvent'] | GQLResolversParentTypes['SubscribedEvent'] | GQLResolversParentTypes['TransferredEvent'] | GQLResolversParentTypes['UnassignedEvent'] | GQLResolversParentTypes['UnlabeledEvent'] | GQLResolversParentTypes['UnlockedEvent'] | GQLResolversParentTypes['UnmarkedAsDuplicateEvent'] | GQLResolversParentTypes['UnpinnedEvent'] | GQLResolversParentTypes['UnsubscribedEvent'] | GQLResolversParentTypes['UserBlockedEvent'];
  IssueTimelineItemsConnection: Omit<GQLIssueTimelineItemsConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<GQLResolversParentTypes['IssueTimelineItems']>>> };
  IssueTimelineItemsEdge: Omit<GQLIssueTimelineItemsEdge, 'node'> & { node?: Maybe<GQLResolversParentTypes['IssueTimelineItems']> };
  JoinedGitHubContribution: GQLJoinedGitHubContribution;
  Label: GQLLabel;
  LabelConnection: GQLLabelConnection;
  LabelEdge: GQLLabelEdge;
  LabelOrder: GQLLabelOrder;
  Labelable: GQLResolversParentTypes['Issue'] | GQLResolversParentTypes['PullRequest'];
  LabeledEvent: GQLLabeledEvent;
  Language: GQLLanguage;
  LanguageConnection: GQLLanguageConnection;
  LanguageEdge: GQLLanguageEdge;
  LanguageOrder: GQLLanguageOrder;
  License: GQLLicense;
  LicenseRule: GQLLicenseRule;
  LinkRepositoryToProjectInput: GQLLinkRepositoryToProjectInput;
  LinkRepositoryToProjectPayload: GQLLinkRepositoryToProjectPayload;
  LockLockableInput: GQLLockLockableInput;
  LockLockablePayload: GQLLockLockablePayload;
  Lockable: GQLResolversParentTypes['Issue'] | GQLResolversParentTypes['PullRequest'];
  LockedEvent: GQLLockedEvent;
  Mannequin: GQLMannequin;
  MarkPullRequestReadyForReviewInput: GQLMarkPullRequestReadyForReviewInput;
  MarkPullRequestReadyForReviewPayload: GQLMarkPullRequestReadyForReviewPayload;
  MarkedAsDuplicateEvent: GQLMarkedAsDuplicateEvent;
  MarketplaceCategory: GQLMarketplaceCategory;
  MarketplaceListing: GQLMarketplaceListing;
  MarketplaceListingConnection: GQLMarketplaceListingConnection;
  MarketplaceListingEdge: GQLMarketplaceListingEdge;
  MemberStatusable: GQLResolversParentTypes['Organization'] | GQLResolversParentTypes['Team'];
  MembersCanDeleteReposClearAuditEntry: Omit<GQLMembersCanDeleteReposClearAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  MembersCanDeleteReposDisableAuditEntry: Omit<GQLMembersCanDeleteReposDisableAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  MembersCanDeleteReposEnableAuditEntry: Omit<GQLMembersCanDeleteReposEnableAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  MentionedEvent: GQLMentionedEvent;
  MergeBranchInput: GQLMergeBranchInput;
  MergeBranchPayload: GQLMergeBranchPayload;
  MergePullRequestInput: GQLMergePullRequestInput;
  MergePullRequestPayload: GQLMergePullRequestPayload;
  MergedEvent: GQLMergedEvent;
  Milestone: GQLMilestone;
  MilestoneConnection: GQLMilestoneConnection;
  MilestoneEdge: GQLMilestoneEdge;
  MilestoneItem: GQLResolversParentTypes['Issue'] | GQLResolversParentTypes['PullRequest'];
  MilestoneOrder: GQLMilestoneOrder;
  MilestonedEvent: Omit<GQLMilestonedEvent, 'subject'> & { subject: GQLResolversParentTypes['MilestoneItem'] };
  Minimizable: GQLResolversParentTypes['CommitComment'] | GQLResolversParentTypes['GistComment'] | GQLResolversParentTypes['IssueComment'] | GQLResolversParentTypes['PullRequestReviewComment'];
  MinimizeCommentInput: GQLMinimizeCommentInput;
  MinimizeCommentPayload: GQLMinimizeCommentPayload;
  MoveProjectCardInput: GQLMoveProjectCardInput;
  MoveProjectCardPayload: GQLMoveProjectCardPayload;
  MoveProjectColumnInput: GQLMoveProjectColumnInput;
  MoveProjectColumnPayload: GQLMoveProjectColumnPayload;
  MovedColumnsInProjectEvent: GQLMovedColumnsInProjectEvent;
  Mutation: {};
  Node: GQLResolversParentTypes['AddedToProjectEvent'] | GQLResolversParentTypes['App'] | GQLResolversParentTypes['AssignedEvent'] | GQLResolversParentTypes['AutomaticBaseChangeFailedEvent'] | GQLResolversParentTypes['AutomaticBaseChangeSucceededEvent'] | GQLResolversParentTypes['BaseRefChangedEvent'] | GQLResolversParentTypes['BaseRefForcePushedEvent'] | GQLResolversParentTypes['Blob'] | GQLResolversParentTypes['Bot'] | GQLResolversParentTypes['BranchProtectionRule'] | GQLResolversParentTypes['CheckRun'] | GQLResolversParentTypes['CheckSuite'] | GQLResolversParentTypes['ClosedEvent'] | GQLResolversParentTypes['CodeOfConduct'] | GQLResolversParentTypes['CommentDeletedEvent'] | GQLResolversParentTypes['Commit'] | GQLResolversParentTypes['CommitComment'] | GQLResolversParentTypes['CommitCommentThread'] | GQLResolversParentTypes['ConnectedEvent'] | GQLResolversParentTypes['ConvertToDraftEvent'] | GQLResolversParentTypes['ConvertedNoteToIssueEvent'] | GQLResolversParentTypes['CrossReferencedEvent'] | GQLResolversParentTypes['DemilestonedEvent'] | GQLResolversParentTypes['DependencyGraphManifest'] | GQLResolversParentTypes['DeployKey'] | GQLResolversParentTypes['DeployedEvent'] | GQLResolversParentTypes['Deployment'] | GQLResolversParentTypes['DeploymentEnvironmentChangedEvent'] | GQLResolversParentTypes['DeploymentStatus'] | GQLResolversParentTypes['DisconnectedEvent'] | GQLResolversParentTypes['Enterprise'] | GQLResolversParentTypes['EnterpriseAdministratorInvitation'] | GQLResolversParentTypes['EnterpriseIdentityProvider'] | GQLResolversParentTypes['EnterpriseRepositoryInfo'] | GQLResolversParentTypes['EnterpriseServerInstallation'] | GQLResolversParentTypes['EnterpriseServerUserAccount'] | GQLResolversParentTypes['EnterpriseServerUserAccountEmail'] | GQLResolversParentTypes['EnterpriseServerUserAccountsUpload'] | GQLResolversParentTypes['EnterpriseUserAccount'] | GQLResolversParentTypes['ExternalIdentity'] | GQLResolversParentTypes['Gist'] | GQLResolversParentTypes['GistComment'] | GQLResolversParentTypes['HeadRefDeletedEvent'] | GQLResolversParentTypes['HeadRefForcePushedEvent'] | GQLResolversParentTypes['HeadRefRestoredEvent'] | GQLResolversParentTypes['IpAllowListEntry'] | GQLResolversParentTypes['Issue'] | GQLResolversParentTypes['IssueComment'] | GQLResolversParentTypes['Label'] | GQLResolversParentTypes['LabeledEvent'] | GQLResolversParentTypes['Language'] | GQLResolversParentTypes['License'] | GQLResolversParentTypes['LockedEvent'] | GQLResolversParentTypes['Mannequin'] | GQLResolversParentTypes['MarkedAsDuplicateEvent'] | GQLResolversParentTypes['MarketplaceCategory'] | GQLResolversParentTypes['MarketplaceListing'] | GQLResolversParentTypes['MembersCanDeleteReposClearAuditEntry'] | GQLResolversParentTypes['MembersCanDeleteReposDisableAuditEntry'] | GQLResolversParentTypes['MembersCanDeleteReposEnableAuditEntry'] | GQLResolversParentTypes['MentionedEvent'] | GQLResolversParentTypes['MergedEvent'] | GQLResolversParentTypes['Milestone'] | GQLResolversParentTypes['MilestonedEvent'] | GQLResolversParentTypes['MovedColumnsInProjectEvent'] | GQLResolversParentTypes['OauthApplicationCreateAuditEntry'] | GQLResolversParentTypes['OrgAddBillingManagerAuditEntry'] | GQLResolversParentTypes['OrgAddMemberAuditEntry'] | GQLResolversParentTypes['OrgBlockUserAuditEntry'] | GQLResolversParentTypes['OrgConfigDisableCollaboratorsOnlyAuditEntry'] | GQLResolversParentTypes['OrgConfigEnableCollaboratorsOnlyAuditEntry'] | GQLResolversParentTypes['OrgCreateAuditEntry'] | GQLResolversParentTypes['OrgDisableOauthAppRestrictionsAuditEntry'] | GQLResolversParentTypes['OrgDisableSamlAuditEntry'] | GQLResolversParentTypes['OrgDisableTwoFactorRequirementAuditEntry'] | GQLResolversParentTypes['OrgEnableOauthAppRestrictionsAuditEntry'] | GQLResolversParentTypes['OrgEnableSamlAuditEntry'] | GQLResolversParentTypes['OrgEnableTwoFactorRequirementAuditEntry'] | GQLResolversParentTypes['OrgInviteMemberAuditEntry'] | GQLResolversParentTypes['OrgInviteToBusinessAuditEntry'] | GQLResolversParentTypes['OrgOauthAppAccessApprovedAuditEntry'] | GQLResolversParentTypes['OrgOauthAppAccessDeniedAuditEntry'] | GQLResolversParentTypes['OrgOauthAppAccessRequestedAuditEntry'] | GQLResolversParentTypes['OrgRemoveBillingManagerAuditEntry'] | GQLResolversParentTypes['OrgRemoveMemberAuditEntry'] | GQLResolversParentTypes['OrgRemoveOutsideCollaboratorAuditEntry'] | GQLResolversParentTypes['OrgRestoreMemberAuditEntry'] | GQLResolversParentTypes['OrgUnblockUserAuditEntry'] | GQLResolversParentTypes['OrgUpdateDefaultRepositoryPermissionAuditEntry'] | GQLResolversParentTypes['OrgUpdateMemberAuditEntry'] | GQLResolversParentTypes['OrgUpdateMemberRepositoryCreationPermissionAuditEntry'] | GQLResolversParentTypes['OrgUpdateMemberRepositoryInvitationPermissionAuditEntry'] | GQLResolversParentTypes['Organization'] | GQLResolversParentTypes['OrganizationIdentityProvider'] | GQLResolversParentTypes['OrganizationInvitation'] | GQLResolversParentTypes['Package'] | GQLResolversParentTypes['PackageFile'] | GQLResolversParentTypes['PackageTag'] | GQLResolversParentTypes['PackageVersion'] | GQLResolversParentTypes['PinnedEvent'] | GQLResolversParentTypes['PinnedIssue'] | GQLResolversParentTypes['PrivateRepositoryForkingDisableAuditEntry'] | GQLResolversParentTypes['PrivateRepositoryForkingEnableAuditEntry'] | GQLResolversParentTypes['Project'] | GQLResolversParentTypes['ProjectCard'] | GQLResolversParentTypes['ProjectColumn'] | GQLResolversParentTypes['PublicKey'] | GQLResolversParentTypes['PullRequest'] | GQLResolversParentTypes['PullRequestCommit'] | GQLResolversParentTypes['PullRequestCommitCommentThread'] | GQLResolversParentTypes['PullRequestReview'] | GQLResolversParentTypes['PullRequestReviewComment'] | GQLResolversParentTypes['PullRequestReviewThread'] | GQLResolversParentTypes['Push'] | GQLResolversParentTypes['PushAllowance'] | GQLResolversParentTypes['Reaction'] | GQLResolversParentTypes['ReadyForReviewEvent'] | GQLResolversParentTypes['Ref'] | GQLResolversParentTypes['ReferencedEvent'] | GQLResolversParentTypes['RegistryPackage'] | GQLResolversParentTypes['RegistryPackageDependency'] | GQLResolversParentTypes['RegistryPackageFile'] | GQLResolversParentTypes['RegistryPackageTag'] | GQLResolversParentTypes['RegistryPackageVersion'] | GQLResolversParentTypes['Release'] | GQLResolversParentTypes['ReleaseAsset'] | GQLResolversParentTypes['RemovedFromProjectEvent'] | GQLResolversParentTypes['RenamedTitleEvent'] | GQLResolversParentTypes['ReopenedEvent'] | GQLResolversParentTypes['RepoAccessAuditEntry'] | GQLResolversParentTypes['RepoAddMemberAuditEntry'] | GQLResolversParentTypes['RepoAddTopicAuditEntry'] | GQLResolversParentTypes['RepoArchivedAuditEntry'] | GQLResolversParentTypes['RepoChangeMergeSettingAuditEntry'] | GQLResolversParentTypes['RepoConfigDisableAnonymousGitAccessAuditEntry'] | GQLResolversParentTypes['RepoConfigDisableCollaboratorsOnlyAuditEntry'] | GQLResolversParentTypes['RepoConfigDisableContributorsOnlyAuditEntry'] | GQLResolversParentTypes['RepoConfigDisableSockpuppetDisallowedAuditEntry'] | GQLResolversParentTypes['RepoConfigEnableAnonymousGitAccessAuditEntry'] | GQLResolversParentTypes['RepoConfigEnableCollaboratorsOnlyAuditEntry'] | GQLResolversParentTypes['RepoConfigEnableContributorsOnlyAuditEntry'] | GQLResolversParentTypes['RepoConfigEnableSockpuppetDisallowedAuditEntry'] | GQLResolversParentTypes['RepoConfigLockAnonymousGitAccessAuditEntry'] | GQLResolversParentTypes['RepoConfigUnlockAnonymousGitAccessAuditEntry'] | GQLResolversParentTypes['RepoCreateAuditEntry'] | GQLResolversParentTypes['RepoDestroyAuditEntry'] | GQLResolversParentTypes['RepoRemoveMemberAuditEntry'] | GQLResolversParentTypes['RepoRemoveTopicAuditEntry'] | GQLResolversParentTypes['Repository'] | GQLResolversParentTypes['RepositoryInvitation'] | GQLResolversParentTypes['RepositoryTopic'] | GQLResolversParentTypes['RepositoryVisibilityChangeDisableAuditEntry'] | GQLResolversParentTypes['RepositoryVisibilityChangeEnableAuditEntry'] | GQLResolversParentTypes['RepositoryVulnerabilityAlert'] | GQLResolversParentTypes['ReviewDismissalAllowance'] | GQLResolversParentTypes['ReviewDismissedEvent'] | GQLResolversParentTypes['ReviewRequest'] | GQLResolversParentTypes['ReviewRequestRemovedEvent'] | GQLResolversParentTypes['ReviewRequestedEvent'] | GQLResolversParentTypes['SavedReply'] | GQLResolversParentTypes['SecurityAdvisory'] | GQLResolversParentTypes['SponsorsListing'] | GQLResolversParentTypes['SponsorsTier'] | GQLResolversParentTypes['Sponsorship'] | GQLResolversParentTypes['Status'] | GQLResolversParentTypes['StatusCheckRollup'] | GQLResolversParentTypes['StatusContext'] | GQLResolversParentTypes['SubscribedEvent'] | GQLResolversParentTypes['Tag'] | GQLResolversParentTypes['Team'] | GQLResolversParentTypes['TeamAddMemberAuditEntry'] | GQLResolversParentTypes['TeamAddRepositoryAuditEntry'] | GQLResolversParentTypes['TeamChangeParentTeamAuditEntry'] | GQLResolversParentTypes['TeamDiscussion'] | GQLResolversParentTypes['TeamDiscussionComment'] | GQLResolversParentTypes['TeamRemoveMemberAuditEntry'] | GQLResolversParentTypes['TeamRemoveRepositoryAuditEntry'] | GQLResolversParentTypes['Topic'] | GQLResolversParentTypes['TransferredEvent'] | GQLResolversParentTypes['Tree'] | GQLResolversParentTypes['UnassignedEvent'] | GQLResolversParentTypes['UnlabeledEvent'] | GQLResolversParentTypes['UnlockedEvent'] | GQLResolversParentTypes['UnmarkedAsDuplicateEvent'] | GQLResolversParentTypes['UnpinnedEvent'] | GQLResolversParentTypes['UnsubscribedEvent'] | GQLResolversParentTypes['User'] | GQLResolversParentTypes['UserBlockedEvent'] | GQLResolversParentTypes['UserContentEdit'] | GQLResolversParentTypes['UserStatus'];
  OauthApplicationAuditEntryData: GQLResolversParentTypes['OauthApplicationCreateAuditEntry'] | GQLResolversParentTypes['OrgOauthAppAccessApprovedAuditEntry'] | GQLResolversParentTypes['OrgOauthAppAccessDeniedAuditEntry'] | GQLResolversParentTypes['OrgOauthAppAccessRequestedAuditEntry'];
  OauthApplicationCreateAuditEntry: Omit<GQLOauthApplicationCreateAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgAddBillingManagerAuditEntry: Omit<GQLOrgAddBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgAddMemberAuditEntry: Omit<GQLOrgAddMemberAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgBlockUserAuditEntry: Omit<GQLOrgBlockUserAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgConfigDisableCollaboratorsOnlyAuditEntry: Omit<GQLOrgConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgConfigEnableCollaboratorsOnlyAuditEntry: Omit<GQLOrgConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgCreateAuditEntry: Omit<GQLOrgCreateAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgDisableOauthAppRestrictionsAuditEntry: Omit<GQLOrgDisableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgDisableSamlAuditEntry: Omit<GQLOrgDisableSamlAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgDisableTwoFactorRequirementAuditEntry: Omit<GQLOrgDisableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgEnableOauthAppRestrictionsAuditEntry: Omit<GQLOrgEnableOauthAppRestrictionsAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgEnableSamlAuditEntry: Omit<GQLOrgEnableSamlAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgEnableTwoFactorRequirementAuditEntry: Omit<GQLOrgEnableTwoFactorRequirementAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgInviteMemberAuditEntry: Omit<GQLOrgInviteMemberAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgInviteToBusinessAuditEntry: Omit<GQLOrgInviteToBusinessAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgOauthAppAccessApprovedAuditEntry: Omit<GQLOrgOauthAppAccessApprovedAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgOauthAppAccessDeniedAuditEntry: Omit<GQLOrgOauthAppAccessDeniedAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgOauthAppAccessRequestedAuditEntry: Omit<GQLOrgOauthAppAccessRequestedAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgRemoveBillingManagerAuditEntry: Omit<GQLOrgRemoveBillingManagerAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgRemoveMemberAuditEntry: Omit<GQLOrgRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgRemoveOutsideCollaboratorAuditEntry: Omit<GQLOrgRemoveOutsideCollaboratorAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgRestoreMemberAuditEntry: Omit<GQLOrgRestoreMemberAuditEntry, 'actor' | 'restoredMemberships'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']>, restoredMemberships?: Maybe<Array<GQLResolversParentTypes['OrgRestoreMemberAuditEntryMembership']>> };
  OrgRestoreMemberAuditEntryMembership: GQLResolversParentTypes['OrgRestoreMemberMembershipOrganizationAuditEntryData'] | GQLResolversParentTypes['OrgRestoreMemberMembershipRepositoryAuditEntryData'] | GQLResolversParentTypes['OrgRestoreMemberMembershipTeamAuditEntryData'];
  OrgRestoreMemberMembershipOrganizationAuditEntryData: GQLOrgRestoreMemberMembershipOrganizationAuditEntryData;
  OrgRestoreMemberMembershipRepositoryAuditEntryData: GQLOrgRestoreMemberMembershipRepositoryAuditEntryData;
  OrgRestoreMemberMembershipTeamAuditEntryData: GQLOrgRestoreMemberMembershipTeamAuditEntryData;
  OrgUnblockUserAuditEntry: Omit<GQLOrgUnblockUserAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgUpdateDefaultRepositoryPermissionAuditEntry: Omit<GQLOrgUpdateDefaultRepositoryPermissionAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgUpdateMemberAuditEntry: Omit<GQLOrgUpdateMemberAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgUpdateMemberRepositoryCreationPermissionAuditEntry: Omit<GQLOrgUpdateMemberRepositoryCreationPermissionAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  OrgUpdateMemberRepositoryInvitationPermissionAuditEntry: Omit<GQLOrgUpdateMemberRepositoryInvitationPermissionAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  Organization: GQLOrganization;
  OrganizationAuditEntry: GQLResolversParentTypes['MembersCanDeleteReposClearAuditEntry'] | GQLResolversParentTypes['MembersCanDeleteReposDisableAuditEntry'] | GQLResolversParentTypes['MembersCanDeleteReposEnableAuditEntry'] | GQLResolversParentTypes['OauthApplicationCreateAuditEntry'] | GQLResolversParentTypes['OrgAddBillingManagerAuditEntry'] | GQLResolversParentTypes['OrgAddMemberAuditEntry'] | GQLResolversParentTypes['OrgBlockUserAuditEntry'] | GQLResolversParentTypes['OrgConfigDisableCollaboratorsOnlyAuditEntry'] | GQLResolversParentTypes['OrgConfigEnableCollaboratorsOnlyAuditEntry'] | GQLResolversParentTypes['OrgCreateAuditEntry'] | GQLResolversParentTypes['OrgDisableOauthAppRestrictionsAuditEntry'] | GQLResolversParentTypes['OrgDisableSamlAuditEntry'] | GQLResolversParentTypes['OrgDisableTwoFactorRequirementAuditEntry'] | GQLResolversParentTypes['OrgEnableOauthAppRestrictionsAuditEntry'] | GQLResolversParentTypes['OrgEnableSamlAuditEntry'] | GQLResolversParentTypes['OrgEnableTwoFactorRequirementAuditEntry'] | GQLResolversParentTypes['OrgInviteMemberAuditEntry'] | GQLResolversParentTypes['OrgInviteToBusinessAuditEntry'] | GQLResolversParentTypes['OrgOauthAppAccessApprovedAuditEntry'] | GQLResolversParentTypes['OrgOauthAppAccessDeniedAuditEntry'] | GQLResolversParentTypes['OrgOauthAppAccessRequestedAuditEntry'] | GQLResolversParentTypes['OrgRemoveBillingManagerAuditEntry'] | GQLResolversParentTypes['OrgRemoveMemberAuditEntry'] | GQLResolversParentTypes['OrgRemoveOutsideCollaboratorAuditEntry'] | GQLResolversParentTypes['OrgRestoreMemberAuditEntry'] | GQLResolversParentTypes['OrgUnblockUserAuditEntry'] | GQLResolversParentTypes['OrgUpdateDefaultRepositoryPermissionAuditEntry'] | GQLResolversParentTypes['OrgUpdateMemberAuditEntry'] | GQLResolversParentTypes['OrgUpdateMemberRepositoryCreationPermissionAuditEntry'] | GQLResolversParentTypes['OrgUpdateMemberRepositoryInvitationPermissionAuditEntry'] | GQLResolversParentTypes['PrivateRepositoryForkingDisableAuditEntry'] | GQLResolversParentTypes['PrivateRepositoryForkingEnableAuditEntry'] | GQLResolversParentTypes['RepoAccessAuditEntry'] | GQLResolversParentTypes['RepoAddMemberAuditEntry'] | GQLResolversParentTypes['RepoAddTopicAuditEntry'] | GQLResolversParentTypes['RepoArchivedAuditEntry'] | GQLResolversParentTypes['RepoChangeMergeSettingAuditEntry'] | GQLResolversParentTypes['RepoConfigDisableAnonymousGitAccessAuditEntry'] | GQLResolversParentTypes['RepoConfigDisableCollaboratorsOnlyAuditEntry'] | GQLResolversParentTypes['RepoConfigDisableContributorsOnlyAuditEntry'] | GQLResolversParentTypes['RepoConfigDisableSockpuppetDisallowedAuditEntry'] | GQLResolversParentTypes['RepoConfigEnableAnonymousGitAccessAuditEntry'] | GQLResolversParentTypes['RepoConfigEnableCollaboratorsOnlyAuditEntry'] | GQLResolversParentTypes['RepoConfigEnableContributorsOnlyAuditEntry'] | GQLResolversParentTypes['RepoConfigEnableSockpuppetDisallowedAuditEntry'] | GQLResolversParentTypes['RepoConfigLockAnonymousGitAccessAuditEntry'] | GQLResolversParentTypes['RepoConfigUnlockAnonymousGitAccessAuditEntry'] | GQLResolversParentTypes['RepoCreateAuditEntry'] | GQLResolversParentTypes['RepoDestroyAuditEntry'] | GQLResolversParentTypes['RepoRemoveMemberAuditEntry'] | GQLResolversParentTypes['RepoRemoveTopicAuditEntry'] | GQLResolversParentTypes['RepositoryVisibilityChangeDisableAuditEntry'] | GQLResolversParentTypes['RepositoryVisibilityChangeEnableAuditEntry'] | GQLResolversParentTypes['TeamAddMemberAuditEntry'] | GQLResolversParentTypes['TeamAddRepositoryAuditEntry'] | GQLResolversParentTypes['TeamChangeParentTeamAuditEntry'] | GQLResolversParentTypes['TeamRemoveMemberAuditEntry'] | GQLResolversParentTypes['TeamRemoveRepositoryAuditEntry'];
  OrganizationAuditEntryConnection: Omit<GQLOrganizationAuditEntryConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<GQLResolversParentTypes['OrganizationAuditEntry']>>> };
  OrganizationAuditEntryData: GQLResolversParentTypes['MembersCanDeleteReposClearAuditEntry'] | GQLResolversParentTypes['MembersCanDeleteReposDisableAuditEntry'] | GQLResolversParentTypes['MembersCanDeleteReposEnableAuditEntry'] | GQLResolversParentTypes['OauthApplicationCreateAuditEntry'] | GQLResolversParentTypes['OrgAddBillingManagerAuditEntry'] | GQLResolversParentTypes['OrgAddMemberAuditEntry'] | GQLResolversParentTypes['OrgBlockUserAuditEntry'] | GQLResolversParentTypes['OrgConfigDisableCollaboratorsOnlyAuditEntry'] | GQLResolversParentTypes['OrgConfigEnableCollaboratorsOnlyAuditEntry'] | GQLResolversParentTypes['OrgCreateAuditEntry'] | GQLResolversParentTypes['OrgDisableOauthAppRestrictionsAuditEntry'] | GQLResolversParentTypes['OrgDisableSamlAuditEntry'] | GQLResolversParentTypes['OrgDisableTwoFactorRequirementAuditEntry'] | GQLResolversParentTypes['OrgEnableOauthAppRestrictionsAuditEntry'] | GQLResolversParentTypes['OrgEnableSamlAuditEntry'] | GQLResolversParentTypes['OrgEnableTwoFactorRequirementAuditEntry'] | GQLResolversParentTypes['OrgInviteMemberAuditEntry'] | GQLResolversParentTypes['OrgInviteToBusinessAuditEntry'] | GQLResolversParentTypes['OrgOauthAppAccessApprovedAuditEntry'] | GQLResolversParentTypes['OrgOauthAppAccessDeniedAuditEntry'] | GQLResolversParentTypes['OrgOauthAppAccessRequestedAuditEntry'] | GQLResolversParentTypes['OrgRemoveBillingManagerAuditEntry'] | GQLResolversParentTypes['OrgRemoveMemberAuditEntry'] | GQLResolversParentTypes['OrgRemoveOutsideCollaboratorAuditEntry'] | GQLResolversParentTypes['OrgRestoreMemberAuditEntry'] | GQLResolversParentTypes['OrgRestoreMemberMembershipOrganizationAuditEntryData'] | GQLResolversParentTypes['OrgUnblockUserAuditEntry'] | GQLResolversParentTypes['OrgUpdateDefaultRepositoryPermissionAuditEntry'] | GQLResolversParentTypes['OrgUpdateMemberAuditEntry'] | GQLResolversParentTypes['OrgUpdateMemberRepositoryCreationPermissionAuditEntry'] | GQLResolversParentTypes['OrgUpdateMemberRepositoryInvitationPermissionAuditEntry'] | GQLResolversParentTypes['PrivateRepositoryForkingDisableAuditEntry'] | GQLResolversParentTypes['PrivateRepositoryForkingEnableAuditEntry'] | GQLResolversParentTypes['RepoAccessAuditEntry'] | GQLResolversParentTypes['RepoAddMemberAuditEntry'] | GQLResolversParentTypes['RepoAddTopicAuditEntry'] | GQLResolversParentTypes['RepoArchivedAuditEntry'] | GQLResolversParentTypes['RepoChangeMergeSettingAuditEntry'] | GQLResolversParentTypes['RepoConfigDisableAnonymousGitAccessAuditEntry'] | GQLResolversParentTypes['RepoConfigDisableCollaboratorsOnlyAuditEntry'] | GQLResolversParentTypes['RepoConfigDisableContributorsOnlyAuditEntry'] | GQLResolversParentTypes['RepoConfigDisableSockpuppetDisallowedAuditEntry'] | GQLResolversParentTypes['RepoConfigEnableAnonymousGitAccessAuditEntry'] | GQLResolversParentTypes['RepoConfigEnableCollaboratorsOnlyAuditEntry'] | GQLResolversParentTypes['RepoConfigEnableContributorsOnlyAuditEntry'] | GQLResolversParentTypes['RepoConfigEnableSockpuppetDisallowedAuditEntry'] | GQLResolversParentTypes['RepoConfigLockAnonymousGitAccessAuditEntry'] | GQLResolversParentTypes['RepoConfigUnlockAnonymousGitAccessAuditEntry'] | GQLResolversParentTypes['RepoCreateAuditEntry'] | GQLResolversParentTypes['RepoDestroyAuditEntry'] | GQLResolversParentTypes['RepoRemoveMemberAuditEntry'] | GQLResolversParentTypes['RepoRemoveTopicAuditEntry'] | GQLResolversParentTypes['RepositoryVisibilityChangeDisableAuditEntry'] | GQLResolversParentTypes['RepositoryVisibilityChangeEnableAuditEntry'] | GQLResolversParentTypes['TeamAddMemberAuditEntry'] | GQLResolversParentTypes['TeamAddRepositoryAuditEntry'] | GQLResolversParentTypes['TeamChangeParentTeamAuditEntry'] | GQLResolversParentTypes['TeamRemoveMemberAuditEntry'] | GQLResolversParentTypes['TeamRemoveRepositoryAuditEntry'];
  OrganizationAuditEntryEdge: Omit<GQLOrganizationAuditEntryEdge, 'node'> & { node?: Maybe<GQLResolversParentTypes['OrganizationAuditEntry']> };
  OrganizationConnection: GQLOrganizationConnection;
  OrganizationEdge: GQLOrganizationEdge;
  OrganizationIdentityProvider: GQLOrganizationIdentityProvider;
  OrganizationInvitation: GQLOrganizationInvitation;
  OrganizationInvitationConnection: GQLOrganizationInvitationConnection;
  OrganizationInvitationEdge: GQLOrganizationInvitationEdge;
  OrganizationMemberConnection: GQLOrganizationMemberConnection;
  OrganizationMemberEdge: GQLOrganizationMemberEdge;
  OrganizationOrder: GQLOrganizationOrder;
  OrganizationTeamsHovercardContext: GQLOrganizationTeamsHovercardContext;
  OrganizationsHovercardContext: GQLOrganizationsHovercardContext;
  Package: GQLPackage;
  PackageConnection: GQLPackageConnection;
  PackageEdge: GQLPackageEdge;
  PackageFile: GQLPackageFile;
  PackageFileConnection: GQLPackageFileConnection;
  PackageFileEdge: GQLPackageFileEdge;
  PackageFileOrder: GQLPackageFileOrder;
  PackageOrder: GQLPackageOrder;
  PackageOwner: GQLResolversParentTypes['Organization'] | GQLResolversParentTypes['Repository'] | GQLResolversParentTypes['User'];
  PackageStatistics: GQLPackageStatistics;
  PackageTag: GQLPackageTag;
  PackageVersion: GQLPackageVersion;
  PackageVersionConnection: GQLPackageVersionConnection;
  PackageVersionEdge: GQLPackageVersionEdge;
  PackageVersionOrder: GQLPackageVersionOrder;
  PackageVersionStatistics: GQLPackageVersionStatistics;
  PageInfo: GQLPageInfo;
  PermissionGranter: GQLResolversParentTypes['Organization'] | GQLResolversParentTypes['Repository'] | GQLResolversParentTypes['Team'];
  PermissionSource: Omit<GQLPermissionSource, 'source'> & { source: GQLResolversParentTypes['PermissionGranter'] };
  PinIssueInput: GQLPinIssueInput;
  PinIssuePayload: GQLPinIssuePayload;
  PinnableItem: GQLResolversParentTypes['Gist'] | GQLResolversParentTypes['Repository'];
  PinnableItemConnection: Omit<GQLPinnableItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<GQLResolversParentTypes['PinnableItem']>>> };
  PinnableItemEdge: Omit<GQLPinnableItemEdge, 'node'> & { node?: Maybe<GQLResolversParentTypes['PinnableItem']> };
  PinnedEvent: GQLPinnedEvent;
  PinnedIssue: GQLPinnedIssue;
  PinnedIssueConnection: GQLPinnedIssueConnection;
  PinnedIssueEdge: GQLPinnedIssueEdge;
  PreciseDateTime: Scalars['PreciseDateTime'];
  PrivateRepositoryForkingDisableAuditEntry: Omit<GQLPrivateRepositoryForkingDisableAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  PrivateRepositoryForkingEnableAuditEntry: Omit<GQLPrivateRepositoryForkingEnableAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  ProfileItemShowcase: GQLProfileItemShowcase;
  ProfileOwner: GQLResolversParentTypes['Organization'] | GQLResolversParentTypes['User'];
  Project: GQLProject;
  ProjectCard: Omit<GQLProjectCard, 'content'> & { content?: Maybe<GQLResolversParentTypes['ProjectCardItem']> };
  ProjectCardConnection: GQLProjectCardConnection;
  ProjectCardEdge: GQLProjectCardEdge;
  ProjectCardImport: GQLProjectCardImport;
  ProjectCardItem: GQLResolversParentTypes['Issue'] | GQLResolversParentTypes['PullRequest'];
  ProjectColumn: GQLProjectColumn;
  ProjectColumnConnection: GQLProjectColumnConnection;
  ProjectColumnEdge: GQLProjectColumnEdge;
  ProjectColumnImport: GQLProjectColumnImport;
  ProjectConnection: GQLProjectConnection;
  ProjectEdge: GQLProjectEdge;
  ProjectOrder: GQLProjectOrder;
  ProjectOwner: GQLResolversParentTypes['Organization'] | GQLResolversParentTypes['Repository'] | GQLResolversParentTypes['User'];
  PublicKey: GQLPublicKey;
  PublicKeyConnection: GQLPublicKeyConnection;
  PublicKeyEdge: GQLPublicKeyEdge;
  PullRequest: GQLPullRequest;
  PullRequestChangedFile: GQLPullRequestChangedFile;
  PullRequestChangedFileConnection: GQLPullRequestChangedFileConnection;
  PullRequestChangedFileEdge: GQLPullRequestChangedFileEdge;
  PullRequestCommit: GQLPullRequestCommit;
  PullRequestCommitCommentThread: GQLPullRequestCommitCommentThread;
  PullRequestCommitConnection: GQLPullRequestCommitConnection;
  PullRequestCommitEdge: GQLPullRequestCommitEdge;
  PullRequestConnection: GQLPullRequestConnection;
  PullRequestContributionsByRepository: GQLPullRequestContributionsByRepository;
  PullRequestEdge: GQLPullRequestEdge;
  PullRequestOrder: GQLPullRequestOrder;
  PullRequestReview: GQLPullRequestReview;
  PullRequestReviewComment: GQLPullRequestReviewComment;
  PullRequestReviewCommentConnection: GQLPullRequestReviewCommentConnection;
  PullRequestReviewCommentEdge: GQLPullRequestReviewCommentEdge;
  PullRequestReviewConnection: GQLPullRequestReviewConnection;
  PullRequestReviewContributionsByRepository: GQLPullRequestReviewContributionsByRepository;
  PullRequestReviewEdge: GQLPullRequestReviewEdge;
  PullRequestReviewThread: GQLPullRequestReviewThread;
  PullRequestReviewThreadConnection: GQLPullRequestReviewThreadConnection;
  PullRequestReviewThreadEdge: GQLPullRequestReviewThreadEdge;
  PullRequestRevisionMarker: GQLPullRequestRevisionMarker;
  PullRequestTimelineConnection: Omit<GQLPullRequestTimelineConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<GQLResolversParentTypes['PullRequestTimelineItem']>>> };
  PullRequestTimelineItem: GQLResolversParentTypes['AssignedEvent'] | GQLResolversParentTypes['BaseRefForcePushedEvent'] | GQLResolversParentTypes['ClosedEvent'] | GQLResolversParentTypes['Commit'] | GQLResolversParentTypes['CommitCommentThread'] | GQLResolversParentTypes['CrossReferencedEvent'] | GQLResolversParentTypes['DemilestonedEvent'] | GQLResolversParentTypes['DeployedEvent'] | GQLResolversParentTypes['DeploymentEnvironmentChangedEvent'] | GQLResolversParentTypes['HeadRefDeletedEvent'] | GQLResolversParentTypes['HeadRefForcePushedEvent'] | GQLResolversParentTypes['HeadRefRestoredEvent'] | GQLResolversParentTypes['IssueComment'] | GQLResolversParentTypes['LabeledEvent'] | GQLResolversParentTypes['LockedEvent'] | GQLResolversParentTypes['MergedEvent'] | GQLResolversParentTypes['MilestonedEvent'] | GQLResolversParentTypes['PullRequestReview'] | GQLResolversParentTypes['PullRequestReviewComment'] | GQLResolversParentTypes['PullRequestReviewThread'] | GQLResolversParentTypes['ReferencedEvent'] | GQLResolversParentTypes['RenamedTitleEvent'] | GQLResolversParentTypes['ReopenedEvent'] | GQLResolversParentTypes['ReviewDismissedEvent'] | GQLResolversParentTypes['ReviewRequestRemovedEvent'] | GQLResolversParentTypes['ReviewRequestedEvent'] | GQLResolversParentTypes['SubscribedEvent'] | GQLResolversParentTypes['UnassignedEvent'] | GQLResolversParentTypes['UnlabeledEvent'] | GQLResolversParentTypes['UnlockedEvent'] | GQLResolversParentTypes['UnsubscribedEvent'] | GQLResolversParentTypes['UserBlockedEvent'];
  PullRequestTimelineItemEdge: Omit<GQLPullRequestTimelineItemEdge, 'node'> & { node?: Maybe<GQLResolversParentTypes['PullRequestTimelineItem']> };
  PullRequestTimelineItems: GQLResolversParentTypes['AddedToProjectEvent'] | GQLResolversParentTypes['AssignedEvent'] | GQLResolversParentTypes['AutomaticBaseChangeFailedEvent'] | GQLResolversParentTypes['AutomaticBaseChangeSucceededEvent'] | GQLResolversParentTypes['BaseRefChangedEvent'] | GQLResolversParentTypes['BaseRefForcePushedEvent'] | GQLResolversParentTypes['ClosedEvent'] | GQLResolversParentTypes['CommentDeletedEvent'] | GQLResolversParentTypes['ConnectedEvent'] | GQLResolversParentTypes['ConvertToDraftEvent'] | GQLResolversParentTypes['ConvertedNoteToIssueEvent'] | GQLResolversParentTypes['CrossReferencedEvent'] | GQLResolversParentTypes['DemilestonedEvent'] | GQLResolversParentTypes['DeployedEvent'] | GQLResolversParentTypes['DeploymentEnvironmentChangedEvent'] | GQLResolversParentTypes['DisconnectedEvent'] | GQLResolversParentTypes['HeadRefDeletedEvent'] | GQLResolversParentTypes['HeadRefForcePushedEvent'] | GQLResolversParentTypes['HeadRefRestoredEvent'] | GQLResolversParentTypes['IssueComment'] | GQLResolversParentTypes['LabeledEvent'] | GQLResolversParentTypes['LockedEvent'] | GQLResolversParentTypes['MarkedAsDuplicateEvent'] | GQLResolversParentTypes['MentionedEvent'] | GQLResolversParentTypes['MergedEvent'] | GQLResolversParentTypes['MilestonedEvent'] | GQLResolversParentTypes['MovedColumnsInProjectEvent'] | GQLResolversParentTypes['PinnedEvent'] | GQLResolversParentTypes['PullRequestCommit'] | GQLResolversParentTypes['PullRequestCommitCommentThread'] | GQLResolversParentTypes['PullRequestReview'] | GQLResolversParentTypes['PullRequestReviewThread'] | GQLResolversParentTypes['PullRequestRevisionMarker'] | GQLResolversParentTypes['ReadyForReviewEvent'] | GQLResolversParentTypes['ReferencedEvent'] | GQLResolversParentTypes['RemovedFromProjectEvent'] | GQLResolversParentTypes['RenamedTitleEvent'] | GQLResolversParentTypes['ReopenedEvent'] | GQLResolversParentTypes['ReviewDismissedEvent'] | GQLResolversParentTypes['ReviewRequestRemovedEvent'] | GQLResolversParentTypes['ReviewRequestedEvent'] | GQLResolversParentTypes['SubscribedEvent'] | GQLResolversParentTypes['TransferredEvent'] | GQLResolversParentTypes['UnassignedEvent'] | GQLResolversParentTypes['UnlabeledEvent'] | GQLResolversParentTypes['UnlockedEvent'] | GQLResolversParentTypes['UnmarkedAsDuplicateEvent'] | GQLResolversParentTypes['UnpinnedEvent'] | GQLResolversParentTypes['UnsubscribedEvent'] | GQLResolversParentTypes['UserBlockedEvent'];
  PullRequestTimelineItemsConnection: Omit<GQLPullRequestTimelineItemsConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<GQLResolversParentTypes['PullRequestTimelineItems']>>> };
  PullRequestTimelineItemsEdge: Omit<GQLPullRequestTimelineItemsEdge, 'node'> & { node?: Maybe<GQLResolversParentTypes['PullRequestTimelineItems']> };
  Push: GQLPush;
  PushAllowance: Omit<GQLPushAllowance, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['PushAllowanceActor']> };
  PushAllowanceActor: GQLResolversParentTypes['App'] | GQLResolversParentTypes['Team'] | GQLResolversParentTypes['User'];
  PushAllowanceConnection: GQLPushAllowanceConnection;
  PushAllowanceEdge: GQLPushAllowanceEdge;
  Query: {};
  RateLimit: GQLRateLimit;
  Reactable: GQLResolversParentTypes['CommitComment'] | GQLResolversParentTypes['Issue'] | GQLResolversParentTypes['IssueComment'] | GQLResolversParentTypes['PullRequest'] | GQLResolversParentTypes['PullRequestReview'] | GQLResolversParentTypes['PullRequestReviewComment'] | GQLResolversParentTypes['TeamDiscussion'] | GQLResolversParentTypes['TeamDiscussionComment'];
  ReactingUserConnection: GQLReactingUserConnection;
  ReactingUserEdge: GQLReactingUserEdge;
  Reaction: GQLReaction;
  ReactionConnection: GQLReactionConnection;
  ReactionEdge: GQLReactionEdge;
  ReactionGroup: GQLReactionGroup;
  ReactionOrder: GQLReactionOrder;
  ReadyForReviewEvent: GQLReadyForReviewEvent;
  Ref: GQLRef;
  RefConnection: GQLRefConnection;
  RefEdge: GQLRefEdge;
  RefOrder: GQLRefOrder;
  RefUpdate: GQLRefUpdate;
  ReferencedEvent: Omit<GQLReferencedEvent, 'subject'> & { subject: GQLResolversParentTypes['ReferencedSubject'] };
  ReferencedSubject: GQLResolversParentTypes['Issue'] | GQLResolversParentTypes['PullRequest'];
  RegenerateEnterpriseIdentityProviderRecoveryCodesInput: GQLRegenerateEnterpriseIdentityProviderRecoveryCodesInput;
  RegenerateEnterpriseIdentityProviderRecoveryCodesPayload: GQLRegenerateEnterpriseIdentityProviderRecoveryCodesPayload;
  RegistryPackage: GQLRegistryPackage;
  RegistryPackageConnection: GQLRegistryPackageConnection;
  RegistryPackageDependency: GQLRegistryPackageDependency;
  RegistryPackageDependencyConnection: GQLRegistryPackageDependencyConnection;
  RegistryPackageDependencyEdge: GQLRegistryPackageDependencyEdge;
  RegistryPackageEdge: GQLRegistryPackageEdge;
  RegistryPackageFile: GQLRegistryPackageFile;
  RegistryPackageFileConnection: GQLRegistryPackageFileConnection;
  RegistryPackageFileEdge: GQLRegistryPackageFileEdge;
  RegistryPackageMetadatum: GQLRegistryPackageMetadatum;
  RegistryPackageOwner: GQLResolversParentTypes['Organization'] | GQLResolversParentTypes['Repository'] | GQLResolversParentTypes['User'];
  RegistryPackageSearch: GQLResolversParentTypes['Organization'] | GQLResolversParentTypes['Repository'] | GQLResolversParentTypes['User'];
  RegistryPackageStatistics: GQLRegistryPackageStatistics;
  RegistryPackageTag: GQLRegistryPackageTag;
  RegistryPackageTagConnection: GQLRegistryPackageTagConnection;
  RegistryPackageTagEdge: GQLRegistryPackageTagEdge;
  RegistryPackageVersion: GQLRegistryPackageVersion;
  RegistryPackageVersionConnection: GQLRegistryPackageVersionConnection;
  RegistryPackageVersionEdge: GQLRegistryPackageVersionEdge;
  RegistryPackageVersionStatistics: GQLRegistryPackageVersionStatistics;
  Release: GQLRelease;
  ReleaseAsset: GQLReleaseAsset;
  ReleaseAssetConnection: GQLReleaseAssetConnection;
  ReleaseAssetEdge: GQLReleaseAssetEdge;
  ReleaseConnection: GQLReleaseConnection;
  ReleaseEdge: GQLReleaseEdge;
  ReleaseOrder: GQLReleaseOrder;
  RemoveAssigneesFromAssignableInput: GQLRemoveAssigneesFromAssignableInput;
  RemoveAssigneesFromAssignablePayload: GQLRemoveAssigneesFromAssignablePayload;
  RemoveEnterpriseAdminInput: GQLRemoveEnterpriseAdminInput;
  RemoveEnterpriseAdminPayload: GQLRemoveEnterpriseAdminPayload;
  RemoveEnterpriseIdentityProviderInput: GQLRemoveEnterpriseIdentityProviderInput;
  RemoveEnterpriseIdentityProviderPayload: GQLRemoveEnterpriseIdentityProviderPayload;
  RemoveEnterpriseOrganizationInput: GQLRemoveEnterpriseOrganizationInput;
  RemoveEnterpriseOrganizationPayload: GQLRemoveEnterpriseOrganizationPayload;
  RemoveLabelsFromLabelableInput: GQLRemoveLabelsFromLabelableInput;
  RemoveLabelsFromLabelablePayload: GQLRemoveLabelsFromLabelablePayload;
  RemoveOutsideCollaboratorInput: GQLRemoveOutsideCollaboratorInput;
  RemoveOutsideCollaboratorPayload: GQLRemoveOutsideCollaboratorPayload;
  RemoveReactionInput: GQLRemoveReactionInput;
  RemoveReactionPayload: GQLRemoveReactionPayload;
  RemoveStarInput: GQLRemoveStarInput;
  RemoveStarPayload: GQLRemoveStarPayload;
  RemovedFromProjectEvent: GQLRemovedFromProjectEvent;
  RenamedTitleEvent: Omit<GQLRenamedTitleEvent, 'subject'> & { subject: GQLResolversParentTypes['RenamedTitleSubject'] };
  RenamedTitleSubject: GQLResolversParentTypes['Issue'] | GQLResolversParentTypes['PullRequest'];
  ReopenIssueInput: GQLReopenIssueInput;
  ReopenIssuePayload: GQLReopenIssuePayload;
  ReopenPullRequestInput: GQLReopenPullRequestInput;
  ReopenPullRequestPayload: GQLReopenPullRequestPayload;
  ReopenedEvent: GQLReopenedEvent;
  RepoAccessAuditEntry: Omit<GQLRepoAccessAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  RepoAddMemberAuditEntry: Omit<GQLRepoAddMemberAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  RepoAddTopicAuditEntry: Omit<GQLRepoAddTopicAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  RepoArchivedAuditEntry: Omit<GQLRepoArchivedAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  RepoChangeMergeSettingAuditEntry: Omit<GQLRepoChangeMergeSettingAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  RepoConfigDisableAnonymousGitAccessAuditEntry: Omit<GQLRepoConfigDisableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  RepoConfigDisableCollaboratorsOnlyAuditEntry: Omit<GQLRepoConfigDisableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  RepoConfigDisableContributorsOnlyAuditEntry: Omit<GQLRepoConfigDisableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  RepoConfigDisableSockpuppetDisallowedAuditEntry: Omit<GQLRepoConfigDisableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  RepoConfigEnableAnonymousGitAccessAuditEntry: Omit<GQLRepoConfigEnableAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  RepoConfigEnableCollaboratorsOnlyAuditEntry: Omit<GQLRepoConfigEnableCollaboratorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  RepoConfigEnableContributorsOnlyAuditEntry: Omit<GQLRepoConfigEnableContributorsOnlyAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  RepoConfigEnableSockpuppetDisallowedAuditEntry: Omit<GQLRepoConfigEnableSockpuppetDisallowedAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  RepoConfigLockAnonymousGitAccessAuditEntry: Omit<GQLRepoConfigLockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  RepoConfigUnlockAnonymousGitAccessAuditEntry: Omit<GQLRepoConfigUnlockAnonymousGitAccessAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  RepoCreateAuditEntry: Omit<GQLRepoCreateAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  RepoDestroyAuditEntry: Omit<GQLRepoDestroyAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  RepoRemoveMemberAuditEntry: Omit<GQLRepoRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  RepoRemoveTopicAuditEntry: Omit<GQLRepoRemoveTopicAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  Repository: Omit<GQLRepository, 'issueOrPullRequest'> & { issueOrPullRequest?: Maybe<GQLResolversParentTypes['IssueOrPullRequest']> };
  RepositoryAuditEntryData: GQLResolversParentTypes['OrgRestoreMemberMembershipRepositoryAuditEntryData'] | GQLResolversParentTypes['PrivateRepositoryForkingDisableAuditEntry'] | GQLResolversParentTypes['PrivateRepositoryForkingEnableAuditEntry'] | GQLResolversParentTypes['RepoAccessAuditEntry'] | GQLResolversParentTypes['RepoAddMemberAuditEntry'] | GQLResolversParentTypes['RepoAddTopicAuditEntry'] | GQLResolversParentTypes['RepoArchivedAuditEntry'] | GQLResolversParentTypes['RepoChangeMergeSettingAuditEntry'] | GQLResolversParentTypes['RepoConfigDisableAnonymousGitAccessAuditEntry'] | GQLResolversParentTypes['RepoConfigDisableCollaboratorsOnlyAuditEntry'] | GQLResolversParentTypes['RepoConfigDisableContributorsOnlyAuditEntry'] | GQLResolversParentTypes['RepoConfigDisableSockpuppetDisallowedAuditEntry'] | GQLResolversParentTypes['RepoConfigEnableAnonymousGitAccessAuditEntry'] | GQLResolversParentTypes['RepoConfigEnableCollaboratorsOnlyAuditEntry'] | GQLResolversParentTypes['RepoConfigEnableContributorsOnlyAuditEntry'] | GQLResolversParentTypes['RepoConfigEnableSockpuppetDisallowedAuditEntry'] | GQLResolversParentTypes['RepoConfigLockAnonymousGitAccessAuditEntry'] | GQLResolversParentTypes['RepoConfigUnlockAnonymousGitAccessAuditEntry'] | GQLResolversParentTypes['RepoCreateAuditEntry'] | GQLResolversParentTypes['RepoDestroyAuditEntry'] | GQLResolversParentTypes['RepoRemoveMemberAuditEntry'] | GQLResolversParentTypes['RepoRemoveTopicAuditEntry'] | GQLResolversParentTypes['TeamAddRepositoryAuditEntry'] | GQLResolversParentTypes['TeamRemoveRepositoryAuditEntry'];
  RepositoryCollaboratorConnection: GQLRepositoryCollaboratorConnection;
  RepositoryCollaboratorEdge: GQLRepositoryCollaboratorEdge;
  RepositoryConnection: GQLRepositoryConnection;
  RepositoryEdge: GQLRepositoryEdge;
  RepositoryInfo: GQLResolversParentTypes['Repository'];
  RepositoryInvitation: GQLRepositoryInvitation;
  RepositoryInvitationConnection: GQLRepositoryInvitationConnection;
  RepositoryInvitationEdge: GQLRepositoryInvitationEdge;
  RepositoryInvitationOrder: GQLRepositoryInvitationOrder;
  RepositoryNode: GQLResolversParentTypes['CommitComment'] | GQLResolversParentTypes['CommitCommentThread'] | GQLResolversParentTypes['Issue'] | GQLResolversParentTypes['IssueComment'] | GQLResolversParentTypes['PullRequest'] | GQLResolversParentTypes['PullRequestCommitCommentThread'] | GQLResolversParentTypes['PullRequestReview'] | GQLResolversParentTypes['PullRequestReviewComment'] | GQLResolversParentTypes['RepositoryVulnerabilityAlert'];
  RepositoryOrder: GQLRepositoryOrder;
  RepositoryOwner: GQLResolversParentTypes['Organization'] | GQLResolversParentTypes['User'];
  RepositoryTopic: GQLRepositoryTopic;
  RepositoryTopicConnection: GQLRepositoryTopicConnection;
  RepositoryTopicEdge: GQLRepositoryTopicEdge;
  RepositoryVisibilityChangeDisableAuditEntry: Omit<GQLRepositoryVisibilityChangeDisableAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  RepositoryVisibilityChangeEnableAuditEntry: Omit<GQLRepositoryVisibilityChangeEnableAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  RepositoryVulnerabilityAlert: GQLRepositoryVulnerabilityAlert;
  RepositoryVulnerabilityAlertConnection: GQLRepositoryVulnerabilityAlertConnection;
  RepositoryVulnerabilityAlertEdge: GQLRepositoryVulnerabilityAlertEdge;
  RequestReviewsInput: GQLRequestReviewsInput;
  RequestReviewsPayload: GQLRequestReviewsPayload;
  RequestedReviewer: GQLResolversParentTypes['Mannequin'] | GQLResolversParentTypes['Team'] | GQLResolversParentTypes['User'];
  RerequestCheckSuiteInput: GQLRerequestCheckSuiteInput;
  RerequestCheckSuitePayload: GQLRerequestCheckSuitePayload;
  ResolveReviewThreadInput: GQLResolveReviewThreadInput;
  ResolveReviewThreadPayload: GQLResolveReviewThreadPayload;
  RestrictedContribution: GQLRestrictedContribution;
  ReviewDismissalAllowance: Omit<GQLReviewDismissalAllowance, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['ReviewDismissalAllowanceActor']> };
  ReviewDismissalAllowanceActor: GQLResolversParentTypes['Team'] | GQLResolversParentTypes['User'];
  ReviewDismissalAllowanceConnection: GQLReviewDismissalAllowanceConnection;
  ReviewDismissalAllowanceEdge: GQLReviewDismissalAllowanceEdge;
  ReviewDismissedEvent: GQLReviewDismissedEvent;
  ReviewRequest: Omit<GQLReviewRequest, 'requestedReviewer'> & { requestedReviewer?: Maybe<GQLResolversParentTypes['RequestedReviewer']> };
  ReviewRequestConnection: GQLReviewRequestConnection;
  ReviewRequestEdge: GQLReviewRequestEdge;
  ReviewRequestRemovedEvent: Omit<GQLReviewRequestRemovedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<GQLResolversParentTypes['RequestedReviewer']> };
  ReviewRequestedEvent: Omit<GQLReviewRequestedEvent, 'requestedReviewer'> & { requestedReviewer?: Maybe<GQLResolversParentTypes['RequestedReviewer']> };
  ReviewStatusHovercardContext: GQLReviewStatusHovercardContext;
  SavedReply: GQLSavedReply;
  SavedReplyConnection: GQLSavedReplyConnection;
  SavedReplyEdge: GQLSavedReplyEdge;
  SavedReplyOrder: GQLSavedReplyOrder;
  SearchResultItem: GQLResolversParentTypes['App'] | GQLResolversParentTypes['Issue'] | GQLResolversParentTypes['MarketplaceListing'] | GQLResolversParentTypes['Organization'] | GQLResolversParentTypes['PullRequest'] | GQLResolversParentTypes['Repository'] | GQLResolversParentTypes['User'];
  SearchResultItemConnection: Omit<GQLSearchResultItemConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<GQLResolversParentTypes['SearchResultItem']>>> };
  SearchResultItemEdge: Omit<GQLSearchResultItemEdge, 'node'> & { node?: Maybe<GQLResolversParentTypes['SearchResultItem']> };
  SecurityAdvisory: GQLSecurityAdvisory;
  SecurityAdvisoryConnection: GQLSecurityAdvisoryConnection;
  SecurityAdvisoryEdge: GQLSecurityAdvisoryEdge;
  SecurityAdvisoryIdentifier: GQLSecurityAdvisoryIdentifier;
  SecurityAdvisoryIdentifierFilter: GQLSecurityAdvisoryIdentifierFilter;
  SecurityAdvisoryOrder: GQLSecurityAdvisoryOrder;
  SecurityAdvisoryPackage: GQLSecurityAdvisoryPackage;
  SecurityAdvisoryPackageVersion: GQLSecurityAdvisoryPackageVersion;
  SecurityAdvisoryReference: GQLSecurityAdvisoryReference;
  SecurityVulnerability: GQLSecurityVulnerability;
  SecurityVulnerabilityConnection: GQLSecurityVulnerabilityConnection;
  SecurityVulnerabilityEdge: GQLSecurityVulnerabilityEdge;
  SecurityVulnerabilityOrder: GQLSecurityVulnerabilityOrder;
  SetEnterpriseIdentityProviderInput: GQLSetEnterpriseIdentityProviderInput;
  SetEnterpriseIdentityProviderPayload: GQLSetEnterpriseIdentityProviderPayload;
  SmimeSignature: GQLSmimeSignature;
  Sponsor: GQLResolversParentTypes['Organization'] | GQLResolversParentTypes['User'];
  Sponsorable: GQLResolversParentTypes['Organization'] | GQLResolversParentTypes['User'];
  SponsorsListing: GQLSponsorsListing;
  SponsorsTier: GQLSponsorsTier;
  SponsorsTierAdminInfo: GQLSponsorsTierAdminInfo;
  SponsorsTierConnection: GQLSponsorsTierConnection;
  SponsorsTierEdge: GQLSponsorsTierEdge;
  SponsorsTierOrder: GQLSponsorsTierOrder;
  Sponsorship: Omit<GQLSponsorship, 'sponsorEntity'> & { sponsorEntity?: Maybe<GQLResolversParentTypes['Sponsor']> };
  SponsorshipConnection: GQLSponsorshipConnection;
  SponsorshipEdge: GQLSponsorshipEdge;
  SponsorshipOrder: GQLSponsorshipOrder;
  StarOrder: GQLStarOrder;
  StargazerConnection: GQLStargazerConnection;
  StargazerEdge: GQLStargazerEdge;
  Starrable: GQLResolversParentTypes['Gist'] | GQLResolversParentTypes['Repository'] | GQLResolversParentTypes['Topic'];
  StarredRepositoryConnection: GQLStarredRepositoryConnection;
  StarredRepositoryEdge: GQLStarredRepositoryEdge;
  Status: GQLStatus;
  StatusCheckRollup: GQLStatusCheckRollup;
  StatusCheckRollupContext: GQLResolversParentTypes['CheckRun'] | GQLResolversParentTypes['StatusContext'];
  StatusCheckRollupContextConnection: Omit<GQLStatusCheckRollupContextConnection, 'nodes'> & { nodes?: Maybe<Array<Maybe<GQLResolversParentTypes['StatusCheckRollupContext']>>> };
  StatusCheckRollupContextEdge: Omit<GQLStatusCheckRollupContextEdge, 'node'> & { node?: Maybe<GQLResolversParentTypes['StatusCheckRollupContext']> };
  StatusContext: GQLStatusContext;
  SubmitPullRequestReviewInput: GQLSubmitPullRequestReviewInput;
  SubmitPullRequestReviewPayload: GQLSubmitPullRequestReviewPayload;
  Submodule: GQLSubmodule;
  SubmoduleConnection: GQLSubmoduleConnection;
  SubmoduleEdge: GQLSubmoduleEdge;
  Subscribable: GQLResolversParentTypes['Commit'] | GQLResolversParentTypes['Issue'] | GQLResolversParentTypes['PullRequest'] | GQLResolversParentTypes['Repository'] | GQLResolversParentTypes['Team'] | GQLResolversParentTypes['TeamDiscussion'];
  SubscribedEvent: GQLSubscribedEvent;
  SuggestedReviewer: GQLSuggestedReviewer;
  Tag: GQLTag;
  Team: GQLTeam;
  TeamAddMemberAuditEntry: Omit<GQLTeamAddMemberAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  TeamAddRepositoryAuditEntry: Omit<GQLTeamAddRepositoryAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  TeamAuditEntryData: GQLResolversParentTypes['OrgRestoreMemberMembershipTeamAuditEntryData'] | GQLResolversParentTypes['TeamAddMemberAuditEntry'] | GQLResolversParentTypes['TeamAddRepositoryAuditEntry'] | GQLResolversParentTypes['TeamChangeParentTeamAuditEntry'] | GQLResolversParentTypes['TeamRemoveMemberAuditEntry'] | GQLResolversParentTypes['TeamRemoveRepositoryAuditEntry'];
  TeamChangeParentTeamAuditEntry: Omit<GQLTeamChangeParentTeamAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  TeamConnection: GQLTeamConnection;
  TeamDiscussion: GQLTeamDiscussion;
  TeamDiscussionComment: GQLTeamDiscussionComment;
  TeamDiscussionCommentConnection: GQLTeamDiscussionCommentConnection;
  TeamDiscussionCommentEdge: GQLTeamDiscussionCommentEdge;
  TeamDiscussionCommentOrder: GQLTeamDiscussionCommentOrder;
  TeamDiscussionConnection: GQLTeamDiscussionConnection;
  TeamDiscussionEdge: GQLTeamDiscussionEdge;
  TeamDiscussionOrder: GQLTeamDiscussionOrder;
  TeamEdge: GQLTeamEdge;
  TeamMemberConnection: GQLTeamMemberConnection;
  TeamMemberEdge: GQLTeamMemberEdge;
  TeamMemberOrder: GQLTeamMemberOrder;
  TeamOrder: GQLTeamOrder;
  TeamRemoveMemberAuditEntry: Omit<GQLTeamRemoveMemberAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  TeamRemoveRepositoryAuditEntry: Omit<GQLTeamRemoveRepositoryAuditEntry, 'actor'> & { actor?: Maybe<GQLResolversParentTypes['AuditEntryActor']> };
  TeamRepositoryConnection: GQLTeamRepositoryConnection;
  TeamRepositoryEdge: GQLTeamRepositoryEdge;
  TeamRepositoryOrder: GQLTeamRepositoryOrder;
  TextMatch: GQLTextMatch;
  TextMatchHighlight: GQLTextMatchHighlight;
  Topic: GQLTopic;
  TopicAuditEntryData: GQLResolversParentTypes['RepoAddTopicAuditEntry'] | GQLResolversParentTypes['RepoRemoveTopicAuditEntry'];
  TopicConnection: GQLTopicConnection;
  TopicEdge: GQLTopicEdge;
  TransferIssueInput: GQLTransferIssueInput;
  TransferIssuePayload: GQLTransferIssuePayload;
  TransferredEvent: GQLTransferredEvent;
  Tree: GQLTree;
  TreeEntry: GQLTreeEntry;
  URI: Scalars['URI'];
  UnarchiveRepositoryInput: GQLUnarchiveRepositoryInput;
  UnarchiveRepositoryPayload: GQLUnarchiveRepositoryPayload;
  UnassignedEvent: Omit<GQLUnassignedEvent, 'assignee'> & { assignee?: Maybe<GQLResolversParentTypes['Assignee']> };
  UnfollowUserInput: GQLUnfollowUserInput;
  UnfollowUserPayload: GQLUnfollowUserPayload;
  UniformResourceLocatable: GQLResolversParentTypes['Bot'] | GQLResolversParentTypes['CheckRun'] | GQLResolversParentTypes['ClosedEvent'] | GQLResolversParentTypes['Commit'] | GQLResolversParentTypes['ConvertToDraftEvent'] | GQLResolversParentTypes['CrossReferencedEvent'] | GQLResolversParentTypes['Gist'] | GQLResolversParentTypes['Issue'] | GQLResolversParentTypes['Mannequin'] | GQLResolversParentTypes['MergedEvent'] | GQLResolversParentTypes['Milestone'] | GQLResolversParentTypes['Organization'] | GQLResolversParentTypes['PullRequest'] | GQLResolversParentTypes['PullRequestCommit'] | GQLResolversParentTypes['ReadyForReviewEvent'] | GQLResolversParentTypes['Release'] | GQLResolversParentTypes['Repository'] | GQLResolversParentTypes['RepositoryTopic'] | GQLResolversParentTypes['ReviewDismissedEvent'] | GQLResolversParentTypes['TeamDiscussion'] | GQLResolversParentTypes['TeamDiscussionComment'] | GQLResolversParentTypes['User'];
  UnknownSignature: GQLUnknownSignature;
  UnlabeledEvent: GQLUnlabeledEvent;
  UnlinkRepositoryFromProjectInput: GQLUnlinkRepositoryFromProjectInput;
  UnlinkRepositoryFromProjectPayload: GQLUnlinkRepositoryFromProjectPayload;
  UnlockLockableInput: GQLUnlockLockableInput;
  UnlockLockablePayload: GQLUnlockLockablePayload;
  UnlockedEvent: GQLUnlockedEvent;
  UnmarkIssueAsDuplicateInput: GQLUnmarkIssueAsDuplicateInput;
  UnmarkIssueAsDuplicatePayload: Omit<GQLUnmarkIssueAsDuplicatePayload, 'duplicate'> & { duplicate?: Maybe<GQLResolversParentTypes['IssueOrPullRequest']> };
  UnmarkedAsDuplicateEvent: GQLUnmarkedAsDuplicateEvent;
  UnminimizeCommentInput: GQLUnminimizeCommentInput;
  UnminimizeCommentPayload: GQLUnminimizeCommentPayload;
  UnpinIssueInput: GQLUnpinIssueInput;
  UnpinIssuePayload: GQLUnpinIssuePayload;
  UnpinnedEvent: GQLUnpinnedEvent;
  UnresolveReviewThreadInput: GQLUnresolveReviewThreadInput;
  UnresolveReviewThreadPayload: GQLUnresolveReviewThreadPayload;
  UnsubscribedEvent: GQLUnsubscribedEvent;
  Updatable: GQLResolversParentTypes['CommitComment'] | GQLResolversParentTypes['GistComment'] | GQLResolversParentTypes['Issue'] | GQLResolversParentTypes['IssueComment'] | GQLResolversParentTypes['Project'] | GQLResolversParentTypes['PullRequest'] | GQLResolversParentTypes['PullRequestReview'] | GQLResolversParentTypes['PullRequestReviewComment'] | GQLResolversParentTypes['TeamDiscussion'] | GQLResolversParentTypes['TeamDiscussionComment'];
  UpdatableComment: GQLResolversParentTypes['CommitComment'] | GQLResolversParentTypes['GistComment'] | GQLResolversParentTypes['Issue'] | GQLResolversParentTypes['IssueComment'] | GQLResolversParentTypes['PullRequest'] | GQLResolversParentTypes['PullRequestReview'] | GQLResolversParentTypes['PullRequestReviewComment'] | GQLResolversParentTypes['TeamDiscussion'] | GQLResolversParentTypes['TeamDiscussionComment'];
  UpdateBranchProtectionRuleInput: GQLUpdateBranchProtectionRuleInput;
  UpdateBranchProtectionRulePayload: GQLUpdateBranchProtectionRulePayload;
  UpdateCheckRunInput: GQLUpdateCheckRunInput;
  UpdateCheckRunPayload: GQLUpdateCheckRunPayload;
  UpdateCheckSuitePreferencesInput: GQLUpdateCheckSuitePreferencesInput;
  UpdateCheckSuitePreferencesPayload: GQLUpdateCheckSuitePreferencesPayload;
  UpdateEnterpriseActionExecutionCapabilitySettingInput: GQLUpdateEnterpriseActionExecutionCapabilitySettingInput;
  UpdateEnterpriseActionExecutionCapabilitySettingPayload: GQLUpdateEnterpriseActionExecutionCapabilitySettingPayload;
  UpdateEnterpriseAdministratorRoleInput: GQLUpdateEnterpriseAdministratorRoleInput;
  UpdateEnterpriseAdministratorRolePayload: GQLUpdateEnterpriseAdministratorRolePayload;
  UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput: GQLUpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;
  UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload: GQLUpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload;
  UpdateEnterpriseDefaultRepositoryPermissionSettingInput: GQLUpdateEnterpriseDefaultRepositoryPermissionSettingInput;
  UpdateEnterpriseDefaultRepositoryPermissionSettingPayload: GQLUpdateEnterpriseDefaultRepositoryPermissionSettingPayload;
  UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput: GQLUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;
  UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload: GQLUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload;
  UpdateEnterpriseMembersCanCreateRepositoriesSettingInput: GQLUpdateEnterpriseMembersCanCreateRepositoriesSettingInput;
  UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload: GQLUpdateEnterpriseMembersCanCreateRepositoriesSettingPayload;
  UpdateEnterpriseMembersCanDeleteIssuesSettingInput: GQLUpdateEnterpriseMembersCanDeleteIssuesSettingInput;
  UpdateEnterpriseMembersCanDeleteIssuesSettingPayload: GQLUpdateEnterpriseMembersCanDeleteIssuesSettingPayload;
  UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput: GQLUpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;
  UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload: GQLUpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload;
  UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput: GQLUpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;
  UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload: GQLUpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload;
  UpdateEnterpriseMembersCanMakePurchasesSettingInput: GQLUpdateEnterpriseMembersCanMakePurchasesSettingInput;
  UpdateEnterpriseMembersCanMakePurchasesSettingPayload: GQLUpdateEnterpriseMembersCanMakePurchasesSettingPayload;
  UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput: GQLUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;
  UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload: GQLUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload;
  UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput: GQLUpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;
  UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload: GQLUpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload;
  UpdateEnterpriseOrganizationProjectsSettingInput: GQLUpdateEnterpriseOrganizationProjectsSettingInput;
  UpdateEnterpriseOrganizationProjectsSettingPayload: GQLUpdateEnterpriseOrganizationProjectsSettingPayload;
  UpdateEnterpriseProfileInput: GQLUpdateEnterpriseProfileInput;
  UpdateEnterpriseProfilePayload: GQLUpdateEnterpriseProfilePayload;
  UpdateEnterpriseRepositoryProjectsSettingInput: GQLUpdateEnterpriseRepositoryProjectsSettingInput;
  UpdateEnterpriseRepositoryProjectsSettingPayload: GQLUpdateEnterpriseRepositoryProjectsSettingPayload;
  UpdateEnterpriseTeamDiscussionsSettingInput: GQLUpdateEnterpriseTeamDiscussionsSettingInput;
  UpdateEnterpriseTeamDiscussionsSettingPayload: GQLUpdateEnterpriseTeamDiscussionsSettingPayload;
  UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput: GQLUpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;
  UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload: GQLUpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload;
  UpdateIpAllowListEnabledSettingInput: GQLUpdateIpAllowListEnabledSettingInput;
  UpdateIpAllowListEnabledSettingPayload: Omit<GQLUpdateIpAllowListEnabledSettingPayload, 'owner'> & { owner?: Maybe<GQLResolversParentTypes['IpAllowListOwner']> };
  UpdateIpAllowListEntryInput: GQLUpdateIpAllowListEntryInput;
  UpdateIpAllowListEntryPayload: GQLUpdateIpAllowListEntryPayload;
  UpdateIssueCommentInput: GQLUpdateIssueCommentInput;
  UpdateIssueCommentPayload: GQLUpdateIssueCommentPayload;
  UpdateIssueInput: GQLUpdateIssueInput;
  UpdateIssuePayload: GQLUpdateIssuePayload;
  UpdateLabelInput: GQLUpdateLabelInput;
  UpdateLabelPayload: GQLUpdateLabelPayload;
  UpdateProjectCardInput: GQLUpdateProjectCardInput;
  UpdateProjectCardPayload: GQLUpdateProjectCardPayload;
  UpdateProjectColumnInput: GQLUpdateProjectColumnInput;
  UpdateProjectColumnPayload: GQLUpdateProjectColumnPayload;
  UpdateProjectInput: GQLUpdateProjectInput;
  UpdateProjectPayload: GQLUpdateProjectPayload;
  UpdatePullRequestInput: GQLUpdatePullRequestInput;
  UpdatePullRequestPayload: GQLUpdatePullRequestPayload;
  UpdatePullRequestReviewCommentInput: GQLUpdatePullRequestReviewCommentInput;
  UpdatePullRequestReviewCommentPayload: GQLUpdatePullRequestReviewCommentPayload;
  UpdatePullRequestReviewInput: GQLUpdatePullRequestReviewInput;
  UpdatePullRequestReviewPayload: GQLUpdatePullRequestReviewPayload;
  UpdateRefInput: GQLUpdateRefInput;
  UpdateRefPayload: GQLUpdateRefPayload;
  UpdateRefsInput: GQLUpdateRefsInput;
  UpdateRefsPayload: GQLUpdateRefsPayload;
  UpdateRepositoryInput: GQLUpdateRepositoryInput;
  UpdateRepositoryPayload: GQLUpdateRepositoryPayload;
  UpdateSubscriptionInput: GQLUpdateSubscriptionInput;
  UpdateSubscriptionPayload: GQLUpdateSubscriptionPayload;
  UpdateTeamDiscussionCommentInput: GQLUpdateTeamDiscussionCommentInput;
  UpdateTeamDiscussionCommentPayload: GQLUpdateTeamDiscussionCommentPayload;
  UpdateTeamDiscussionInput: GQLUpdateTeamDiscussionInput;
  UpdateTeamDiscussionPayload: GQLUpdateTeamDiscussionPayload;
  UpdateTeamReviewAssignmentInput: GQLUpdateTeamReviewAssignmentInput;
  UpdateTeamReviewAssignmentPayload: GQLUpdateTeamReviewAssignmentPayload;
  UpdateTopicsInput: GQLUpdateTopicsInput;
  UpdateTopicsPayload: GQLUpdateTopicsPayload;
  User: GQLUser;
  UserBlockedEvent: GQLUserBlockedEvent;
  UserConnection: GQLUserConnection;
  UserContentEdit: GQLUserContentEdit;
  UserContentEditConnection: GQLUserContentEditConnection;
  UserContentEditEdge: GQLUserContentEditEdge;
  UserEdge: GQLUserEdge;
  UserStatus: GQLUserStatus;
  UserStatusConnection: GQLUserStatusConnection;
  UserStatusEdge: GQLUserStatusEdge;
  UserStatusOrder: GQLUserStatusOrder;
  ViewerHovercardContext: GQLViewerHovercardContext;
  X509Certificate: Scalars['X509Certificate'];
};

export type GQLPossibleTypesDirectiveArgs = {   abstractType?: Maybe<Scalars['String']>;
  concreteTypes: Array<Scalars['String']>; };

export type GQLPossibleTypesDirectiveResolver<Result, Parent, ContextType = any, Args = GQLPossibleTypesDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type GQLPreviewDirectiveArgs = {   toggledBy: Scalars['String']; };

export type GQLPreviewDirectiveResolver<Result, Parent, ContextType = any, Args = GQLPreviewDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type GQLAcceptEnterpriseAdministratorInvitationPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['AcceptEnterpriseAdministratorInvitationPayload'] = GQLResolversParentTypes['AcceptEnterpriseAdministratorInvitationPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  invitation?: Resolver<Maybe<GQLResolversTypes['EnterpriseAdministratorInvitation']>, ParentType, ContextType>;
  message?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLAcceptTopicSuggestionPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['AcceptTopicSuggestionPayload'] = GQLResolversParentTypes['AcceptTopicSuggestionPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  topic?: Resolver<Maybe<GQLResolversTypes['Topic']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLActorResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Actor'] = GQLResolversParentTypes['Actor']> = {
  __resolveType: TypeResolveFn<'Bot' | 'EnterpriseUserAccount' | 'Mannequin' | 'Organization' | 'User', ParentType, ContextType>;
  avatarUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType, RequireFields<GQLActorAvatarUrlArgs, never>>;
  login?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
};

export type GQLActorLocationResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ActorLocation'] = GQLResolversParentTypes['ActorLocation']> = {
  city?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  countryCode?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  region?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  regionCode?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLAddAssigneesToAssignablePayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['AddAssigneesToAssignablePayload'] = GQLResolversParentTypes['AddAssigneesToAssignablePayload']> = {
  assignable?: Resolver<Maybe<GQLResolversTypes['Assignable']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLAddCommentPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['AddCommentPayload'] = GQLResolversParentTypes['AddCommentPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  commentEdge?: Resolver<Maybe<GQLResolversTypes['IssueCommentEdge']>, ParentType, ContextType>;
  subject?: Resolver<Maybe<GQLResolversTypes['Node']>, ParentType, ContextType>;
  timelineEdge?: Resolver<Maybe<GQLResolversTypes['IssueTimelineItemEdge']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLAddLabelsToLabelablePayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['AddLabelsToLabelablePayload'] = GQLResolversParentTypes['AddLabelsToLabelablePayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  labelable?: Resolver<Maybe<GQLResolversTypes['Labelable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLAddProjectCardPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['AddProjectCardPayload'] = GQLResolversParentTypes['AddProjectCardPayload']> = {
  cardEdge?: Resolver<Maybe<GQLResolversTypes['ProjectCardEdge']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  projectColumn?: Resolver<Maybe<GQLResolversTypes['ProjectColumn']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLAddProjectColumnPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['AddProjectColumnPayload'] = GQLResolversParentTypes['AddProjectColumnPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  columnEdge?: Resolver<Maybe<GQLResolversTypes['ProjectColumnEdge']>, ParentType, ContextType>;
  project?: Resolver<Maybe<GQLResolversTypes['Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLAddPullRequestReviewCommentPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['AddPullRequestReviewCommentPayload'] = GQLResolversParentTypes['AddPullRequestReviewCommentPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<GQLResolversTypes['PullRequestReviewComment']>, ParentType, ContextType>;
  commentEdge?: Resolver<Maybe<GQLResolversTypes['PullRequestReviewCommentEdge']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLAddPullRequestReviewPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['AddPullRequestReviewPayload'] = GQLResolversParentTypes['AddPullRequestReviewPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<GQLResolversTypes['PullRequestReview']>, ParentType, ContextType>;
  reviewEdge?: Resolver<Maybe<GQLResolversTypes['PullRequestReviewEdge']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLAddPullRequestReviewThreadPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['AddPullRequestReviewThreadPayload'] = GQLResolversParentTypes['AddPullRequestReviewThreadPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  thread?: Resolver<Maybe<GQLResolversTypes['PullRequestReviewThread']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLAddReactionPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['AddReactionPayload'] = GQLResolversParentTypes['AddReactionPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  reaction?: Resolver<Maybe<GQLResolversTypes['Reaction']>, ParentType, ContextType>;
  subject?: Resolver<Maybe<GQLResolversTypes['Reactable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLAddStarPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['AddStarPayload'] = GQLResolversParentTypes['AddStarPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  starrable?: Resolver<Maybe<GQLResolversTypes['Starrable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLAddedToProjectEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['AddedToProjectEvent'] = GQLResolversParentTypes['AddedToProjectEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  project?: Resolver<Maybe<GQLResolversTypes['Project']>, ParentType, ContextType>;
  projectCard?: Resolver<Maybe<GQLResolversTypes['ProjectCard']>, ParentType, ContextType>;
  projectColumnName?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLAppResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['App'] = GQLResolversParentTypes['App']> = {
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  logoBackgroundColor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  logoUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType, RequireFields<GQLAppLogoUrlArgs, never>>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLArchiveRepositoryPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ArchiveRepositoryPayload'] = GQLResolversParentTypes['ArchiveRepositoryPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLAssignableResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Assignable'] = GQLResolversParentTypes['Assignable']> = {
  __resolveType: TypeResolveFn<'Issue' | 'PullRequest', ParentType, ContextType>;
  assignees?: Resolver<GQLResolversTypes['UserConnection'], ParentType, ContextType, RequireFields<GQLAssignableAssigneesArgs, never>>;
};

export type GQLAssignedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['AssignedEvent'] = GQLResolversParentTypes['AssignedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  assignable?: Resolver<GQLResolversTypes['Assignable'], ParentType, ContextType>;
  assignee?: Resolver<Maybe<GQLResolversTypes['Assignee']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLAssigneeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Assignee'] = GQLResolversParentTypes['Assignee']> = {
  __resolveType: TypeResolveFn<'Bot' | 'Mannequin' | 'Organization' | 'User', ParentType, ContextType>;
};

export type GQLAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['AuditEntry'] = GQLResolversParentTypes['AuditEntry']> = {
  __resolveType: TypeResolveFn<'MembersCanDeleteReposClearAuditEntry' | 'MembersCanDeleteReposDisableAuditEntry' | 'MembersCanDeleteReposEnableAuditEntry' | 'OauthApplicationCreateAuditEntry' | 'OrgAddBillingManagerAuditEntry' | 'OrgAddMemberAuditEntry' | 'OrgBlockUserAuditEntry' | 'OrgConfigDisableCollaboratorsOnlyAuditEntry' | 'OrgConfigEnableCollaboratorsOnlyAuditEntry' | 'OrgCreateAuditEntry' | 'OrgDisableOauthAppRestrictionsAuditEntry' | 'OrgDisableSamlAuditEntry' | 'OrgDisableTwoFactorRequirementAuditEntry' | 'OrgEnableOauthAppRestrictionsAuditEntry' | 'OrgEnableSamlAuditEntry' | 'OrgEnableTwoFactorRequirementAuditEntry' | 'OrgInviteMemberAuditEntry' | 'OrgInviteToBusinessAuditEntry' | 'OrgOauthAppAccessApprovedAuditEntry' | 'OrgOauthAppAccessDeniedAuditEntry' | 'OrgOauthAppAccessRequestedAuditEntry' | 'OrgRemoveBillingManagerAuditEntry' | 'OrgRemoveMemberAuditEntry' | 'OrgRemoveOutsideCollaboratorAuditEntry' | 'OrgRestoreMemberAuditEntry' | 'OrgUnblockUserAuditEntry' | 'OrgUpdateDefaultRepositoryPermissionAuditEntry' | 'OrgUpdateMemberAuditEntry' | 'OrgUpdateMemberRepositoryCreationPermissionAuditEntry' | 'OrgUpdateMemberRepositoryInvitationPermissionAuditEntry' | 'PrivateRepositoryForkingDisableAuditEntry' | 'PrivateRepositoryForkingEnableAuditEntry' | 'RepoAccessAuditEntry' | 'RepoAddMemberAuditEntry' | 'RepoAddTopicAuditEntry' | 'RepoArchivedAuditEntry' | 'RepoChangeMergeSettingAuditEntry' | 'RepoConfigDisableAnonymousGitAccessAuditEntry' | 'RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'RepoConfigDisableContributorsOnlyAuditEntry' | 'RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'RepoConfigEnableAnonymousGitAccessAuditEntry' | 'RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'RepoConfigEnableContributorsOnlyAuditEntry' | 'RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'RepoConfigLockAnonymousGitAccessAuditEntry' | 'RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'RepoCreateAuditEntry' | 'RepoDestroyAuditEntry' | 'RepoRemoveMemberAuditEntry' | 'RepoRemoveTopicAuditEntry' | 'RepositoryVisibilityChangeDisableAuditEntry' | 'RepositoryVisibilityChangeEnableAuditEntry' | 'TeamAddMemberAuditEntry' | 'TeamAddRepositoryAuditEntry' | 'TeamChangeParentTeamAuditEntry' | 'TeamRemoveMemberAuditEntry' | 'TeamRemoveRepositoryAuditEntry', ParentType, ContextType>;
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
};

export type GQLAuditEntryActorResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['AuditEntryActor'] = GQLResolversParentTypes['AuditEntryActor']> = {
  __resolveType: TypeResolveFn<'Bot' | 'Organization' | 'User', ParentType, ContextType>;
};

export type GQLAutomaticBaseChangeFailedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['AutomaticBaseChangeFailedEvent'] = GQLResolversParentTypes['AutomaticBaseChangeFailedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  newBase?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  oldBase?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  pullRequest?: Resolver<GQLResolversTypes['PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLAutomaticBaseChangeSucceededEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['AutomaticBaseChangeSucceededEvent'] = GQLResolversParentTypes['AutomaticBaseChangeSucceededEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  newBase?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  oldBase?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  pullRequest?: Resolver<GQLResolversTypes['PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLBaseRefChangedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['BaseRefChangedEvent'] = GQLResolversParentTypes['BaseRefChangedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLBaseRefForcePushedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['BaseRefForcePushedEvent'] = GQLResolversParentTypes['BaseRefForcePushedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  afterCommit?: Resolver<Maybe<GQLResolversTypes['Commit']>, ParentType, ContextType>;
  beforeCommit?: Resolver<Maybe<GQLResolversTypes['Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<GQLResolversTypes['PullRequest'], ParentType, ContextType>;
  ref?: Resolver<Maybe<GQLResolversTypes['Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLBlameResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Blame'] = GQLResolversParentTypes['Blame']> = {
  ranges?: Resolver<Array<GQLResolversTypes['BlameRange']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLBlameRangeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['BlameRange'] = GQLResolversParentTypes['BlameRange']> = {
  age?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  commit?: Resolver<GQLResolversTypes['Commit'], ParentType, ContextType>;
  endingLine?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  startingLine?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLBlobResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Blob'] = GQLResolversParentTypes['Blob']> = {
  abbreviatedOid?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  byteSize?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  commitResourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  commitUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isBinary?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isTruncated?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  oid?: Resolver<GQLResolversTypes['GitObjectID'], ParentType, ContextType>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  text?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLBotResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Bot'] = GQLResolversParentTypes['Bot']> = {
  avatarUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType, RequireFields<GQLBotAvatarUrlArgs, never>>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  login?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLBranchProtectionRuleResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['BranchProtectionRule'] = GQLResolversParentTypes['BranchProtectionRule']> = {
  branchProtectionRuleConflicts?: Resolver<GQLResolversTypes['BranchProtectionRuleConflictConnection'], ParentType, ContextType, RequireFields<GQLBranchProtectionRuleBranchProtectionRuleConflictsArgs, never>>;
  creator?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  dismissesStaleReviews?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isAdminEnforced?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  matchingRefs?: Resolver<GQLResolversTypes['RefConnection'], ParentType, ContextType, RequireFields<GQLBranchProtectionRuleMatchingRefsArgs, never>>;
  pattern?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  pushAllowances?: Resolver<GQLResolversTypes['PushAllowanceConnection'], ParentType, ContextType, RequireFields<GQLBranchProtectionRulePushAllowancesArgs, never>>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  requiredApprovingReviewCount?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  requiredStatusCheckContexts?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['String']>>>, ParentType, ContextType>;
  requiresApprovingReviews?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  requiresCodeOwnerReviews?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  requiresCommitSignatures?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  requiresStatusChecks?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  requiresStrictStatusChecks?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  restrictsPushes?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  restrictsReviewDismissals?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  reviewDismissalAllowances?: Resolver<GQLResolversTypes['ReviewDismissalAllowanceConnection'], ParentType, ContextType, RequireFields<GQLBranchProtectionRuleReviewDismissalAllowancesArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLBranchProtectionRuleConflictResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['BranchProtectionRuleConflict'] = GQLResolversParentTypes['BranchProtectionRuleConflict']> = {
  branchProtectionRule?: Resolver<Maybe<GQLResolversTypes['BranchProtectionRule']>, ParentType, ContextType>;
  conflictingBranchProtectionRule?: Resolver<Maybe<GQLResolversTypes['BranchProtectionRule']>, ParentType, ContextType>;
  ref?: Resolver<Maybe<GQLResolversTypes['Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLBranchProtectionRuleConflictConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['BranchProtectionRuleConflictConnection'] = GQLResolversParentTypes['BranchProtectionRuleConflictConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['BranchProtectionRuleConflictEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['BranchProtectionRuleConflict']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLBranchProtectionRuleConflictEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['BranchProtectionRuleConflictEdge'] = GQLResolversParentTypes['BranchProtectionRuleConflictEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['BranchProtectionRuleConflict']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLBranchProtectionRuleConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['BranchProtectionRuleConnection'] = GQLResolversParentTypes['BranchProtectionRuleConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['BranchProtectionRuleEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['BranchProtectionRule']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLBranchProtectionRuleEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['BranchProtectionRuleEdge'] = GQLResolversParentTypes['BranchProtectionRuleEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['BranchProtectionRule']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCancelEnterpriseAdminInvitationPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CancelEnterpriseAdminInvitationPayload'] = GQLResolversParentTypes['CancelEnterpriseAdminInvitationPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  invitation?: Resolver<Maybe<GQLResolversTypes['EnterpriseAdministratorInvitation']>, ParentType, ContextType>;
  message?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLChangeUserStatusPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ChangeUserStatusPayload'] = GQLResolversParentTypes['ChangeUserStatusPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<Maybe<GQLResolversTypes['UserStatus']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCheckAnnotationResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CheckAnnotation'] = GQLResolversParentTypes['CheckAnnotation']> = {
  annotationLevel?: Resolver<Maybe<GQLResolversTypes['CheckAnnotationLevel']>, ParentType, ContextType>;
  blobUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  location?: Resolver<GQLResolversTypes['CheckAnnotationSpan'], ParentType, ContextType>;
  message?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  rawDetails?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  title?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCheckAnnotationConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CheckAnnotationConnection'] = GQLResolversParentTypes['CheckAnnotationConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['CheckAnnotationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['CheckAnnotation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCheckAnnotationEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CheckAnnotationEdge'] = GQLResolversParentTypes['CheckAnnotationEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['CheckAnnotation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCheckAnnotationPositionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CheckAnnotationPosition'] = GQLResolversParentTypes['CheckAnnotationPosition']> = {
  column?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  line?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCheckAnnotationSpanResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CheckAnnotationSpan'] = GQLResolversParentTypes['CheckAnnotationSpan']> = {
  end?: Resolver<GQLResolversTypes['CheckAnnotationPosition'], ParentType, ContextType>;
  start?: Resolver<GQLResolversTypes['CheckAnnotationPosition'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCheckRunResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CheckRun'] = GQLResolversParentTypes['CheckRun']> = {
  annotations?: Resolver<Maybe<GQLResolversTypes['CheckAnnotationConnection']>, ParentType, ContextType, RequireFields<GQLCheckRunAnnotationsArgs, never>>;
  checkSuite?: Resolver<GQLResolversTypes['CheckSuite'], ParentType, ContextType>;
  completedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  conclusion?: Resolver<Maybe<GQLResolversTypes['CheckConclusionState']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  detailsUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  externalId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  permalink?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  startedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  status?: Resolver<GQLResolversTypes['CheckStatusState'], ParentType, ContextType>;
  summary?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  text?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  title?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCheckRunConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CheckRunConnection'] = GQLResolversParentTypes['CheckRunConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['CheckRunEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['CheckRun']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCheckRunEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CheckRunEdge'] = GQLResolversParentTypes['CheckRunEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['CheckRun']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCheckSuiteResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CheckSuite'] = GQLResolversParentTypes['CheckSuite']> = {
  app?: Resolver<Maybe<GQLResolversTypes['App']>, ParentType, ContextType>;
  branch?: Resolver<Maybe<GQLResolversTypes['Ref']>, ParentType, ContextType>;
  checkRuns?: Resolver<Maybe<GQLResolversTypes['CheckRunConnection']>, ParentType, ContextType, RequireFields<GQLCheckSuiteCheckRunsArgs, never>>;
  commit?: Resolver<GQLResolversTypes['Commit'], ParentType, ContextType>;
  conclusion?: Resolver<Maybe<GQLResolversTypes['CheckConclusionState']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  matchingPullRequests?: Resolver<Maybe<GQLResolversTypes['PullRequestConnection']>, ParentType, ContextType, RequireFields<GQLCheckSuiteMatchingPullRequestsArgs, never>>;
  push?: Resolver<Maybe<GQLResolversTypes['Push']>, ParentType, ContextType>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  status?: Resolver<GQLResolversTypes['CheckStatusState'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCheckSuiteConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CheckSuiteConnection'] = GQLResolversParentTypes['CheckSuiteConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['CheckSuiteEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['CheckSuite']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCheckSuiteEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CheckSuiteEdge'] = GQLResolversParentTypes['CheckSuiteEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['CheckSuite']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLClearLabelsFromLabelablePayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ClearLabelsFromLabelablePayload'] = GQLResolversParentTypes['ClearLabelsFromLabelablePayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  labelable?: Resolver<Maybe<GQLResolversTypes['Labelable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCloneProjectPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CloneProjectPayload'] = GQLResolversParentTypes['CloneProjectPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  jobStatusId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<GQLResolversTypes['Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCloneTemplateRepositoryPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CloneTemplateRepositoryPayload'] = GQLResolversParentTypes['CloneTemplateRepositoryPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLClosableResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Closable'] = GQLResolversParentTypes['Closable']> = {
  __resolveType: TypeResolveFn<'Issue' | 'Milestone' | 'Project' | 'PullRequest', ParentType, ContextType>;
  closed?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
};

export type GQLCloseIssuePayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CloseIssuePayload'] = GQLResolversParentTypes['CloseIssuePayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<GQLResolversTypes['Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLClosePullRequestPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ClosePullRequestPayload'] = GQLResolversParentTypes['ClosePullRequestPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<GQLResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLClosedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ClosedEvent'] = GQLResolversParentTypes['ClosedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  closable?: Resolver<GQLResolversTypes['Closable'], ParentType, ContextType>;
  closer?: Resolver<Maybe<GQLResolversTypes['Closer']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCloserResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Closer'] = GQLResolversParentTypes['Closer']> = {
  __resolveType: TypeResolveFn<'Commit' | 'PullRequest', ParentType, ContextType>;
};

export type GQLCodeOfConductResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CodeOfConduct'] = GQLResolversParentTypes['CodeOfConduct']> = {
  body?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  key?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  resourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  url?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCommentResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Comment'] = GQLResolversParentTypes['Comment']> = {
  __resolveType: TypeResolveFn<'CommitComment' | 'GistComment' | 'Issue' | 'IssueComment' | 'PullRequest' | 'PullRequestReview' | 'PullRequestReviewComment' | 'TeamDiscussion' | 'TeamDiscussionComment', ParentType, ContextType>;
  author?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<GQLResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType>;
  bodyText?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  editor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<GQLResolversTypes['UserContentEditConnection']>, ParentType, ContextType, RequireFields<GQLCommentUserContentEditsArgs, never>>;
  viewerDidAuthor?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
};

export type GQLCommentDeletedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CommentDeletedEvent'] = GQLResolversParentTypes['CommentDeletedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCommitResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Commit'] = GQLResolversParentTypes['Commit']> = {
  abbreviatedOid?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  additions?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  associatedPullRequests?: Resolver<Maybe<GQLResolversTypes['PullRequestConnection']>, ParentType, ContextType, RequireFields<GQLCommitAssociatedPullRequestsArgs, 'orderBy'>>;
  author?: Resolver<Maybe<GQLResolversTypes['GitActor']>, ParentType, ContextType>;
  authoredByCommitter?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  authoredDate?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  blame?: Resolver<GQLResolversTypes['Blame'], ParentType, ContextType, RequireFields<GQLCommitBlameArgs, 'path'>>;
  changedFiles?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  checkSuites?: Resolver<Maybe<GQLResolversTypes['CheckSuiteConnection']>, ParentType, ContextType, RequireFields<GQLCommitCheckSuitesArgs, never>>;
  comments?: Resolver<GQLResolversTypes['CommitCommentConnection'], ParentType, ContextType, RequireFields<GQLCommitCommentsArgs, never>>;
  commitResourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  commitUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  committedDate?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  committedViaWeb?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  committer?: Resolver<Maybe<GQLResolversTypes['GitActor']>, ParentType, ContextType>;
  deletions?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  deployments?: Resolver<Maybe<GQLResolversTypes['DeploymentConnection']>, ParentType, ContextType, RequireFields<GQLCommitDeploymentsArgs, 'orderBy'>>;
  history?: Resolver<GQLResolversTypes['CommitHistoryConnection'], ParentType, ContextType, RequireFields<GQLCommitHistoryArgs, never>>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  message?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  messageBody?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  messageBodyHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType>;
  messageHeadline?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  messageHeadlineHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType>;
  oid?: Resolver<GQLResolversTypes['GitObjectID'], ParentType, ContextType>;
  onBehalfOf?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  parents?: Resolver<GQLResolversTypes['CommitConnection'], ParentType, ContextType, RequireFields<GQLCommitParentsArgs, never>>;
  pushedDate?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  signature?: Resolver<Maybe<GQLResolversTypes['GitSignature']>, ParentType, ContextType>;
  status?: Resolver<Maybe<GQLResolversTypes['Status']>, ParentType, ContextType>;
  statusCheckRollup?: Resolver<Maybe<GQLResolversTypes['StatusCheckRollup']>, ParentType, ContextType>;
  submodules?: Resolver<GQLResolversTypes['SubmoduleConnection'], ParentType, ContextType, RequireFields<GQLCommitSubmodulesArgs, never>>;
  tarballUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  tree?: Resolver<GQLResolversTypes['Tree'], ParentType, ContextType>;
  treeResourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  treeUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<GQLResolversTypes['SubscriptionState']>, ParentType, ContextType>;
  zipballUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCommitCommentResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CommitComment'] = GQLResolversParentTypes['CommitComment']> = {
  author?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<GQLResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType>;
  bodyText?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  commit?: Resolver<Maybe<GQLResolversTypes['Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isMinimized?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  position?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<GQLResolversTypes['ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<GQLResolversTypes['ReactionConnection'], ParentType, ContextType, RequireFields<GQLCommitCommentReactionsArgs, never>>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<GQLResolversTypes['UserContentEditConnection']>, ParentType, ContextType, RequireFields<GQLCommitCommentUserContentEditsArgs, never>>;
  viewerCanDelete?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMinimize?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<GQLResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCommitCommentConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CommitCommentConnection'] = GQLResolversParentTypes['CommitCommentConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['CommitCommentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['CommitComment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCommitCommentEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CommitCommentEdge'] = GQLResolversParentTypes['CommitCommentEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['CommitComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCommitCommentThreadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CommitCommentThread'] = GQLResolversParentTypes['CommitCommentThread']> = {
  comments?: Resolver<GQLResolversTypes['CommitCommentConnection'], ParentType, ContextType, RequireFields<GQLCommitCommentThreadCommentsArgs, never>>;
  commit?: Resolver<Maybe<GQLResolversTypes['Commit']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  path?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  position?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCommitConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CommitConnection'] = GQLResolversParentTypes['CommitConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['CommitEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['Commit']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCommitContributionsByRepositoryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CommitContributionsByRepository'] = GQLResolversParentTypes['CommitContributionsByRepository']> = {
  contributions?: Resolver<GQLResolversTypes['CreatedCommitContributionConnection'], ParentType, ContextType, RequireFields<GQLCommitContributionsByRepositoryContributionsArgs, 'orderBy'>>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCommitEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CommitEdge'] = GQLResolversParentTypes['CommitEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['Commit']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCommitHistoryConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CommitHistoryConnection'] = GQLResolversParentTypes['CommitHistoryConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['CommitEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['Commit']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLConnectedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ConnectedEvent'] = GQLResolversParentTypes['ConnectedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isCrossRepository?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  source?: Resolver<GQLResolversTypes['ReferencedSubject'], ParentType, ContextType>;
  subject?: Resolver<GQLResolversTypes['ReferencedSubject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLContentAttachmentResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ContentAttachment'] = GQLResolversParentTypes['ContentAttachment']> = {
  body?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  contentReference?: Resolver<GQLResolversTypes['ContentReference'], ParentType, ContextType>;
  databaseId?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  title?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLContentReferenceResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ContentReference'] = GQLResolversParentTypes['ContentReference']> = {
  databaseId?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  reference?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLContributionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Contribution'] = GQLResolversParentTypes['Contribution']> = {
  __resolveType: TypeResolveFn<'CreatedCommitContribution' | 'CreatedIssueContribution' | 'CreatedPullRequestContribution' | 'CreatedPullRequestReviewContribution' | 'CreatedRepositoryContribution' | 'JoinedGitHubContribution' | 'RestrictedContribution', ParentType, ContextType>;
  isRestricted?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  user?: Resolver<GQLResolversTypes['User'], ParentType, ContextType>;
};

export type GQLContributionCalendarResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ContributionCalendar'] = GQLResolversParentTypes['ContributionCalendar']> = {
  colors?: Resolver<Array<GQLResolversTypes['String']>, ParentType, ContextType>;
  isHalloween?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  months?: Resolver<Array<GQLResolversTypes['ContributionCalendarMonth']>, ParentType, ContextType>;
  totalContributions?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  weeks?: Resolver<Array<GQLResolversTypes['ContributionCalendarWeek']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLContributionCalendarDayResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ContributionCalendarDay'] = GQLResolversParentTypes['ContributionCalendarDay']> = {
  color?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  contributionCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  date?: Resolver<GQLResolversTypes['Date'], ParentType, ContextType>;
  weekday?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLContributionCalendarMonthResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ContributionCalendarMonth'] = GQLResolversParentTypes['ContributionCalendarMonth']> = {
  firstDay?: Resolver<GQLResolversTypes['Date'], ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  totalWeeks?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  year?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLContributionCalendarWeekResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ContributionCalendarWeek'] = GQLResolversParentTypes['ContributionCalendarWeek']> = {
  contributionDays?: Resolver<Array<GQLResolversTypes['ContributionCalendarDay']>, ParentType, ContextType>;
  firstDay?: Resolver<GQLResolversTypes['Date'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLContributionsCollectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ContributionsCollection'] = GQLResolversParentTypes['ContributionsCollection']> = {
  commitContributionsByRepository?: Resolver<Array<GQLResolversTypes['CommitContributionsByRepository']>, ParentType, ContextType, RequireFields<GQLContributionsCollectionCommitContributionsByRepositoryArgs, 'maxRepositories'>>;
  contributionCalendar?: Resolver<GQLResolversTypes['ContributionCalendar'], ParentType, ContextType>;
  contributionYears?: Resolver<Array<GQLResolversTypes['Int']>, ParentType, ContextType>;
  doesEndInCurrentMonth?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  earliestRestrictedContributionDate?: Resolver<Maybe<GQLResolversTypes['Date']>, ParentType, ContextType>;
  endedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  firstIssueContribution?: Resolver<Maybe<GQLResolversTypes['CreatedIssueOrRestrictedContribution']>, ParentType, ContextType>;
  firstPullRequestContribution?: Resolver<Maybe<GQLResolversTypes['CreatedPullRequestOrRestrictedContribution']>, ParentType, ContextType>;
  firstRepositoryContribution?: Resolver<Maybe<GQLResolversTypes['CreatedRepositoryOrRestrictedContribution']>, ParentType, ContextType>;
  hasActivityInThePast?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  hasAnyContributions?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  hasAnyRestrictedContributions?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isSingleDay?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  issueContributions?: Resolver<GQLResolversTypes['CreatedIssueContributionConnection'], ParentType, ContextType, RequireFields<GQLContributionsCollectionIssueContributionsArgs, 'excludeFirst' | 'excludePopular' | 'orderBy'>>;
  issueContributionsByRepository?: Resolver<Array<GQLResolversTypes['IssueContributionsByRepository']>, ParentType, ContextType, RequireFields<GQLContributionsCollectionIssueContributionsByRepositoryArgs, 'excludeFirst' | 'excludePopular' | 'maxRepositories'>>;
  joinedGitHubContribution?: Resolver<Maybe<GQLResolversTypes['JoinedGitHubContribution']>, ParentType, ContextType>;
  latestRestrictedContributionDate?: Resolver<Maybe<GQLResolversTypes['Date']>, ParentType, ContextType>;
  mostRecentCollectionWithActivity?: Resolver<Maybe<GQLResolversTypes['ContributionsCollection']>, ParentType, ContextType>;
  mostRecentCollectionWithoutActivity?: Resolver<Maybe<GQLResolversTypes['ContributionsCollection']>, ParentType, ContextType>;
  popularIssueContribution?: Resolver<Maybe<GQLResolversTypes['CreatedIssueContribution']>, ParentType, ContextType>;
  popularPullRequestContribution?: Resolver<Maybe<GQLResolversTypes['CreatedPullRequestContribution']>, ParentType, ContextType>;
  pullRequestContributions?: Resolver<GQLResolversTypes['CreatedPullRequestContributionConnection'], ParentType, ContextType, RequireFields<GQLContributionsCollectionPullRequestContributionsArgs, 'excludeFirst' | 'excludePopular' | 'orderBy'>>;
  pullRequestContributionsByRepository?: Resolver<Array<GQLResolversTypes['PullRequestContributionsByRepository']>, ParentType, ContextType, RequireFields<GQLContributionsCollectionPullRequestContributionsByRepositoryArgs, 'excludeFirst' | 'excludePopular' | 'maxRepositories'>>;
  pullRequestReviewContributions?: Resolver<GQLResolversTypes['CreatedPullRequestReviewContributionConnection'], ParentType, ContextType, RequireFields<GQLContributionsCollectionPullRequestReviewContributionsArgs, 'orderBy'>>;
  pullRequestReviewContributionsByRepository?: Resolver<Array<GQLResolversTypes['PullRequestReviewContributionsByRepository']>, ParentType, ContextType, RequireFields<GQLContributionsCollectionPullRequestReviewContributionsByRepositoryArgs, 'maxRepositories'>>;
  repositoryContributions?: Resolver<GQLResolversTypes['CreatedRepositoryContributionConnection'], ParentType, ContextType, RequireFields<GQLContributionsCollectionRepositoryContributionsArgs, 'excludeFirst' | 'orderBy'>>;
  restrictedContributionsCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  startedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  totalCommitContributions?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  totalIssueContributions?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType, RequireFields<GQLContributionsCollectionTotalIssueContributionsArgs, 'excludeFirst' | 'excludePopular'>>;
  totalPullRequestContributions?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType, RequireFields<GQLContributionsCollectionTotalPullRequestContributionsArgs, 'excludeFirst' | 'excludePopular'>>;
  totalPullRequestReviewContributions?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  totalRepositoriesWithContributedCommits?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  totalRepositoriesWithContributedIssues?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType, RequireFields<GQLContributionsCollectionTotalRepositoriesWithContributedIssuesArgs, 'excludeFirst' | 'excludePopular'>>;
  totalRepositoriesWithContributedPullRequestReviews?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  totalRepositoriesWithContributedPullRequests?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType, RequireFields<GQLContributionsCollectionTotalRepositoriesWithContributedPullRequestsArgs, 'excludeFirst' | 'excludePopular'>>;
  totalRepositoryContributions?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType, RequireFields<GQLContributionsCollectionTotalRepositoryContributionsArgs, 'excludeFirst'>>;
  user?: Resolver<GQLResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLConvertProjectCardNoteToIssuePayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ConvertProjectCardNoteToIssuePayload'] = GQLResolversParentTypes['ConvertProjectCardNoteToIssuePayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  projectCard?: Resolver<Maybe<GQLResolversTypes['ProjectCard']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLConvertToDraftEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ConvertToDraftEvent'] = GQLResolversParentTypes['ConvertToDraftEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<GQLResolversTypes['PullRequest'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLConvertedNoteToIssueEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ConvertedNoteToIssueEvent'] = GQLResolversParentTypes['ConvertedNoteToIssueEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  project?: Resolver<Maybe<GQLResolversTypes['Project']>, ParentType, ContextType>;
  projectCard?: Resolver<Maybe<GQLResolversTypes['ProjectCard']>, ParentType, ContextType>;
  projectColumnName?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreateBranchProtectionRulePayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreateBranchProtectionRulePayload'] = GQLResolversParentTypes['CreateBranchProtectionRulePayload']> = {
  branchProtectionRule?: Resolver<Maybe<GQLResolversTypes['BranchProtectionRule']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreateCheckRunPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreateCheckRunPayload'] = GQLResolversParentTypes['CreateCheckRunPayload']> = {
  checkRun?: Resolver<Maybe<GQLResolversTypes['CheckRun']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreateCheckSuitePayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreateCheckSuitePayload'] = GQLResolversParentTypes['CreateCheckSuitePayload']> = {
  checkSuite?: Resolver<Maybe<GQLResolversTypes['CheckSuite']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreateContentAttachmentPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreateContentAttachmentPayload'] = GQLResolversParentTypes['CreateContentAttachmentPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  contentAttachment?: Resolver<Maybe<GQLResolversTypes['ContentAttachment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreateDeploymentPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreateDeploymentPayload'] = GQLResolversParentTypes['CreateDeploymentPayload']> = {
  autoMerged?: Resolver<Maybe<GQLResolversTypes['Boolean']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  deployment?: Resolver<Maybe<GQLResolversTypes['Deployment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreateDeploymentStatusPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreateDeploymentStatusPayload'] = GQLResolversParentTypes['CreateDeploymentStatusPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  deploymentStatus?: Resolver<Maybe<GQLResolversTypes['DeploymentStatus']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreateEnterpriseOrganizationPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreateEnterpriseOrganizationPayload'] = GQLResolversParentTypes['CreateEnterpriseOrganizationPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<GQLResolversTypes['Enterprise']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreateIpAllowListEntryPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreateIpAllowListEntryPayload'] = GQLResolversParentTypes['CreateIpAllowListEntryPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  ipAllowListEntry?: Resolver<Maybe<GQLResolversTypes['IpAllowListEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreateIssuePayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreateIssuePayload'] = GQLResolversParentTypes['CreateIssuePayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<GQLResolversTypes['Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreateLabelPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreateLabelPayload'] = GQLResolversParentTypes['CreateLabelPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  label?: Resolver<Maybe<GQLResolversTypes['Label']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreateProjectPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreateProjectPayload'] = GQLResolversParentTypes['CreateProjectPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<GQLResolversTypes['Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreatePullRequestPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreatePullRequestPayload'] = GQLResolversParentTypes['CreatePullRequestPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<GQLResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreateRefPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreateRefPayload'] = GQLResolversParentTypes['CreateRefPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  ref?: Resolver<Maybe<GQLResolversTypes['Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreateRepositoryPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreateRepositoryPayload'] = GQLResolversParentTypes['CreateRepositoryPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreateTeamDiscussionCommentPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreateTeamDiscussionCommentPayload'] = GQLResolversParentTypes['CreateTeamDiscussionCommentPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  teamDiscussionComment?: Resolver<Maybe<GQLResolversTypes['TeamDiscussionComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreateTeamDiscussionPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreateTeamDiscussionPayload'] = GQLResolversParentTypes['CreateTeamDiscussionPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  teamDiscussion?: Resolver<Maybe<GQLResolversTypes['TeamDiscussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreatedCommitContributionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreatedCommitContribution'] = GQLResolversParentTypes['CreatedCommitContribution']> = {
  commitCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  isRestricted?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  user?: Resolver<GQLResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreatedCommitContributionConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreatedCommitContributionConnection'] = GQLResolversParentTypes['CreatedCommitContributionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['CreatedCommitContributionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['CreatedCommitContribution']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreatedCommitContributionEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreatedCommitContributionEdge'] = GQLResolversParentTypes['CreatedCommitContributionEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['CreatedCommitContribution']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreatedIssueContributionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreatedIssueContribution'] = GQLResolversParentTypes['CreatedIssueContribution']> = {
  isRestricted?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  issue?: Resolver<GQLResolversTypes['Issue'], ParentType, ContextType>;
  occurredAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  user?: Resolver<GQLResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreatedIssueContributionConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreatedIssueContributionConnection'] = GQLResolversParentTypes['CreatedIssueContributionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['CreatedIssueContributionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['CreatedIssueContribution']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreatedIssueContributionEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreatedIssueContributionEdge'] = GQLResolversParentTypes['CreatedIssueContributionEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['CreatedIssueContribution']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreatedIssueOrRestrictedContributionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreatedIssueOrRestrictedContribution'] = GQLResolversParentTypes['CreatedIssueOrRestrictedContribution']> = {
  __resolveType: TypeResolveFn<'CreatedIssueContribution' | 'RestrictedContribution', ParentType, ContextType>;
};

export type GQLCreatedPullRequestContributionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreatedPullRequestContribution'] = GQLResolversParentTypes['CreatedPullRequestContribution']> = {
  isRestricted?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  pullRequest?: Resolver<GQLResolversTypes['PullRequest'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  user?: Resolver<GQLResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreatedPullRequestContributionConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreatedPullRequestContributionConnection'] = GQLResolversParentTypes['CreatedPullRequestContributionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['CreatedPullRequestContributionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['CreatedPullRequestContribution']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreatedPullRequestContributionEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreatedPullRequestContributionEdge'] = GQLResolversParentTypes['CreatedPullRequestContributionEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['CreatedPullRequestContribution']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreatedPullRequestOrRestrictedContributionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreatedPullRequestOrRestrictedContribution'] = GQLResolversParentTypes['CreatedPullRequestOrRestrictedContribution']> = {
  __resolveType: TypeResolveFn<'CreatedPullRequestContribution' | 'RestrictedContribution', ParentType, ContextType>;
};

export type GQLCreatedPullRequestReviewContributionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreatedPullRequestReviewContribution'] = GQLResolversParentTypes['CreatedPullRequestReviewContribution']> = {
  isRestricted?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  pullRequest?: Resolver<GQLResolversTypes['PullRequest'], ParentType, ContextType>;
  pullRequestReview?: Resolver<GQLResolversTypes['PullRequestReview'], ParentType, ContextType>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  user?: Resolver<GQLResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreatedPullRequestReviewContributionConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreatedPullRequestReviewContributionConnection'] = GQLResolversParentTypes['CreatedPullRequestReviewContributionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['CreatedPullRequestReviewContributionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['CreatedPullRequestReviewContribution']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreatedPullRequestReviewContributionEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreatedPullRequestReviewContributionEdge'] = GQLResolversParentTypes['CreatedPullRequestReviewContributionEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['CreatedPullRequestReviewContribution']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreatedRepositoryContributionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreatedRepositoryContribution'] = GQLResolversParentTypes['CreatedRepositoryContribution']> = {
  isRestricted?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  user?: Resolver<GQLResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreatedRepositoryContributionConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreatedRepositoryContributionConnection'] = GQLResolversParentTypes['CreatedRepositoryContributionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['CreatedRepositoryContributionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['CreatedRepositoryContribution']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreatedRepositoryContributionEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreatedRepositoryContributionEdge'] = GQLResolversParentTypes['CreatedRepositoryContributionEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['CreatedRepositoryContribution']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLCreatedRepositoryOrRestrictedContributionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CreatedRepositoryOrRestrictedContribution'] = GQLResolversParentTypes['CreatedRepositoryOrRestrictedContribution']> = {
  __resolveType: TypeResolveFn<'CreatedRepositoryContribution' | 'RestrictedContribution', ParentType, ContextType>;
};

export type GQLCrossReferencedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['CrossReferencedEvent'] = GQLResolversParentTypes['CrossReferencedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isCrossRepository?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  referencedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  source?: Resolver<GQLResolversTypes['ReferencedSubject'], ParentType, ContextType>;
  target?: Resolver<GQLResolversTypes['ReferencedSubject'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  willCloseTarget?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export interface GQLDateScalarConfig extends GraphQLScalarTypeConfig<GQLResolversTypes['Date'], any> {
  name: 'Date';
}

export interface GQLDateTimeScalarConfig extends GraphQLScalarTypeConfig<GQLResolversTypes['DateTime'], any> {
  name: 'DateTime';
}

export type GQLDeclineTopicSuggestionPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeclineTopicSuggestionPayload'] = GQLResolversParentTypes['DeclineTopicSuggestionPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  topic?: Resolver<Maybe<GQLResolversTypes['Topic']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeletableResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Deletable'] = GQLResolversParentTypes['Deletable']> = {
  __resolveType: TypeResolveFn<'CommitComment' | 'GistComment' | 'IssueComment' | 'PullRequestReview' | 'PullRequestReviewComment' | 'TeamDiscussion' | 'TeamDiscussionComment', ParentType, ContextType>;
  viewerCanDelete?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
};

export type GQLDeleteBranchProtectionRulePayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeleteBranchProtectionRulePayload'] = GQLResolversParentTypes['DeleteBranchProtectionRulePayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeleteDeploymentPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeleteDeploymentPayload'] = GQLResolversParentTypes['DeleteDeploymentPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeleteIpAllowListEntryPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeleteIpAllowListEntryPayload'] = GQLResolversParentTypes['DeleteIpAllowListEntryPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  ipAllowListEntry?: Resolver<Maybe<GQLResolversTypes['IpAllowListEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeleteIssueCommentPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeleteIssueCommentPayload'] = GQLResolversParentTypes['DeleteIssueCommentPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeleteIssuePayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeleteIssuePayload'] = GQLResolversParentTypes['DeleteIssuePayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeleteLabelPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeleteLabelPayload'] = GQLResolversParentTypes['DeleteLabelPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeletePackageVersionPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeletePackageVersionPayload'] = GQLResolversParentTypes['DeletePackageVersionPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  success?: Resolver<Maybe<GQLResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeleteProjectCardPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeleteProjectCardPayload'] = GQLResolversParentTypes['DeleteProjectCardPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  column?: Resolver<Maybe<GQLResolversTypes['ProjectColumn']>, ParentType, ContextType>;
  deletedCardId?: Resolver<Maybe<GQLResolversTypes['ID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeleteProjectColumnPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeleteProjectColumnPayload'] = GQLResolversParentTypes['DeleteProjectColumnPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  deletedColumnId?: Resolver<Maybe<GQLResolversTypes['ID']>, ParentType, ContextType>;
  project?: Resolver<Maybe<GQLResolversTypes['Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeleteProjectPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeleteProjectPayload'] = GQLResolversParentTypes['DeleteProjectPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<Maybe<GQLResolversTypes['ProjectOwner']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeletePullRequestReviewCommentPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeletePullRequestReviewCommentPayload'] = GQLResolversParentTypes['DeletePullRequestReviewCommentPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<GQLResolversTypes['PullRequestReview']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeletePullRequestReviewPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeletePullRequestReviewPayload'] = GQLResolversParentTypes['DeletePullRequestReviewPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<GQLResolversTypes['PullRequestReview']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeleteRefPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeleteRefPayload'] = GQLResolversParentTypes['DeleteRefPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeleteTeamDiscussionCommentPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeleteTeamDiscussionCommentPayload'] = GQLResolversParentTypes['DeleteTeamDiscussionCommentPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeleteTeamDiscussionPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeleteTeamDiscussionPayload'] = GQLResolversParentTypes['DeleteTeamDiscussionPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDemilestonedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DemilestonedEvent'] = GQLResolversParentTypes['DemilestonedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  milestoneTitle?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  subject?: Resolver<GQLResolversTypes['MilestoneItem'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDependencyGraphDependencyResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DependencyGraphDependency'] = GQLResolversParentTypes['DependencyGraphDependency']> = {
  hasDependencies?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  packageManager?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  packageName?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  requirements?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDependencyGraphDependencyConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DependencyGraphDependencyConnection'] = GQLResolversParentTypes['DependencyGraphDependencyConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['DependencyGraphDependencyEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['DependencyGraphDependency']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDependencyGraphDependencyEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DependencyGraphDependencyEdge'] = GQLResolversParentTypes['DependencyGraphDependencyEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['DependencyGraphDependency']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDependencyGraphManifestResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DependencyGraphManifest'] = GQLResolversParentTypes['DependencyGraphManifest']> = {
  blobPath?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  dependencies?: Resolver<Maybe<GQLResolversTypes['DependencyGraphDependencyConnection']>, ParentType, ContextType, RequireFields<GQLDependencyGraphManifestDependenciesArgs, never>>;
  dependenciesCount?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  exceedsMaxSize?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  filename?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  parseable?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDependencyGraphManifestConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DependencyGraphManifestConnection'] = GQLResolversParentTypes['DependencyGraphManifestConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['DependencyGraphManifestEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['DependencyGraphManifest']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDependencyGraphManifestEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DependencyGraphManifestEdge'] = GQLResolversParentTypes['DependencyGraphManifestEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['DependencyGraphManifest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeployKeyResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeployKey'] = GQLResolversParentTypes['DeployKey']> = {
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  key?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  readOnly?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  title?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  verified?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeployKeyConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeployKeyConnection'] = GQLResolversParentTypes['DeployKeyConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['DeployKeyEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['DeployKey']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeployKeyEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeployKeyEdge'] = GQLResolversParentTypes['DeployKeyEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['DeployKey']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeployedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeployedEvent'] = GQLResolversParentTypes['DeployedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  deployment?: Resolver<GQLResolversTypes['Deployment'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<GQLResolversTypes['PullRequest'], ParentType, ContextType>;
  ref?: Resolver<Maybe<GQLResolversTypes['Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeploymentResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Deployment'] = GQLResolversParentTypes['Deployment']> = {
  commit?: Resolver<Maybe<GQLResolversTypes['Commit']>, ParentType, ContextType>;
  commitOid?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<GQLResolversTypes['Actor'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  environment?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  latestEnvironment?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  latestStatus?: Resolver<Maybe<GQLResolversTypes['DeploymentStatus']>, ParentType, ContextType>;
  originalEnvironment?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  payload?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  ref?: Resolver<Maybe<GQLResolversTypes['Ref']>, ParentType, ContextType>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  state?: Resolver<Maybe<GQLResolversTypes['DeploymentState']>, ParentType, ContextType>;
  statuses?: Resolver<Maybe<GQLResolversTypes['DeploymentStatusConnection']>, ParentType, ContextType, RequireFields<GQLDeploymentStatusesArgs, never>>;
  task?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeploymentConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeploymentConnection'] = GQLResolversParentTypes['DeploymentConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['DeploymentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['Deployment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeploymentEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeploymentEdge'] = GQLResolversParentTypes['DeploymentEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['Deployment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeploymentEnvironmentChangedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeploymentEnvironmentChangedEvent'] = GQLResolversParentTypes['DeploymentEnvironmentChangedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  deploymentStatus?: Resolver<GQLResolversTypes['DeploymentStatus'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<GQLResolversTypes['PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeploymentStatusResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeploymentStatus'] = GQLResolversParentTypes['DeploymentStatus']> = {
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<GQLResolversTypes['Actor'], ParentType, ContextType>;
  deployment?: Resolver<GQLResolversTypes['Deployment'], ParentType, ContextType>;
  description?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  environment?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  environmentUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  logUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  state?: Resolver<GQLResolversTypes['DeploymentStatusState'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeploymentStatusConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeploymentStatusConnection'] = GQLResolversParentTypes['DeploymentStatusConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['DeploymentStatusEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['DeploymentStatus']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDeploymentStatusEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DeploymentStatusEdge'] = GQLResolversParentTypes['DeploymentStatusEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['DeploymentStatus']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDisconnectedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DisconnectedEvent'] = GQLResolversParentTypes['DisconnectedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isCrossRepository?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  source?: Resolver<GQLResolversTypes['ReferencedSubject'], ParentType, ContextType>;
  subject?: Resolver<GQLResolversTypes['ReferencedSubject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLDismissPullRequestReviewPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['DismissPullRequestReviewPayload'] = GQLResolversParentTypes['DismissPullRequestReviewPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<GQLResolversTypes['PullRequestReview']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Enterprise'] = GQLResolversParentTypes['Enterprise']> = {
  avatarUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType, RequireFields<GQLEnterpriseAvatarUrlArgs, never>>;
  billingInfo?: Resolver<Maybe<GQLResolversTypes['EnterpriseBillingInfo']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  descriptionHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  location?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  members?: Resolver<GQLResolversTypes['EnterpriseMemberConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseMembersArgs, 'orderBy'>>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  organizations?: Resolver<GQLResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOrganizationsArgs, 'orderBy'>>;
  ownerInfo?: Resolver<Maybe<GQLResolversTypes['EnterpriseOwnerInfo']>, ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  slug?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  userAccounts?: Resolver<GQLResolversTypes['EnterpriseUserAccountConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseUserAccountsArgs, never>>;
  viewerIsAdmin?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  websiteUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseAdministratorConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseAdministratorConnection'] = GQLResolversParentTypes['EnterpriseAdministratorConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['EnterpriseAdministratorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseAdministratorEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseAdministratorEdge'] = GQLResolversParentTypes['EnterpriseAdministratorEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  role?: Resolver<GQLResolversTypes['EnterpriseAdministratorRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseAdministratorInvitationResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseAdministratorInvitation'] = GQLResolversParentTypes['EnterpriseAdministratorInvitation']> = {
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  email?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<GQLResolversTypes['Enterprise'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  invitee?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  inviter?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  role?: Resolver<GQLResolversTypes['EnterpriseAdministratorRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseAdministratorInvitationConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseAdministratorInvitationConnection'] = GQLResolversParentTypes['EnterpriseAdministratorInvitationConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['EnterpriseAdministratorInvitationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['EnterpriseAdministratorInvitation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseAdministratorInvitationEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseAdministratorInvitationEdge'] = GQLResolversParentTypes['EnterpriseAdministratorInvitationEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['EnterpriseAdministratorInvitation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseAuditEntryDataResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseAuditEntryData'] = GQLResolversParentTypes['EnterpriseAuditEntryData']> = {
  __resolveType: TypeResolveFn<'MembersCanDeleteReposClearAuditEntry' | 'MembersCanDeleteReposDisableAuditEntry' | 'MembersCanDeleteReposEnableAuditEntry' | 'OrgInviteToBusinessAuditEntry' | 'PrivateRepositoryForkingDisableAuditEntry' | 'PrivateRepositoryForkingEnableAuditEntry' | 'RepositoryVisibilityChangeDisableAuditEntry' | 'RepositoryVisibilityChangeEnableAuditEntry', ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
};

export type GQLEnterpriseBillingInfoResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseBillingInfo'] = GQLResolversParentTypes['EnterpriseBillingInfo']> = {
  allLicensableUsersCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  assetPacks?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  availableSeats?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  bandwidthQuota?: Resolver<GQLResolversTypes['Float'], ParentType, ContextType>;
  bandwidthUsage?: Resolver<GQLResolversTypes['Float'], ParentType, ContextType>;
  bandwidthUsagePercentage?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  seats?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  storageQuota?: Resolver<GQLResolversTypes['Float'], ParentType, ContextType>;
  storageUsage?: Resolver<GQLResolversTypes['Float'], ParentType, ContextType>;
  storageUsagePercentage?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  totalAvailableLicenses?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  totalLicenses?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseIdentityProviderResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseIdentityProvider'] = GQLResolversParentTypes['EnterpriseIdentityProvider']> = {
  digestMethod?: Resolver<Maybe<GQLResolversTypes['SamlDigestAlgorithm']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<GQLResolversTypes['Enterprise']>, ParentType, ContextType>;
  externalIdentities?: Resolver<GQLResolversTypes['ExternalIdentityConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseIdentityProviderExternalIdentitiesArgs, never>>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  idpCertificate?: Resolver<Maybe<GQLResolversTypes['X509Certificate']>, ParentType, ContextType>;
  issuer?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  recoveryCodes?: Resolver<Maybe<Array<GQLResolversTypes['String']>>, ParentType, ContextType>;
  signatureMethod?: Resolver<Maybe<GQLResolversTypes['SamlSignatureAlgorithm']>, ParentType, ContextType>;
  ssoUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseMemberResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseMember'] = GQLResolversParentTypes['EnterpriseMember']> = {
  __resolveType: TypeResolveFn<'EnterpriseUserAccount' | 'User', ParentType, ContextType>;
};

export type GQLEnterpriseMemberConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseMemberConnection'] = GQLResolversParentTypes['EnterpriseMemberConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['EnterpriseMemberEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['EnterpriseMember']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseMemberEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseMemberEdge'] = GQLResolversParentTypes['EnterpriseMemberEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  isUnlicensed?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['EnterpriseMember']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseOrganizationMembershipConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseOrganizationMembershipConnection'] = GQLResolversParentTypes['EnterpriseOrganizationMembershipConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['EnterpriseOrganizationMembershipEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['Organization']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseOrganizationMembershipEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseOrganizationMembershipEdge'] = GQLResolversParentTypes['EnterpriseOrganizationMembershipEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  role?: Resolver<GQLResolversTypes['EnterpriseUserAccountMembershipRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseOutsideCollaboratorConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseOutsideCollaboratorConnection'] = GQLResolversParentTypes['EnterpriseOutsideCollaboratorConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['EnterpriseOutsideCollaboratorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseOutsideCollaboratorEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseOutsideCollaboratorEdge'] = GQLResolversParentTypes['EnterpriseOutsideCollaboratorEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  isUnlicensed?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  repositories?: Resolver<GQLResolversTypes['EnterpriseRepositoryInfoConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOutsideCollaboratorEdgeRepositoriesArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseOwnerInfoResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseOwnerInfo'] = GQLResolversParentTypes['EnterpriseOwnerInfo']> = {
  actionExecutionCapabilitySettingOrganizations?: Resolver<GQLResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOwnerInfoActionExecutionCapabilitySettingOrganizationsArgs, 'orderBy'>>;
  admins?: Resolver<GQLResolversTypes['EnterpriseAdministratorConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOwnerInfoAdminsArgs, 'orderBy'>>;
  affiliatedUsersWithTwoFactorDisabled?: Resolver<GQLResolversTypes['UserConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOwnerInfoAffiliatedUsersWithTwoFactorDisabledArgs, never>>;
  affiliatedUsersWithTwoFactorDisabledExist?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  allowPrivateRepositoryForkingSetting?: Resolver<GQLResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  allowPrivateRepositoryForkingSettingOrganizations?: Resolver<GQLResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOwnerInfoAllowPrivateRepositoryForkingSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  defaultRepositoryPermissionSetting?: Resolver<GQLResolversTypes['EnterpriseDefaultRepositoryPermissionSettingValue'], ParentType, ContextType>;
  defaultRepositoryPermissionSettingOrganizations?: Resolver<GQLResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOwnerInfoDefaultRepositoryPermissionSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  enterpriseServerInstallations?: Resolver<GQLResolversTypes['EnterpriseServerInstallationConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOwnerInfoEnterpriseServerInstallationsArgs, 'connectedOnly' | 'orderBy'>>;
  ipAllowListEnabledSetting?: Resolver<GQLResolversTypes['IpAllowListEnabledSettingValue'], ParentType, ContextType>;
  ipAllowListEntries?: Resolver<GQLResolversTypes['IpAllowListEntryConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOwnerInfoIpAllowListEntriesArgs, 'orderBy'>>;
  isUpdatingDefaultRepositoryPermission?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isUpdatingTwoFactorRequirement?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  membersCanChangeRepositoryVisibilitySetting?: Resolver<GQLResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  membersCanChangeRepositoryVisibilitySettingOrganizations?: Resolver<GQLResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOwnerInfoMembersCanChangeRepositoryVisibilitySettingOrganizationsArgs, 'orderBy' | 'value'>>;
  membersCanCreateInternalRepositoriesSetting?: Resolver<Maybe<GQLResolversTypes['Boolean']>, ParentType, ContextType>;
  membersCanCreatePrivateRepositoriesSetting?: Resolver<Maybe<GQLResolversTypes['Boolean']>, ParentType, ContextType>;
  membersCanCreatePublicRepositoriesSetting?: Resolver<Maybe<GQLResolversTypes['Boolean']>, ParentType, ContextType>;
  membersCanCreateRepositoriesSetting?: Resolver<Maybe<GQLResolversTypes['EnterpriseMembersCanCreateRepositoriesSettingValue']>, ParentType, ContextType>;
  membersCanCreateRepositoriesSettingOrganizations?: Resolver<GQLResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOwnerInfoMembersCanCreateRepositoriesSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  membersCanDeleteIssuesSetting?: Resolver<GQLResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  membersCanDeleteIssuesSettingOrganizations?: Resolver<GQLResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOwnerInfoMembersCanDeleteIssuesSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  membersCanDeleteRepositoriesSetting?: Resolver<GQLResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  membersCanDeleteRepositoriesSettingOrganizations?: Resolver<GQLResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOwnerInfoMembersCanDeleteRepositoriesSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  membersCanInviteCollaboratorsSetting?: Resolver<GQLResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  membersCanInviteCollaboratorsSettingOrganizations?: Resolver<GQLResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOwnerInfoMembersCanInviteCollaboratorsSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  membersCanMakePurchasesSetting?: Resolver<GQLResolversTypes['EnterpriseMembersCanMakePurchasesSettingValue'], ParentType, ContextType>;
  membersCanUpdateProtectedBranchesSetting?: Resolver<GQLResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  membersCanUpdateProtectedBranchesSettingOrganizations?: Resolver<GQLResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOwnerInfoMembersCanUpdateProtectedBranchesSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  membersCanViewDependencyInsightsSetting?: Resolver<GQLResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  membersCanViewDependencyInsightsSettingOrganizations?: Resolver<GQLResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOwnerInfoMembersCanViewDependencyInsightsSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  organizationProjectsSetting?: Resolver<GQLResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  organizationProjectsSettingOrganizations?: Resolver<GQLResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOwnerInfoOrganizationProjectsSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  outsideCollaborators?: Resolver<GQLResolversTypes['EnterpriseOutsideCollaboratorConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOwnerInfoOutsideCollaboratorsArgs, 'orderBy'>>;
  pendingAdminInvitations?: Resolver<GQLResolversTypes['EnterpriseAdministratorInvitationConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOwnerInfoPendingAdminInvitationsArgs, 'orderBy'>>;
  pendingCollaboratorInvitations?: Resolver<GQLResolversTypes['RepositoryInvitationConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOwnerInfoPendingCollaboratorInvitationsArgs, 'orderBy'>>;
  pendingCollaborators?: Resolver<GQLResolversTypes['EnterprisePendingCollaboratorConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOwnerInfoPendingCollaboratorsArgs, 'orderBy'>>;
  pendingMemberInvitations?: Resolver<GQLResolversTypes['EnterprisePendingMemberInvitationConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOwnerInfoPendingMemberInvitationsArgs, never>>;
  repositoryProjectsSetting?: Resolver<GQLResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  repositoryProjectsSettingOrganizations?: Resolver<GQLResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOwnerInfoRepositoryProjectsSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  samlIdentityProvider?: Resolver<Maybe<GQLResolversTypes['EnterpriseIdentityProvider']>, ParentType, ContextType>;
  samlIdentityProviderSettingOrganizations?: Resolver<GQLResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOwnerInfoSamlIdentityProviderSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  teamDiscussionsSetting?: Resolver<GQLResolversTypes['EnterpriseEnabledDisabledSettingValue'], ParentType, ContextType>;
  teamDiscussionsSettingOrganizations?: Resolver<GQLResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOwnerInfoTeamDiscussionsSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  twoFactorRequiredSetting?: Resolver<GQLResolversTypes['EnterpriseEnabledSettingValue'], ParentType, ContextType>;
  twoFactorRequiredSettingOrganizations?: Resolver<GQLResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseOwnerInfoTwoFactorRequiredSettingOrganizationsArgs, 'orderBy' | 'value'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterprisePendingCollaboratorConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterprisePendingCollaboratorConnection'] = GQLResolversParentTypes['EnterprisePendingCollaboratorConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['EnterprisePendingCollaboratorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterprisePendingCollaboratorEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterprisePendingCollaboratorEdge'] = GQLResolversParentTypes['EnterprisePendingCollaboratorEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  isUnlicensed?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  repositories?: Resolver<GQLResolversTypes['EnterpriseRepositoryInfoConnection'], ParentType, ContextType, RequireFields<GQLEnterprisePendingCollaboratorEdgeRepositoriesArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterprisePendingMemberInvitationConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterprisePendingMemberInvitationConnection'] = GQLResolversParentTypes['EnterprisePendingMemberInvitationConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['EnterprisePendingMemberInvitationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['OrganizationInvitation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  totalUniqueUserCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterprisePendingMemberInvitationEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterprisePendingMemberInvitationEdge'] = GQLResolversParentTypes['EnterprisePendingMemberInvitationEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  isUnlicensed?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['OrganizationInvitation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseRepositoryInfoResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseRepositoryInfo'] = GQLResolversParentTypes['EnterpriseRepositoryInfo']> = {
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isPrivate?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  nameWithOwner?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseRepositoryInfoConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseRepositoryInfoConnection'] = GQLResolversParentTypes['EnterpriseRepositoryInfoConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['EnterpriseRepositoryInfoEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['EnterpriseRepositoryInfo']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseRepositoryInfoEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseRepositoryInfoEdge'] = GQLResolversParentTypes['EnterpriseRepositoryInfoEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['EnterpriseRepositoryInfo']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseServerInstallationResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseServerInstallation'] = GQLResolversParentTypes['EnterpriseServerInstallation']> = {
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  customerName?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  hostName?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isConnected?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  userAccounts?: Resolver<GQLResolversTypes['EnterpriseServerUserAccountConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseServerInstallationUserAccountsArgs, 'orderBy'>>;
  userAccountsUploads?: Resolver<GQLResolversTypes['EnterpriseServerUserAccountsUploadConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseServerInstallationUserAccountsUploadsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseServerInstallationConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseServerInstallationConnection'] = GQLResolversParentTypes['EnterpriseServerInstallationConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['EnterpriseServerInstallationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['EnterpriseServerInstallation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseServerInstallationEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseServerInstallationEdge'] = GQLResolversParentTypes['EnterpriseServerInstallationEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['EnterpriseServerInstallation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseServerUserAccountResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseServerUserAccount'] = GQLResolversParentTypes['EnterpriseServerUserAccount']> = {
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  emails?: Resolver<GQLResolversTypes['EnterpriseServerUserAccountEmailConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseServerUserAccountEmailsArgs, 'orderBy'>>;
  enterpriseServerInstallation?: Resolver<GQLResolversTypes['EnterpriseServerInstallation'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isSiteAdmin?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  login?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  profileName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  remoteCreatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  remoteUserId?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseServerUserAccountConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseServerUserAccountConnection'] = GQLResolversParentTypes['EnterpriseServerUserAccountConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['EnterpriseServerUserAccountEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['EnterpriseServerUserAccount']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseServerUserAccountEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseServerUserAccountEdge'] = GQLResolversParentTypes['EnterpriseServerUserAccountEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['EnterpriseServerUserAccount']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseServerUserAccountEmailResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseServerUserAccountEmail'] = GQLResolversParentTypes['EnterpriseServerUserAccountEmail']> = {
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  email?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isPrimary?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  userAccount?: Resolver<GQLResolversTypes['EnterpriseServerUserAccount'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseServerUserAccountEmailConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseServerUserAccountEmailConnection'] = GQLResolversParentTypes['EnterpriseServerUserAccountEmailConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['EnterpriseServerUserAccountEmailEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['EnterpriseServerUserAccountEmail']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseServerUserAccountEmailEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseServerUserAccountEmailEdge'] = GQLResolversParentTypes['EnterpriseServerUserAccountEmailEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['EnterpriseServerUserAccountEmail']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseServerUserAccountsUploadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseServerUserAccountsUpload'] = GQLResolversParentTypes['EnterpriseServerUserAccountsUpload']> = {
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  enterprise?: Resolver<GQLResolversTypes['Enterprise'], ParentType, ContextType>;
  enterpriseServerInstallation?: Resolver<GQLResolversTypes['EnterpriseServerInstallation'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  syncState?: Resolver<GQLResolversTypes['EnterpriseServerUserAccountsUploadSyncState'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseServerUserAccountsUploadConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseServerUserAccountsUploadConnection'] = GQLResolversParentTypes['EnterpriseServerUserAccountsUploadConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['EnterpriseServerUserAccountsUploadEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['EnterpriseServerUserAccountsUpload']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseServerUserAccountsUploadEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseServerUserAccountsUploadEdge'] = GQLResolversParentTypes['EnterpriseServerUserAccountsUploadEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['EnterpriseServerUserAccountsUpload']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseUserAccountResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseUserAccount'] = GQLResolversParentTypes['EnterpriseUserAccount']> = {
  avatarUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType, RequireFields<GQLEnterpriseUserAccountAvatarUrlArgs, never>>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  enterprise?: Resolver<GQLResolversTypes['Enterprise'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  login?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizations?: Resolver<GQLResolversTypes['EnterpriseOrganizationMembershipConnection'], ParentType, ContextType, RequireFields<GQLEnterpriseUserAccountOrganizationsArgs, 'orderBy'>>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseUserAccountConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseUserAccountConnection'] = GQLResolversParentTypes['EnterpriseUserAccountConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['EnterpriseUserAccountEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['EnterpriseUserAccount']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLEnterpriseUserAccountEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['EnterpriseUserAccountEdge'] = GQLResolversParentTypes['EnterpriseUserAccountEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['EnterpriseUserAccount']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLExternalIdentityResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ExternalIdentity'] = GQLResolversParentTypes['ExternalIdentity']> = {
  guid?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  organizationInvitation?: Resolver<Maybe<GQLResolversTypes['OrganizationInvitation']>, ParentType, ContextType>;
  samlIdentity?: Resolver<Maybe<GQLResolversTypes['ExternalIdentitySamlAttributes']>, ParentType, ContextType>;
  scimIdentity?: Resolver<Maybe<GQLResolversTypes['ExternalIdentityScimAttributes']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLExternalIdentityConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ExternalIdentityConnection'] = GQLResolversParentTypes['ExternalIdentityConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['ExternalIdentityEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['ExternalIdentity']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLExternalIdentityEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ExternalIdentityEdge'] = GQLResolversParentTypes['ExternalIdentityEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['ExternalIdentity']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLExternalIdentitySamlAttributesResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ExternalIdentitySamlAttributes'] = GQLResolversParentTypes['ExternalIdentitySamlAttributes']> = {
  nameId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLExternalIdentityScimAttributesResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ExternalIdentityScimAttributes'] = GQLResolversParentTypes['ExternalIdentityScimAttributes']> = {
  username?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLFollowUserPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['FollowUserPayload'] = GQLResolversParentTypes['FollowUserPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLFollowerConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['FollowerConnection'] = GQLResolversParentTypes['FollowerConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['UserEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLFollowingConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['FollowingConnection'] = GQLResolversParentTypes['FollowingConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['UserEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLFundingLinkResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['FundingLink'] = GQLResolversParentTypes['FundingLink']> = {
  platform?: Resolver<GQLResolversTypes['FundingPlatform'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLGenericHovercardContextResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['GenericHovercardContext'] = GQLResolversParentTypes['GenericHovercardContext']> = {
  message?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  octicon?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLGistResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Gist'] = GQLResolversParentTypes['Gist']> = {
  comments?: Resolver<GQLResolversTypes['GistCommentConnection'], ParentType, ContextType, RequireFields<GQLGistCommentsArgs, never>>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  files?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['GistFile']>>>, ParentType, ContextType, RequireFields<GQLGistFilesArgs, 'limit'>>;
  forks?: Resolver<GQLResolversTypes['GistConnection'], ParentType, ContextType, RequireFields<GQLGistForksArgs, never>>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isFork?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isPublic?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  owner?: Resolver<Maybe<GQLResolversTypes['RepositoryOwner']>, ParentType, ContextType>;
  pushedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  stargazers?: Resolver<GQLResolversTypes['StargazerConnection'], ParentType, ContextType, RequireFields<GQLGistStargazersArgs, never>>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  viewerHasStarred?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLGistCommentResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['GistComment'] = GQLResolversParentTypes['GistComment']> = {
  author?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<GQLResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType>;
  bodyText?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  gist?: Resolver<GQLResolversTypes['Gist'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isMinimized?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<GQLResolversTypes['UserContentEditConnection']>, ParentType, ContextType, RequireFields<GQLGistCommentUserContentEditsArgs, never>>;
  viewerCanDelete?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMinimize?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<GQLResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLGistCommentConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['GistCommentConnection'] = GQLResolversParentTypes['GistCommentConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['GistCommentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['GistComment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLGistCommentEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['GistCommentEdge'] = GQLResolversParentTypes['GistCommentEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['GistComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLGistConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['GistConnection'] = GQLResolversParentTypes['GistConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['GistEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['Gist']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLGistEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['GistEdge'] = GQLResolversParentTypes['GistEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['Gist']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLGistFileResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['GistFile'] = GQLResolversParentTypes['GistFile']> = {
  encodedName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  encoding?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  extension?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  isImage?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isTruncated?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  language?: Resolver<Maybe<GQLResolversTypes['Language']>, ParentType, ContextType>;
  name?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  size?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  text?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType, RequireFields<GQLGistFileTextArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLGitActorResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['GitActor'] = GQLResolversParentTypes['GitActor']> = {
  avatarUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType, RequireFields<GQLGitActorAvatarUrlArgs, never>>;
  date?: Resolver<Maybe<GQLResolversTypes['GitTimestamp']>, ParentType, ContextType>;
  email?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLGitHubMetadataResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['GitHubMetadata'] = GQLResolversParentTypes['GitHubMetadata']> = {
  gitHubServicesSha?: Resolver<GQLResolversTypes['GitObjectID'], ParentType, ContextType>;
  gitIpAddresses?: Resolver<Maybe<Array<GQLResolversTypes['String']>>, ParentType, ContextType>;
  hookIpAddresses?: Resolver<Maybe<Array<GQLResolversTypes['String']>>, ParentType, ContextType>;
  importerIpAddresses?: Resolver<Maybe<Array<GQLResolversTypes['String']>>, ParentType, ContextType>;
  isPasswordAuthenticationVerifiable?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  pagesIpAddresses?: Resolver<Maybe<Array<GQLResolversTypes['String']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLGitObjectResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['GitObject'] = GQLResolversParentTypes['GitObject']> = {
  __resolveType: TypeResolveFn<'Blob' | 'Commit' | 'Tag' | 'Tree', ParentType, ContextType>;
  abbreviatedOid?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  commitResourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  commitUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  oid?: Resolver<GQLResolversTypes['GitObjectID'], ParentType, ContextType>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
};

export interface GQLGitObjectIdScalarConfig extends GraphQLScalarTypeConfig<GQLResolversTypes['GitObjectID'], any> {
  name: 'GitObjectID';
}

export interface GQLGitRefnameScalarConfig extends GraphQLScalarTypeConfig<GQLResolversTypes['GitRefname'], any> {
  name: 'GitRefname';
}

export interface GQLGitSshRemoteScalarConfig extends GraphQLScalarTypeConfig<GQLResolversTypes['GitSSHRemote'], any> {
  name: 'GitSSHRemote';
}

export type GQLGitSignatureResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['GitSignature'] = GQLResolversParentTypes['GitSignature']> = {
  __resolveType: TypeResolveFn<'GpgSignature' | 'SmimeSignature' | 'UnknownSignature', ParentType, ContextType>;
  email?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  isValid?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  payload?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  signature?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  signer?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  state?: Resolver<GQLResolversTypes['GitSignatureState'], ParentType, ContextType>;
  wasSignedByGitHub?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
};

export interface GQLGitTimestampScalarConfig extends GraphQLScalarTypeConfig<GQLResolversTypes['GitTimestamp'], any> {
  name: 'GitTimestamp';
}

export type GQLGpgSignatureResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['GpgSignature'] = GQLResolversParentTypes['GpgSignature']> = {
  email?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  isValid?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  keyId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  payload?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  signature?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  signer?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  state?: Resolver<GQLResolversTypes['GitSignatureState'], ParentType, ContextType>;
  wasSignedByGitHub?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export interface GQLHtmlScalarConfig extends GraphQLScalarTypeConfig<GQLResolversTypes['HTML'], any> {
  name: 'HTML';
}

export type GQLHeadRefDeletedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['HeadRefDeletedEvent'] = GQLResolversParentTypes['HeadRefDeletedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  headRef?: Resolver<Maybe<GQLResolversTypes['Ref']>, ParentType, ContextType>;
  headRefName?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<GQLResolversTypes['PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLHeadRefForcePushedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['HeadRefForcePushedEvent'] = GQLResolversParentTypes['HeadRefForcePushedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  afterCommit?: Resolver<Maybe<GQLResolversTypes['Commit']>, ParentType, ContextType>;
  beforeCommit?: Resolver<Maybe<GQLResolversTypes['Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<GQLResolversTypes['PullRequest'], ParentType, ContextType>;
  ref?: Resolver<Maybe<GQLResolversTypes['Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLHeadRefRestoredEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['HeadRefRestoredEvent'] = GQLResolversParentTypes['HeadRefRestoredEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<GQLResolversTypes['PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLHovercardResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Hovercard'] = GQLResolversParentTypes['Hovercard']> = {
  contexts?: Resolver<Array<GQLResolversTypes['HovercardContext']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLHovercardContextResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['HovercardContext'] = GQLResolversParentTypes['HovercardContext']> = {
  __resolveType: TypeResolveFn<'GenericHovercardContext' | 'OrganizationTeamsHovercardContext' | 'OrganizationsHovercardContext' | 'ReviewStatusHovercardContext' | 'ViewerHovercardContext', ParentType, ContextType>;
  message?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  octicon?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
};

export type GQLImportProjectPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ImportProjectPayload'] = GQLResolversParentTypes['ImportProjectPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<GQLResolversTypes['Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLInviteEnterpriseAdminPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['InviteEnterpriseAdminPayload'] = GQLResolversParentTypes['InviteEnterpriseAdminPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  invitation?: Resolver<Maybe<GQLResolversTypes['EnterpriseAdministratorInvitation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLIpAllowListEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['IpAllowListEntry'] = GQLResolversParentTypes['IpAllowListEntry']> = {
  allowListValue?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isActive?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<GQLResolversTypes['IpAllowListOwner'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLIpAllowListEntryConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['IpAllowListEntryConnection'] = GQLResolversParentTypes['IpAllowListEntryConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['IpAllowListEntryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['IpAllowListEntry']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLIpAllowListEntryEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['IpAllowListEntryEdge'] = GQLResolversParentTypes['IpAllowListEntryEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['IpAllowListEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLIpAllowListOwnerResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['IpAllowListOwner'] = GQLResolversParentTypes['IpAllowListOwner']> = {
  __resolveType: TypeResolveFn<'Enterprise' | 'Organization', ParentType, ContextType>;
};

export type GQLIssueResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Issue'] = GQLResolversParentTypes['Issue']> = {
  activeLockReason?: Resolver<Maybe<GQLResolversTypes['LockReason']>, ParentType, ContextType>;
  assignees?: Resolver<GQLResolversTypes['UserConnection'], ParentType, ContextType, RequireFields<GQLIssueAssigneesArgs, never>>;
  author?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<GQLResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType>;
  bodyText?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  closed?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  comments?: Resolver<GQLResolversTypes['IssueCommentConnection'], ParentType, ContextType, RequireFields<GQLIssueCommentsArgs, never>>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  hovercard?: Resolver<GQLResolversTypes['Hovercard'], ParentType, ContextType, RequireFields<GQLIssueHovercardArgs, 'includeNotificationContexts'>>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  labels?: Resolver<Maybe<GQLResolversTypes['LabelConnection']>, ParentType, ContextType, RequireFields<GQLIssueLabelsArgs, 'orderBy'>>;
  lastEditedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  locked?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  milestone?: Resolver<Maybe<GQLResolversTypes['Milestone']>, ParentType, ContextType>;
  number?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  participants?: Resolver<GQLResolversTypes['UserConnection'], ParentType, ContextType, RequireFields<GQLIssueParticipantsArgs, never>>;
  projectCards?: Resolver<GQLResolversTypes['ProjectCardConnection'], ParentType, ContextType, RequireFields<GQLIssueProjectCardsArgs, 'archivedStates'>>;
  publishedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<GQLResolversTypes['ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<GQLResolversTypes['ReactionConnection'], ParentType, ContextType, RequireFields<GQLIssueReactionsArgs, never>>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  state?: Resolver<GQLResolversTypes['IssueState'], ParentType, ContextType>;
  timeline?: Resolver<GQLResolversTypes['IssueTimelineConnection'], ParentType, ContextType, RequireFields<GQLIssueTimelineArgs, never>>;
  timelineItems?: Resolver<GQLResolversTypes['IssueTimelineItemsConnection'], ParentType, ContextType, RequireFields<GQLIssueTimelineItemsArgs, never>>;
  title?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<GQLResolversTypes['UserContentEditConnection']>, ParentType, ContextType, RequireFields<GQLIssueUserContentEditsArgs, never>>;
  viewerCanReact?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<GQLResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<GQLResolversTypes['SubscriptionState']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLIssueCommentResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['IssueComment'] = GQLResolversParentTypes['IssueComment']> = {
  author?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<GQLResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType>;
  bodyText?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isMinimized?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  issue?: Resolver<GQLResolversTypes['Issue'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<GQLResolversTypes['PullRequest']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<GQLResolversTypes['ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<GQLResolversTypes['ReactionConnection'], ParentType, ContextType, RequireFields<GQLIssueCommentReactionsArgs, never>>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<GQLResolversTypes['UserContentEditConnection']>, ParentType, ContextType, RequireFields<GQLIssueCommentUserContentEditsArgs, never>>;
  viewerCanDelete?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMinimize?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<GQLResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLIssueCommentConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['IssueCommentConnection'] = GQLResolversParentTypes['IssueCommentConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['IssueCommentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['IssueComment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLIssueCommentEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['IssueCommentEdge'] = GQLResolversParentTypes['IssueCommentEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['IssueComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLIssueConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['IssueConnection'] = GQLResolversParentTypes['IssueConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['IssueEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['Issue']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLIssueContributionsByRepositoryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['IssueContributionsByRepository'] = GQLResolversParentTypes['IssueContributionsByRepository']> = {
  contributions?: Resolver<GQLResolversTypes['CreatedIssueContributionConnection'], ParentType, ContextType, RequireFields<GQLIssueContributionsByRepositoryContributionsArgs, 'orderBy'>>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLIssueEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['IssueEdge'] = GQLResolversParentTypes['IssueEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLIssueOrPullRequestResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['IssueOrPullRequest'] = GQLResolversParentTypes['IssueOrPullRequest']> = {
  __resolveType: TypeResolveFn<'Issue' | 'PullRequest', ParentType, ContextType>;
};

export type GQLIssueTimelineConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['IssueTimelineConnection'] = GQLResolversParentTypes['IssueTimelineConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['IssueTimelineItemEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['IssueTimelineItem']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLIssueTimelineItemResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['IssueTimelineItem'] = GQLResolversParentTypes['IssueTimelineItem']> = {
  __resolveType: TypeResolveFn<'AssignedEvent' | 'ClosedEvent' | 'Commit' | 'CrossReferencedEvent' | 'DemilestonedEvent' | 'IssueComment' | 'LabeledEvent' | 'LockedEvent' | 'MilestonedEvent' | 'ReferencedEvent' | 'RenamedTitleEvent' | 'ReopenedEvent' | 'SubscribedEvent' | 'TransferredEvent' | 'UnassignedEvent' | 'UnlabeledEvent' | 'UnlockedEvent' | 'UnsubscribedEvent' | 'UserBlockedEvent', ParentType, ContextType>;
};

export type GQLIssueTimelineItemEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['IssueTimelineItemEdge'] = GQLResolversParentTypes['IssueTimelineItemEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['IssueTimelineItem']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLIssueTimelineItemsResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['IssueTimelineItems'] = GQLResolversParentTypes['IssueTimelineItems']> = {
  __resolveType: TypeResolveFn<'AddedToProjectEvent' | 'AssignedEvent' | 'ClosedEvent' | 'CommentDeletedEvent' | 'ConnectedEvent' | 'ConvertedNoteToIssueEvent' | 'CrossReferencedEvent' | 'DemilestonedEvent' | 'DisconnectedEvent' | 'IssueComment' | 'LabeledEvent' | 'LockedEvent' | 'MarkedAsDuplicateEvent' | 'MentionedEvent' | 'MilestonedEvent' | 'MovedColumnsInProjectEvent' | 'PinnedEvent' | 'ReferencedEvent' | 'RemovedFromProjectEvent' | 'RenamedTitleEvent' | 'ReopenedEvent' | 'SubscribedEvent' | 'TransferredEvent' | 'UnassignedEvent' | 'UnlabeledEvent' | 'UnlockedEvent' | 'UnmarkedAsDuplicateEvent' | 'UnpinnedEvent' | 'UnsubscribedEvent' | 'UserBlockedEvent', ParentType, ContextType>;
};

export type GQLIssueTimelineItemsConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['IssueTimelineItemsConnection'] = GQLResolversParentTypes['IssueTimelineItemsConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['IssueTimelineItemsEdge']>>>, ParentType, ContextType>;
  filteredCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['IssueTimelineItems']>>>, ParentType, ContextType>;
  pageCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLIssueTimelineItemsEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['IssueTimelineItemsEdge'] = GQLResolversParentTypes['IssueTimelineItemsEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['IssueTimelineItems']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLJoinedGitHubContributionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['JoinedGitHubContribution'] = GQLResolversParentTypes['JoinedGitHubContribution']> = {
  isRestricted?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  user?: Resolver<GQLResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLLabelResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Label'] = GQLResolversParentTypes['Label']> = {
  color?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  description?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isDefault?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  issues?: Resolver<GQLResolversTypes['IssueConnection'], ParentType, ContextType, RequireFields<GQLLabelIssuesArgs, never>>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  pullRequests?: Resolver<GQLResolversTypes['PullRequestConnection'], ParentType, ContextType, RequireFields<GQLLabelPullRequestsArgs, never>>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLLabelConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['LabelConnection'] = GQLResolversParentTypes['LabelConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['LabelEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['Label']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLLabelEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['LabelEdge'] = GQLResolversParentTypes['LabelEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['Label']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLLabelableResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Labelable'] = GQLResolversParentTypes['Labelable']> = {
  __resolveType: TypeResolveFn<'Issue' | 'PullRequest', ParentType, ContextType>;
  labels?: Resolver<Maybe<GQLResolversTypes['LabelConnection']>, ParentType, ContextType, RequireFields<GQLLabelableLabelsArgs, 'orderBy'>>;
};

export type GQLLabeledEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['LabeledEvent'] = GQLResolversParentTypes['LabeledEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  label?: Resolver<GQLResolversTypes['Label'], ParentType, ContextType>;
  labelable?: Resolver<GQLResolversTypes['Labelable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLLanguageResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Language'] = GQLResolversParentTypes['Language']> = {
  color?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLLanguageConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['LanguageConnection'] = GQLResolversParentTypes['LanguageConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['LanguageEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['Language']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  totalSize?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLLanguageEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['LanguageEdge'] = GQLResolversParentTypes['LanguageEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<GQLResolversTypes['Language'], ParentType, ContextType>;
  size?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLLicenseResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['License'] = GQLResolversParentTypes['License']> = {
  body?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  conditions?: Resolver<Array<Maybe<GQLResolversTypes['LicenseRule']>>, ParentType, ContextType>;
  description?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  featured?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  hidden?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  implementation?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  key?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  limitations?: Resolver<Array<Maybe<GQLResolversTypes['LicenseRule']>>, ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  nickname?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  permissions?: Resolver<Array<Maybe<GQLResolversTypes['LicenseRule']>>, ParentType, ContextType>;
  pseudoLicense?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  spdxId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  url?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLLicenseRuleResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['LicenseRule'] = GQLResolversParentTypes['LicenseRule']> = {
  description?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  key?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  label?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLLinkRepositoryToProjectPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['LinkRepositoryToProjectPayload'] = GQLResolversParentTypes['LinkRepositoryToProjectPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<GQLResolversTypes['Project']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLLockLockablePayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['LockLockablePayload'] = GQLResolversParentTypes['LockLockablePayload']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  lockedRecord?: Resolver<Maybe<GQLResolversTypes['Lockable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLLockableResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Lockable'] = GQLResolversParentTypes['Lockable']> = {
  __resolveType: TypeResolveFn<'Issue' | 'PullRequest', ParentType, ContextType>;
  activeLockReason?: Resolver<Maybe<GQLResolversTypes['LockReason']>, ParentType, ContextType>;
  locked?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
};

export type GQLLockedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['LockedEvent'] = GQLResolversParentTypes['LockedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  lockReason?: Resolver<Maybe<GQLResolversTypes['LockReason']>, ParentType, ContextType>;
  lockable?: Resolver<GQLResolversTypes['Lockable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLMannequinResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Mannequin'] = GQLResolversParentTypes['Mannequin']> = {
  avatarUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType, RequireFields<GQLMannequinAvatarUrlArgs, never>>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  email?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  login?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLMarkPullRequestReadyForReviewPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['MarkPullRequestReadyForReviewPayload'] = GQLResolversParentTypes['MarkPullRequestReadyForReviewPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<GQLResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLMarkedAsDuplicateEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['MarkedAsDuplicateEvent'] = GQLResolversParentTypes['MarkedAsDuplicateEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLMarketplaceCategoryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['MarketplaceCategory'] = GQLResolversParentTypes['MarketplaceCategory']> = {
  description?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  howItWorks?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  primaryListingCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  secondaryListingCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  slug?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLMarketplaceListingResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['MarketplaceListing'] = GQLResolversParentTypes['MarketplaceListing']> = {
  app?: Resolver<Maybe<GQLResolversTypes['App']>, ParentType, ContextType>;
  companyUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  configurationResourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  configurationUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  documentationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  extendedDescription?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  extendedDescriptionHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType>;
  fullDescription?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  fullDescriptionHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType>;
  hasPublishedFreeTrialPlans?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  hasTermsOfService?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  howItWorks?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  howItWorksHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  installationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  installedForViewer?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isArchived?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isDraft?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isPaid?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isPublic?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isRejected?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isUnverified?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isUnverifiedPending?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isVerificationPendingFromDraft?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isVerificationPendingFromUnverified?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isVerified?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  logoBackgroundColor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  logoUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType, RequireFields<GQLMarketplaceListingLogoUrlArgs, 'size'>>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  normalizedShortDescription?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  pricingUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  primaryCategory?: Resolver<GQLResolversTypes['MarketplaceCategory'], ParentType, ContextType>;
  privacyPolicyUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  screenshotUrls?: Resolver<Array<Maybe<GQLResolversTypes['String']>>, ParentType, ContextType>;
  secondaryCategory?: Resolver<Maybe<GQLResolversTypes['MarketplaceCategory']>, ParentType, ContextType>;
  shortDescription?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  statusUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  supportEmail?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  supportUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  termsOfServiceUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  viewerCanAddPlans?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanApprove?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanDelist?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanEdit?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanEditCategories?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanEditPlans?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanRedraft?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReject?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanRequestApproval?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerHasPurchased?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerHasPurchasedForAllOrganizations?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerIsListingAdmin?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLMarketplaceListingConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['MarketplaceListingConnection'] = GQLResolversParentTypes['MarketplaceListingConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['MarketplaceListingEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['MarketplaceListing']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLMarketplaceListingEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['MarketplaceListingEdge'] = GQLResolversParentTypes['MarketplaceListingEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['MarketplaceListing']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLMemberStatusableResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['MemberStatusable'] = GQLResolversParentTypes['MemberStatusable']> = {
  __resolveType: TypeResolveFn<'Organization' | 'Team', ParentType, ContextType>;
  memberStatuses?: Resolver<GQLResolversTypes['UserStatusConnection'], ParentType, ContextType, RequireFields<GQLMemberStatusableMemberStatusesArgs, 'orderBy'>>;
};

export type GQLMembersCanDeleteReposClearAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['MembersCanDeleteReposClearAuditEntry'] = GQLResolversParentTypes['MembersCanDeleteReposClearAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLMembersCanDeleteReposDisableAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['MembersCanDeleteReposDisableAuditEntry'] = GQLResolversParentTypes['MembersCanDeleteReposDisableAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLMembersCanDeleteReposEnableAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['MembersCanDeleteReposEnableAuditEntry'] = GQLResolversParentTypes['MembersCanDeleteReposEnableAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLMentionedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['MentionedEvent'] = GQLResolversParentTypes['MentionedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLMergeBranchPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['MergeBranchPayload'] = GQLResolversParentTypes['MergeBranchPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  mergeCommit?: Resolver<Maybe<GQLResolversTypes['Commit']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLMergePullRequestPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['MergePullRequestPayload'] = GQLResolversParentTypes['MergePullRequestPayload']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<GQLResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLMergedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['MergedEvent'] = GQLResolversParentTypes['MergedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  commit?: Resolver<Maybe<GQLResolversTypes['Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  mergeRef?: Resolver<Maybe<GQLResolversTypes['Ref']>, ParentType, ContextType>;
  mergeRefName?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  pullRequest?: Resolver<GQLResolversTypes['PullRequest'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLMilestoneResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Milestone'] = GQLResolversParentTypes['Milestone']> = {
  closed?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  description?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  dueOn?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  issuePrioritiesDebug?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  issues?: Resolver<GQLResolversTypes['IssueConnection'], ParentType, ContextType, RequireFields<GQLMilestoneIssuesArgs, never>>;
  number?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  pullRequests?: Resolver<GQLResolversTypes['PullRequestConnection'], ParentType, ContextType, RequireFields<GQLMilestonePullRequestsArgs, never>>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  state?: Resolver<GQLResolversTypes['MilestoneState'], ParentType, ContextType>;
  title?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLMilestoneConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['MilestoneConnection'] = GQLResolversParentTypes['MilestoneConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['MilestoneEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['Milestone']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLMilestoneEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['MilestoneEdge'] = GQLResolversParentTypes['MilestoneEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['Milestone']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLMilestoneItemResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['MilestoneItem'] = GQLResolversParentTypes['MilestoneItem']> = {
  __resolveType: TypeResolveFn<'Issue' | 'PullRequest', ParentType, ContextType>;
};

export type GQLMilestonedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['MilestonedEvent'] = GQLResolversParentTypes['MilestonedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  milestoneTitle?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  subject?: Resolver<GQLResolversTypes['MilestoneItem'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLMinimizableResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Minimizable'] = GQLResolversParentTypes['Minimizable']> = {
  __resolveType: TypeResolveFn<'CommitComment' | 'GistComment' | 'IssueComment' | 'PullRequestReviewComment', ParentType, ContextType>;
  isMinimized?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  viewerCanMinimize?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
};

export type GQLMinimizeCommentPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['MinimizeCommentPayload'] = GQLResolversParentTypes['MinimizeCommentPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  minimizedComment?: Resolver<Maybe<GQLResolversTypes['Minimizable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLMoveProjectCardPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['MoveProjectCardPayload'] = GQLResolversParentTypes['MoveProjectCardPayload']> = {
  cardEdge?: Resolver<Maybe<GQLResolversTypes['ProjectCardEdge']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLMoveProjectColumnPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['MoveProjectColumnPayload'] = GQLResolversParentTypes['MoveProjectColumnPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  columnEdge?: Resolver<Maybe<GQLResolversTypes['ProjectColumnEdge']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLMovedColumnsInProjectEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['MovedColumnsInProjectEvent'] = GQLResolversParentTypes['MovedColumnsInProjectEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  previousProjectColumnName?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  project?: Resolver<Maybe<GQLResolversTypes['Project']>, ParentType, ContextType>;
  projectCard?: Resolver<Maybe<GQLResolversTypes['ProjectCard']>, ParentType, ContextType>;
  projectColumnName?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLMutationResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Mutation'] = GQLResolversParentTypes['Mutation']> = {
  acceptEnterpriseAdministratorInvitation?: Resolver<Maybe<GQLResolversTypes['AcceptEnterpriseAdministratorInvitationPayload']>, ParentType, ContextType, RequireFields<GQLMutationAcceptEnterpriseAdministratorInvitationArgs, 'input'>>;
  acceptTopicSuggestion?: Resolver<Maybe<GQLResolversTypes['AcceptTopicSuggestionPayload']>, ParentType, ContextType, RequireFields<GQLMutationAcceptTopicSuggestionArgs, 'input'>>;
  addAssigneesToAssignable?: Resolver<Maybe<GQLResolversTypes['AddAssigneesToAssignablePayload']>, ParentType, ContextType, RequireFields<GQLMutationAddAssigneesToAssignableArgs, 'input'>>;
  addComment?: Resolver<Maybe<GQLResolversTypes['AddCommentPayload']>, ParentType, ContextType, RequireFields<GQLMutationAddCommentArgs, 'input'>>;
  addLabelsToLabelable?: Resolver<Maybe<GQLResolversTypes['AddLabelsToLabelablePayload']>, ParentType, ContextType, RequireFields<GQLMutationAddLabelsToLabelableArgs, 'input'>>;
  addProjectCard?: Resolver<Maybe<GQLResolversTypes['AddProjectCardPayload']>, ParentType, ContextType, RequireFields<GQLMutationAddProjectCardArgs, 'input'>>;
  addProjectColumn?: Resolver<Maybe<GQLResolversTypes['AddProjectColumnPayload']>, ParentType, ContextType, RequireFields<GQLMutationAddProjectColumnArgs, 'input'>>;
  addPullRequestReview?: Resolver<Maybe<GQLResolversTypes['AddPullRequestReviewPayload']>, ParentType, ContextType, RequireFields<GQLMutationAddPullRequestReviewArgs, 'input'>>;
  addPullRequestReviewComment?: Resolver<Maybe<GQLResolversTypes['AddPullRequestReviewCommentPayload']>, ParentType, ContextType, RequireFields<GQLMutationAddPullRequestReviewCommentArgs, 'input'>>;
  addPullRequestReviewThread?: Resolver<Maybe<GQLResolversTypes['AddPullRequestReviewThreadPayload']>, ParentType, ContextType, RequireFields<GQLMutationAddPullRequestReviewThreadArgs, 'input'>>;
  addReaction?: Resolver<Maybe<GQLResolversTypes['AddReactionPayload']>, ParentType, ContextType, RequireFields<GQLMutationAddReactionArgs, 'input'>>;
  addStar?: Resolver<Maybe<GQLResolversTypes['AddStarPayload']>, ParentType, ContextType, RequireFields<GQLMutationAddStarArgs, 'input'>>;
  archiveRepository?: Resolver<Maybe<GQLResolversTypes['ArchiveRepositoryPayload']>, ParentType, ContextType, RequireFields<GQLMutationArchiveRepositoryArgs, 'input'>>;
  cancelEnterpriseAdminInvitation?: Resolver<Maybe<GQLResolversTypes['CancelEnterpriseAdminInvitationPayload']>, ParentType, ContextType, RequireFields<GQLMutationCancelEnterpriseAdminInvitationArgs, 'input'>>;
  changeUserStatus?: Resolver<Maybe<GQLResolversTypes['ChangeUserStatusPayload']>, ParentType, ContextType, RequireFields<GQLMutationChangeUserStatusArgs, 'input'>>;
  clearLabelsFromLabelable?: Resolver<Maybe<GQLResolversTypes['ClearLabelsFromLabelablePayload']>, ParentType, ContextType, RequireFields<GQLMutationClearLabelsFromLabelableArgs, 'input'>>;
  cloneProject?: Resolver<Maybe<GQLResolversTypes['CloneProjectPayload']>, ParentType, ContextType, RequireFields<GQLMutationCloneProjectArgs, 'input'>>;
  cloneTemplateRepository?: Resolver<Maybe<GQLResolversTypes['CloneTemplateRepositoryPayload']>, ParentType, ContextType, RequireFields<GQLMutationCloneTemplateRepositoryArgs, 'input'>>;
  closeIssue?: Resolver<Maybe<GQLResolversTypes['CloseIssuePayload']>, ParentType, ContextType, RequireFields<GQLMutationCloseIssueArgs, 'input'>>;
  closePullRequest?: Resolver<Maybe<GQLResolversTypes['ClosePullRequestPayload']>, ParentType, ContextType, RequireFields<GQLMutationClosePullRequestArgs, 'input'>>;
  convertProjectCardNoteToIssue?: Resolver<Maybe<GQLResolversTypes['ConvertProjectCardNoteToIssuePayload']>, ParentType, ContextType, RequireFields<GQLMutationConvertProjectCardNoteToIssueArgs, 'input'>>;
  createBranchProtectionRule?: Resolver<Maybe<GQLResolversTypes['CreateBranchProtectionRulePayload']>, ParentType, ContextType, RequireFields<GQLMutationCreateBranchProtectionRuleArgs, 'input'>>;
  createCheckRun?: Resolver<Maybe<GQLResolversTypes['CreateCheckRunPayload']>, ParentType, ContextType, RequireFields<GQLMutationCreateCheckRunArgs, 'input'>>;
  createCheckSuite?: Resolver<Maybe<GQLResolversTypes['CreateCheckSuitePayload']>, ParentType, ContextType, RequireFields<GQLMutationCreateCheckSuiteArgs, 'input'>>;
  createContentAttachment?: Resolver<Maybe<GQLResolversTypes['CreateContentAttachmentPayload']>, ParentType, ContextType, RequireFields<GQLMutationCreateContentAttachmentArgs, 'input'>>;
  createDeployment?: Resolver<Maybe<GQLResolversTypes['CreateDeploymentPayload']>, ParentType, ContextType, RequireFields<GQLMutationCreateDeploymentArgs, 'input'>>;
  createDeploymentStatus?: Resolver<Maybe<GQLResolversTypes['CreateDeploymentStatusPayload']>, ParentType, ContextType, RequireFields<GQLMutationCreateDeploymentStatusArgs, 'input'>>;
  createEnterpriseOrganization?: Resolver<Maybe<GQLResolversTypes['CreateEnterpriseOrganizationPayload']>, ParentType, ContextType, RequireFields<GQLMutationCreateEnterpriseOrganizationArgs, 'input'>>;
  createIpAllowListEntry?: Resolver<Maybe<GQLResolversTypes['CreateIpAllowListEntryPayload']>, ParentType, ContextType, RequireFields<GQLMutationCreateIpAllowListEntryArgs, 'input'>>;
  createIssue?: Resolver<Maybe<GQLResolversTypes['CreateIssuePayload']>, ParentType, ContextType, RequireFields<GQLMutationCreateIssueArgs, 'input'>>;
  createLabel?: Resolver<Maybe<GQLResolversTypes['CreateLabelPayload']>, ParentType, ContextType, RequireFields<GQLMutationCreateLabelArgs, 'input'>>;
  createProject?: Resolver<Maybe<GQLResolversTypes['CreateProjectPayload']>, ParentType, ContextType, RequireFields<GQLMutationCreateProjectArgs, 'input'>>;
  createPullRequest?: Resolver<Maybe<GQLResolversTypes['CreatePullRequestPayload']>, ParentType, ContextType, RequireFields<GQLMutationCreatePullRequestArgs, 'input'>>;
  createRef?: Resolver<Maybe<GQLResolversTypes['CreateRefPayload']>, ParentType, ContextType, RequireFields<GQLMutationCreateRefArgs, 'input'>>;
  createRepository?: Resolver<Maybe<GQLResolversTypes['CreateRepositoryPayload']>, ParentType, ContextType, RequireFields<GQLMutationCreateRepositoryArgs, 'input'>>;
  createTeamDiscussion?: Resolver<Maybe<GQLResolversTypes['CreateTeamDiscussionPayload']>, ParentType, ContextType, RequireFields<GQLMutationCreateTeamDiscussionArgs, 'input'>>;
  createTeamDiscussionComment?: Resolver<Maybe<GQLResolversTypes['CreateTeamDiscussionCommentPayload']>, ParentType, ContextType, RequireFields<GQLMutationCreateTeamDiscussionCommentArgs, 'input'>>;
  declineTopicSuggestion?: Resolver<Maybe<GQLResolversTypes['DeclineTopicSuggestionPayload']>, ParentType, ContextType, RequireFields<GQLMutationDeclineTopicSuggestionArgs, 'input'>>;
  deleteBranchProtectionRule?: Resolver<Maybe<GQLResolversTypes['DeleteBranchProtectionRulePayload']>, ParentType, ContextType, RequireFields<GQLMutationDeleteBranchProtectionRuleArgs, 'input'>>;
  deleteDeployment?: Resolver<Maybe<GQLResolversTypes['DeleteDeploymentPayload']>, ParentType, ContextType, RequireFields<GQLMutationDeleteDeploymentArgs, 'input'>>;
  deleteIpAllowListEntry?: Resolver<Maybe<GQLResolversTypes['DeleteIpAllowListEntryPayload']>, ParentType, ContextType, RequireFields<GQLMutationDeleteIpAllowListEntryArgs, 'input'>>;
  deleteIssue?: Resolver<Maybe<GQLResolversTypes['DeleteIssuePayload']>, ParentType, ContextType, RequireFields<GQLMutationDeleteIssueArgs, 'input'>>;
  deleteIssueComment?: Resolver<Maybe<GQLResolversTypes['DeleteIssueCommentPayload']>, ParentType, ContextType, RequireFields<GQLMutationDeleteIssueCommentArgs, 'input'>>;
  deleteLabel?: Resolver<Maybe<GQLResolversTypes['DeleteLabelPayload']>, ParentType, ContextType, RequireFields<GQLMutationDeleteLabelArgs, 'input'>>;
  deletePackageVersion?: Resolver<Maybe<GQLResolversTypes['DeletePackageVersionPayload']>, ParentType, ContextType, RequireFields<GQLMutationDeletePackageVersionArgs, 'input'>>;
  deleteProject?: Resolver<Maybe<GQLResolversTypes['DeleteProjectPayload']>, ParentType, ContextType, RequireFields<GQLMutationDeleteProjectArgs, 'input'>>;
  deleteProjectCard?: Resolver<Maybe<GQLResolversTypes['DeleteProjectCardPayload']>, ParentType, ContextType, RequireFields<GQLMutationDeleteProjectCardArgs, 'input'>>;
  deleteProjectColumn?: Resolver<Maybe<GQLResolversTypes['DeleteProjectColumnPayload']>, ParentType, ContextType, RequireFields<GQLMutationDeleteProjectColumnArgs, 'input'>>;
  deletePullRequestReview?: Resolver<Maybe<GQLResolversTypes['DeletePullRequestReviewPayload']>, ParentType, ContextType, RequireFields<GQLMutationDeletePullRequestReviewArgs, 'input'>>;
  deletePullRequestReviewComment?: Resolver<Maybe<GQLResolversTypes['DeletePullRequestReviewCommentPayload']>, ParentType, ContextType, RequireFields<GQLMutationDeletePullRequestReviewCommentArgs, 'input'>>;
  deleteRef?: Resolver<Maybe<GQLResolversTypes['DeleteRefPayload']>, ParentType, ContextType, RequireFields<GQLMutationDeleteRefArgs, 'input'>>;
  deleteTeamDiscussion?: Resolver<Maybe<GQLResolversTypes['DeleteTeamDiscussionPayload']>, ParentType, ContextType, RequireFields<GQLMutationDeleteTeamDiscussionArgs, 'input'>>;
  deleteTeamDiscussionComment?: Resolver<Maybe<GQLResolversTypes['DeleteTeamDiscussionCommentPayload']>, ParentType, ContextType, RequireFields<GQLMutationDeleteTeamDiscussionCommentArgs, 'input'>>;
  dismissPullRequestReview?: Resolver<Maybe<GQLResolversTypes['DismissPullRequestReviewPayload']>, ParentType, ContextType, RequireFields<GQLMutationDismissPullRequestReviewArgs, 'input'>>;
  followUser?: Resolver<Maybe<GQLResolversTypes['FollowUserPayload']>, ParentType, ContextType, RequireFields<GQLMutationFollowUserArgs, 'input'>>;
  importProject?: Resolver<Maybe<GQLResolversTypes['ImportProjectPayload']>, ParentType, ContextType, RequireFields<GQLMutationImportProjectArgs, 'input'>>;
  inviteEnterpriseAdmin?: Resolver<Maybe<GQLResolversTypes['InviteEnterpriseAdminPayload']>, ParentType, ContextType, RequireFields<GQLMutationInviteEnterpriseAdminArgs, 'input'>>;
  linkRepositoryToProject?: Resolver<Maybe<GQLResolversTypes['LinkRepositoryToProjectPayload']>, ParentType, ContextType, RequireFields<GQLMutationLinkRepositoryToProjectArgs, 'input'>>;
  lockLockable?: Resolver<Maybe<GQLResolversTypes['LockLockablePayload']>, ParentType, ContextType, RequireFields<GQLMutationLockLockableArgs, 'input'>>;
  markPullRequestReadyForReview?: Resolver<Maybe<GQLResolversTypes['MarkPullRequestReadyForReviewPayload']>, ParentType, ContextType, RequireFields<GQLMutationMarkPullRequestReadyForReviewArgs, 'input'>>;
  mergeBranch?: Resolver<Maybe<GQLResolversTypes['MergeBranchPayload']>, ParentType, ContextType, RequireFields<GQLMutationMergeBranchArgs, 'input'>>;
  mergePullRequest?: Resolver<Maybe<GQLResolversTypes['MergePullRequestPayload']>, ParentType, ContextType, RequireFields<GQLMutationMergePullRequestArgs, 'input'>>;
  minimizeComment?: Resolver<Maybe<GQLResolversTypes['MinimizeCommentPayload']>, ParentType, ContextType, RequireFields<GQLMutationMinimizeCommentArgs, 'input'>>;
  moveProjectCard?: Resolver<Maybe<GQLResolversTypes['MoveProjectCardPayload']>, ParentType, ContextType, RequireFields<GQLMutationMoveProjectCardArgs, 'input'>>;
  moveProjectColumn?: Resolver<Maybe<GQLResolversTypes['MoveProjectColumnPayload']>, ParentType, ContextType, RequireFields<GQLMutationMoveProjectColumnArgs, 'input'>>;
  pinIssue?: Resolver<Maybe<GQLResolversTypes['PinIssuePayload']>, ParentType, ContextType, RequireFields<GQLMutationPinIssueArgs, 'input'>>;
  regenerateEnterpriseIdentityProviderRecoveryCodes?: Resolver<Maybe<GQLResolversTypes['RegenerateEnterpriseIdentityProviderRecoveryCodesPayload']>, ParentType, ContextType, RequireFields<GQLMutationRegenerateEnterpriseIdentityProviderRecoveryCodesArgs, 'input'>>;
  removeAssigneesFromAssignable?: Resolver<Maybe<GQLResolversTypes['RemoveAssigneesFromAssignablePayload']>, ParentType, ContextType, RequireFields<GQLMutationRemoveAssigneesFromAssignableArgs, 'input'>>;
  removeEnterpriseAdmin?: Resolver<Maybe<GQLResolversTypes['RemoveEnterpriseAdminPayload']>, ParentType, ContextType, RequireFields<GQLMutationRemoveEnterpriseAdminArgs, 'input'>>;
  removeEnterpriseIdentityProvider?: Resolver<Maybe<GQLResolversTypes['RemoveEnterpriseIdentityProviderPayload']>, ParentType, ContextType, RequireFields<GQLMutationRemoveEnterpriseIdentityProviderArgs, 'input'>>;
  removeEnterpriseOrganization?: Resolver<Maybe<GQLResolversTypes['RemoveEnterpriseOrganizationPayload']>, ParentType, ContextType, RequireFields<GQLMutationRemoveEnterpriseOrganizationArgs, 'input'>>;
  removeLabelsFromLabelable?: Resolver<Maybe<GQLResolversTypes['RemoveLabelsFromLabelablePayload']>, ParentType, ContextType, RequireFields<GQLMutationRemoveLabelsFromLabelableArgs, 'input'>>;
  removeOutsideCollaborator?: Resolver<Maybe<GQLResolversTypes['RemoveOutsideCollaboratorPayload']>, ParentType, ContextType, RequireFields<GQLMutationRemoveOutsideCollaboratorArgs, 'input'>>;
  removeReaction?: Resolver<Maybe<GQLResolversTypes['RemoveReactionPayload']>, ParentType, ContextType, RequireFields<GQLMutationRemoveReactionArgs, 'input'>>;
  removeStar?: Resolver<Maybe<GQLResolversTypes['RemoveStarPayload']>, ParentType, ContextType, RequireFields<GQLMutationRemoveStarArgs, 'input'>>;
  reopenIssue?: Resolver<Maybe<GQLResolversTypes['ReopenIssuePayload']>, ParentType, ContextType, RequireFields<GQLMutationReopenIssueArgs, 'input'>>;
  reopenPullRequest?: Resolver<Maybe<GQLResolversTypes['ReopenPullRequestPayload']>, ParentType, ContextType, RequireFields<GQLMutationReopenPullRequestArgs, 'input'>>;
  requestReviews?: Resolver<Maybe<GQLResolversTypes['RequestReviewsPayload']>, ParentType, ContextType, RequireFields<GQLMutationRequestReviewsArgs, 'input'>>;
  rerequestCheckSuite?: Resolver<Maybe<GQLResolversTypes['RerequestCheckSuitePayload']>, ParentType, ContextType, RequireFields<GQLMutationRerequestCheckSuiteArgs, 'input'>>;
  resolveReviewThread?: Resolver<Maybe<GQLResolversTypes['ResolveReviewThreadPayload']>, ParentType, ContextType, RequireFields<GQLMutationResolveReviewThreadArgs, 'input'>>;
  setEnterpriseIdentityProvider?: Resolver<Maybe<GQLResolversTypes['SetEnterpriseIdentityProviderPayload']>, ParentType, ContextType, RequireFields<GQLMutationSetEnterpriseIdentityProviderArgs, 'input'>>;
  submitPullRequestReview?: Resolver<Maybe<GQLResolversTypes['SubmitPullRequestReviewPayload']>, ParentType, ContextType, RequireFields<GQLMutationSubmitPullRequestReviewArgs, 'input'>>;
  transferIssue?: Resolver<Maybe<GQLResolversTypes['TransferIssuePayload']>, ParentType, ContextType, RequireFields<GQLMutationTransferIssueArgs, 'input'>>;
  unarchiveRepository?: Resolver<Maybe<GQLResolversTypes['UnarchiveRepositoryPayload']>, ParentType, ContextType, RequireFields<GQLMutationUnarchiveRepositoryArgs, 'input'>>;
  unfollowUser?: Resolver<Maybe<GQLResolversTypes['UnfollowUserPayload']>, ParentType, ContextType, RequireFields<GQLMutationUnfollowUserArgs, 'input'>>;
  unlinkRepositoryFromProject?: Resolver<Maybe<GQLResolversTypes['UnlinkRepositoryFromProjectPayload']>, ParentType, ContextType, RequireFields<GQLMutationUnlinkRepositoryFromProjectArgs, 'input'>>;
  unlockLockable?: Resolver<Maybe<GQLResolversTypes['UnlockLockablePayload']>, ParentType, ContextType, RequireFields<GQLMutationUnlockLockableArgs, 'input'>>;
  unmarkIssueAsDuplicate?: Resolver<Maybe<GQLResolversTypes['UnmarkIssueAsDuplicatePayload']>, ParentType, ContextType, RequireFields<GQLMutationUnmarkIssueAsDuplicateArgs, 'input'>>;
  unminimizeComment?: Resolver<Maybe<GQLResolversTypes['UnminimizeCommentPayload']>, ParentType, ContextType, RequireFields<GQLMutationUnminimizeCommentArgs, 'input'>>;
  unpinIssue?: Resolver<Maybe<GQLResolversTypes['UnpinIssuePayload']>, ParentType, ContextType, RequireFields<GQLMutationUnpinIssueArgs, 'input'>>;
  unresolveReviewThread?: Resolver<Maybe<GQLResolversTypes['UnresolveReviewThreadPayload']>, ParentType, ContextType, RequireFields<GQLMutationUnresolveReviewThreadArgs, 'input'>>;
  updateBranchProtectionRule?: Resolver<Maybe<GQLResolversTypes['UpdateBranchProtectionRulePayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateBranchProtectionRuleArgs, 'input'>>;
  updateCheckRun?: Resolver<Maybe<GQLResolversTypes['UpdateCheckRunPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateCheckRunArgs, 'input'>>;
  updateCheckSuitePreferences?: Resolver<Maybe<GQLResolversTypes['UpdateCheckSuitePreferencesPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateCheckSuitePreferencesArgs, 'input'>>;
  updateEnterpriseActionExecutionCapabilitySetting?: Resolver<Maybe<GQLResolversTypes['UpdateEnterpriseActionExecutionCapabilitySettingPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateEnterpriseActionExecutionCapabilitySettingArgs, 'input'>>;
  updateEnterpriseAdministratorRole?: Resolver<Maybe<GQLResolversTypes['UpdateEnterpriseAdministratorRolePayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateEnterpriseAdministratorRoleArgs, 'input'>>;
  updateEnterpriseAllowPrivateRepositoryForkingSetting?: Resolver<Maybe<GQLResolversTypes['UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateEnterpriseAllowPrivateRepositoryForkingSettingArgs, 'input'>>;
  updateEnterpriseDefaultRepositoryPermissionSetting?: Resolver<Maybe<GQLResolversTypes['UpdateEnterpriseDefaultRepositoryPermissionSettingPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateEnterpriseDefaultRepositoryPermissionSettingArgs, 'input'>>;
  updateEnterpriseMembersCanChangeRepositoryVisibilitySetting?: Resolver<Maybe<GQLResolversTypes['UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingArgs, 'input'>>;
  updateEnterpriseMembersCanCreateRepositoriesSetting?: Resolver<Maybe<GQLResolversTypes['UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateEnterpriseMembersCanCreateRepositoriesSettingArgs, 'input'>>;
  updateEnterpriseMembersCanDeleteIssuesSetting?: Resolver<Maybe<GQLResolversTypes['UpdateEnterpriseMembersCanDeleteIssuesSettingPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateEnterpriseMembersCanDeleteIssuesSettingArgs, 'input'>>;
  updateEnterpriseMembersCanDeleteRepositoriesSetting?: Resolver<Maybe<GQLResolversTypes['UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateEnterpriseMembersCanDeleteRepositoriesSettingArgs, 'input'>>;
  updateEnterpriseMembersCanInviteCollaboratorsSetting?: Resolver<Maybe<GQLResolversTypes['UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateEnterpriseMembersCanInviteCollaboratorsSettingArgs, 'input'>>;
  updateEnterpriseMembersCanMakePurchasesSetting?: Resolver<Maybe<GQLResolversTypes['UpdateEnterpriseMembersCanMakePurchasesSettingPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateEnterpriseMembersCanMakePurchasesSettingArgs, 'input'>>;
  updateEnterpriseMembersCanUpdateProtectedBranchesSetting?: Resolver<Maybe<GQLResolversTypes['UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingArgs, 'input'>>;
  updateEnterpriseMembersCanViewDependencyInsightsSetting?: Resolver<Maybe<GQLResolversTypes['UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateEnterpriseMembersCanViewDependencyInsightsSettingArgs, 'input'>>;
  updateEnterpriseOrganizationProjectsSetting?: Resolver<Maybe<GQLResolversTypes['UpdateEnterpriseOrganizationProjectsSettingPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateEnterpriseOrganizationProjectsSettingArgs, 'input'>>;
  updateEnterpriseProfile?: Resolver<Maybe<GQLResolversTypes['UpdateEnterpriseProfilePayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateEnterpriseProfileArgs, 'input'>>;
  updateEnterpriseRepositoryProjectsSetting?: Resolver<Maybe<GQLResolversTypes['UpdateEnterpriseRepositoryProjectsSettingPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateEnterpriseRepositoryProjectsSettingArgs, 'input'>>;
  updateEnterpriseTeamDiscussionsSetting?: Resolver<Maybe<GQLResolversTypes['UpdateEnterpriseTeamDiscussionsSettingPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateEnterpriseTeamDiscussionsSettingArgs, 'input'>>;
  updateEnterpriseTwoFactorAuthenticationRequiredSetting?: Resolver<Maybe<GQLResolversTypes['UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateEnterpriseTwoFactorAuthenticationRequiredSettingArgs, 'input'>>;
  updateIpAllowListEnabledSetting?: Resolver<Maybe<GQLResolversTypes['UpdateIpAllowListEnabledSettingPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateIpAllowListEnabledSettingArgs, 'input'>>;
  updateIpAllowListEntry?: Resolver<Maybe<GQLResolversTypes['UpdateIpAllowListEntryPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateIpAllowListEntryArgs, 'input'>>;
  updateIssue?: Resolver<Maybe<GQLResolversTypes['UpdateIssuePayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateIssueArgs, 'input'>>;
  updateIssueComment?: Resolver<Maybe<GQLResolversTypes['UpdateIssueCommentPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateIssueCommentArgs, 'input'>>;
  updateLabel?: Resolver<Maybe<GQLResolversTypes['UpdateLabelPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateLabelArgs, 'input'>>;
  updateProject?: Resolver<Maybe<GQLResolversTypes['UpdateProjectPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateProjectArgs, 'input'>>;
  updateProjectCard?: Resolver<Maybe<GQLResolversTypes['UpdateProjectCardPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateProjectCardArgs, 'input'>>;
  updateProjectColumn?: Resolver<Maybe<GQLResolversTypes['UpdateProjectColumnPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateProjectColumnArgs, 'input'>>;
  updatePullRequest?: Resolver<Maybe<GQLResolversTypes['UpdatePullRequestPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdatePullRequestArgs, 'input'>>;
  updatePullRequestReview?: Resolver<Maybe<GQLResolversTypes['UpdatePullRequestReviewPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdatePullRequestReviewArgs, 'input'>>;
  updatePullRequestReviewComment?: Resolver<Maybe<GQLResolversTypes['UpdatePullRequestReviewCommentPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdatePullRequestReviewCommentArgs, 'input'>>;
  updateRef?: Resolver<Maybe<GQLResolversTypes['UpdateRefPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateRefArgs, 'input'>>;
  updateRefs?: Resolver<Maybe<GQLResolversTypes['UpdateRefsPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateRefsArgs, 'input'>>;
  updateRepository?: Resolver<Maybe<GQLResolversTypes['UpdateRepositoryPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateRepositoryArgs, 'input'>>;
  updateSubscription?: Resolver<Maybe<GQLResolversTypes['UpdateSubscriptionPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateSubscriptionArgs, 'input'>>;
  updateTeamDiscussion?: Resolver<Maybe<GQLResolversTypes['UpdateTeamDiscussionPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateTeamDiscussionArgs, 'input'>>;
  updateTeamDiscussionComment?: Resolver<Maybe<GQLResolversTypes['UpdateTeamDiscussionCommentPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateTeamDiscussionCommentArgs, 'input'>>;
  updateTeamReviewAssignment?: Resolver<Maybe<GQLResolversTypes['UpdateTeamReviewAssignmentPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateTeamReviewAssignmentArgs, 'input'>>;
  updateTopics?: Resolver<Maybe<GQLResolversTypes['UpdateTopicsPayload']>, ParentType, ContextType, RequireFields<GQLMutationUpdateTopicsArgs, 'input'>>;
};

export type GQLNodeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Node'] = GQLResolversParentTypes['Node']> = {
  __resolveType: TypeResolveFn<'AddedToProjectEvent' | 'App' | 'AssignedEvent' | 'AutomaticBaseChangeFailedEvent' | 'AutomaticBaseChangeSucceededEvent' | 'BaseRefChangedEvent' | 'BaseRefForcePushedEvent' | 'Blob' | 'Bot' | 'BranchProtectionRule' | 'CheckRun' | 'CheckSuite' | 'ClosedEvent' | 'CodeOfConduct' | 'CommentDeletedEvent' | 'Commit' | 'CommitComment' | 'CommitCommentThread' | 'ConnectedEvent' | 'ConvertToDraftEvent' | 'ConvertedNoteToIssueEvent' | 'CrossReferencedEvent' | 'DemilestonedEvent' | 'DependencyGraphManifest' | 'DeployKey' | 'DeployedEvent' | 'Deployment' | 'DeploymentEnvironmentChangedEvent' | 'DeploymentStatus' | 'DisconnectedEvent' | 'Enterprise' | 'EnterpriseAdministratorInvitation' | 'EnterpriseIdentityProvider' | 'EnterpriseRepositoryInfo' | 'EnterpriseServerInstallation' | 'EnterpriseServerUserAccount' | 'EnterpriseServerUserAccountEmail' | 'EnterpriseServerUserAccountsUpload' | 'EnterpriseUserAccount' | 'ExternalIdentity' | 'Gist' | 'GistComment' | 'HeadRefDeletedEvent' | 'HeadRefForcePushedEvent' | 'HeadRefRestoredEvent' | 'IpAllowListEntry' | 'Issue' | 'IssueComment' | 'Label' | 'LabeledEvent' | 'Language' | 'License' | 'LockedEvent' | 'Mannequin' | 'MarkedAsDuplicateEvent' | 'MarketplaceCategory' | 'MarketplaceListing' | 'MembersCanDeleteReposClearAuditEntry' | 'MembersCanDeleteReposDisableAuditEntry' | 'MembersCanDeleteReposEnableAuditEntry' | 'MentionedEvent' | 'MergedEvent' | 'Milestone' | 'MilestonedEvent' | 'MovedColumnsInProjectEvent' | 'OauthApplicationCreateAuditEntry' | 'OrgAddBillingManagerAuditEntry' | 'OrgAddMemberAuditEntry' | 'OrgBlockUserAuditEntry' | 'OrgConfigDisableCollaboratorsOnlyAuditEntry' | 'OrgConfigEnableCollaboratorsOnlyAuditEntry' | 'OrgCreateAuditEntry' | 'OrgDisableOauthAppRestrictionsAuditEntry' | 'OrgDisableSamlAuditEntry' | 'OrgDisableTwoFactorRequirementAuditEntry' | 'OrgEnableOauthAppRestrictionsAuditEntry' | 'OrgEnableSamlAuditEntry' | 'OrgEnableTwoFactorRequirementAuditEntry' | 'OrgInviteMemberAuditEntry' | 'OrgInviteToBusinessAuditEntry' | 'OrgOauthAppAccessApprovedAuditEntry' | 'OrgOauthAppAccessDeniedAuditEntry' | 'OrgOauthAppAccessRequestedAuditEntry' | 'OrgRemoveBillingManagerAuditEntry' | 'OrgRemoveMemberAuditEntry' | 'OrgRemoveOutsideCollaboratorAuditEntry' | 'OrgRestoreMemberAuditEntry' | 'OrgUnblockUserAuditEntry' | 'OrgUpdateDefaultRepositoryPermissionAuditEntry' | 'OrgUpdateMemberAuditEntry' | 'OrgUpdateMemberRepositoryCreationPermissionAuditEntry' | 'OrgUpdateMemberRepositoryInvitationPermissionAuditEntry' | 'Organization' | 'OrganizationIdentityProvider' | 'OrganizationInvitation' | 'Package' | 'PackageFile' | 'PackageTag' | 'PackageVersion' | 'PinnedEvent' | 'PinnedIssue' | 'PrivateRepositoryForkingDisableAuditEntry' | 'PrivateRepositoryForkingEnableAuditEntry' | 'Project' | 'ProjectCard' | 'ProjectColumn' | 'PublicKey' | 'PullRequest' | 'PullRequestCommit' | 'PullRequestCommitCommentThread' | 'PullRequestReview' | 'PullRequestReviewComment' | 'PullRequestReviewThread' | 'Push' | 'PushAllowance' | 'Reaction' | 'ReadyForReviewEvent' | 'Ref' | 'ReferencedEvent' | 'RegistryPackage' | 'RegistryPackageDependency' | 'RegistryPackageFile' | 'RegistryPackageTag' | 'RegistryPackageVersion' | 'Release' | 'ReleaseAsset' | 'RemovedFromProjectEvent' | 'RenamedTitleEvent' | 'ReopenedEvent' | 'RepoAccessAuditEntry' | 'RepoAddMemberAuditEntry' | 'RepoAddTopicAuditEntry' | 'RepoArchivedAuditEntry' | 'RepoChangeMergeSettingAuditEntry' | 'RepoConfigDisableAnonymousGitAccessAuditEntry' | 'RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'RepoConfigDisableContributorsOnlyAuditEntry' | 'RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'RepoConfigEnableAnonymousGitAccessAuditEntry' | 'RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'RepoConfigEnableContributorsOnlyAuditEntry' | 'RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'RepoConfigLockAnonymousGitAccessAuditEntry' | 'RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'RepoCreateAuditEntry' | 'RepoDestroyAuditEntry' | 'RepoRemoveMemberAuditEntry' | 'RepoRemoveTopicAuditEntry' | 'Repository' | 'RepositoryInvitation' | 'RepositoryTopic' | 'RepositoryVisibilityChangeDisableAuditEntry' | 'RepositoryVisibilityChangeEnableAuditEntry' | 'RepositoryVulnerabilityAlert' | 'ReviewDismissalAllowance' | 'ReviewDismissedEvent' | 'ReviewRequest' | 'ReviewRequestRemovedEvent' | 'ReviewRequestedEvent' | 'SavedReply' | 'SecurityAdvisory' | 'SponsorsListing' | 'SponsorsTier' | 'Sponsorship' | 'Status' | 'StatusCheckRollup' | 'StatusContext' | 'SubscribedEvent' | 'Tag' | 'Team' | 'TeamAddMemberAuditEntry' | 'TeamAddRepositoryAuditEntry' | 'TeamChangeParentTeamAuditEntry' | 'TeamDiscussion' | 'TeamDiscussionComment' | 'TeamRemoveMemberAuditEntry' | 'TeamRemoveRepositoryAuditEntry' | 'Topic' | 'TransferredEvent' | 'Tree' | 'UnassignedEvent' | 'UnlabeledEvent' | 'UnlockedEvent' | 'UnmarkedAsDuplicateEvent' | 'UnpinnedEvent' | 'UnsubscribedEvent' | 'User' | 'UserBlockedEvent' | 'UserContentEdit' | 'UserStatus', ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
};

export type GQLOauthApplicationAuditEntryDataResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OauthApplicationAuditEntryData'] = GQLResolversParentTypes['OauthApplicationAuditEntryData']> = {
  __resolveType: TypeResolveFn<'OauthApplicationCreateAuditEntry' | 'OrgOauthAppAccessApprovedAuditEntry' | 'OrgOauthAppAccessDeniedAuditEntry' | 'OrgOauthAppAccessRequestedAuditEntry', ParentType, ContextType>;
  oauthApplicationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  oauthApplicationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  oauthApplicationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
};

export type GQLOauthApplicationCreateAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OauthApplicationCreateAuditEntry'] = GQLResolversParentTypes['OauthApplicationCreateAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  applicationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  callbackUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  oauthApplicationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  oauthApplicationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  oauthApplicationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  rateLimit?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  state?: Resolver<Maybe<GQLResolversTypes['OauthApplicationCreateAuditEntryState']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgAddBillingManagerAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgAddBillingManagerAuditEntry'] = GQLResolversParentTypes['OrgAddBillingManagerAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  invitationEmail?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgAddMemberAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgAddMemberAuditEntry'] = GQLResolversParentTypes['OrgAddMemberAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  permission?: Resolver<Maybe<GQLResolversTypes['OrgAddMemberAuditEntryPermission']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgBlockUserAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgBlockUserAuditEntry'] = GQLResolversParentTypes['OrgBlockUserAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  blockedUser?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  blockedUserName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  blockedUserResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  blockedUserUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgConfigDisableCollaboratorsOnlyAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgConfigDisableCollaboratorsOnlyAuditEntry'] = GQLResolversParentTypes['OrgConfigDisableCollaboratorsOnlyAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgConfigEnableCollaboratorsOnlyAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgConfigEnableCollaboratorsOnlyAuditEntry'] = GQLResolversParentTypes['OrgConfigEnableCollaboratorsOnlyAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgCreateAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgCreateAuditEntry'] = GQLResolversParentTypes['OrgCreateAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  billingPlan?: Resolver<Maybe<GQLResolversTypes['OrgCreateAuditEntryBillingPlan']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgDisableOauthAppRestrictionsAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgDisableOauthAppRestrictionsAuditEntry'] = GQLResolversParentTypes['OrgDisableOauthAppRestrictionsAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgDisableSamlAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgDisableSamlAuditEntry'] = GQLResolversParentTypes['OrgDisableSamlAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  digestMethodUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  issuerUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  signatureMethodUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  singleSignOnUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgDisableTwoFactorRequirementAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgDisableTwoFactorRequirementAuditEntry'] = GQLResolversParentTypes['OrgDisableTwoFactorRequirementAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgEnableOauthAppRestrictionsAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgEnableOauthAppRestrictionsAuditEntry'] = GQLResolversParentTypes['OrgEnableOauthAppRestrictionsAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgEnableSamlAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgEnableSamlAuditEntry'] = GQLResolversParentTypes['OrgEnableSamlAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  digestMethodUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  issuerUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  signatureMethodUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  singleSignOnUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgEnableTwoFactorRequirementAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgEnableTwoFactorRequirementAuditEntry'] = GQLResolversParentTypes['OrgEnableTwoFactorRequirementAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgInviteMemberAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgInviteMemberAuditEntry'] = GQLResolversParentTypes['OrgInviteMemberAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  email?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationInvitation?: Resolver<Maybe<GQLResolversTypes['OrganizationInvitation']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgInviteToBusinessAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgInviteToBusinessAuditEntry'] = GQLResolversParentTypes['OrgInviteToBusinessAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgOauthAppAccessApprovedAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgOauthAppAccessApprovedAuditEntry'] = GQLResolversParentTypes['OrgOauthAppAccessApprovedAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  oauthApplicationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  oauthApplicationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  oauthApplicationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgOauthAppAccessDeniedAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgOauthAppAccessDeniedAuditEntry'] = GQLResolversParentTypes['OrgOauthAppAccessDeniedAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  oauthApplicationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  oauthApplicationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  oauthApplicationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgOauthAppAccessRequestedAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgOauthAppAccessRequestedAuditEntry'] = GQLResolversParentTypes['OrgOauthAppAccessRequestedAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  oauthApplicationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  oauthApplicationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  oauthApplicationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgRemoveBillingManagerAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgRemoveBillingManagerAuditEntry'] = GQLResolversParentTypes['OrgRemoveBillingManagerAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  reason?: Resolver<Maybe<GQLResolversTypes['OrgRemoveBillingManagerAuditEntryReason']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgRemoveMemberAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgRemoveMemberAuditEntry'] = GQLResolversParentTypes['OrgRemoveMemberAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  membershipTypes?: Resolver<Maybe<Array<GQLResolversTypes['OrgRemoveMemberAuditEntryMembershipType']>>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  reason?: Resolver<Maybe<GQLResolversTypes['OrgRemoveMemberAuditEntryReason']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgRemoveOutsideCollaboratorAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgRemoveOutsideCollaboratorAuditEntry'] = GQLResolversParentTypes['OrgRemoveOutsideCollaboratorAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  membershipTypes?: Resolver<Maybe<Array<GQLResolversTypes['OrgRemoveOutsideCollaboratorAuditEntryMembershipType']>>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  reason?: Resolver<Maybe<GQLResolversTypes['OrgRemoveOutsideCollaboratorAuditEntryReason']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgRestoreMemberAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgRestoreMemberAuditEntry'] = GQLResolversParentTypes['OrgRestoreMemberAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  restoredCustomEmailRoutingsCount?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  restoredIssueAssignmentsCount?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  restoredMemberships?: Resolver<Maybe<Array<GQLResolversTypes['OrgRestoreMemberAuditEntryMembership']>>, ParentType, ContextType>;
  restoredMembershipsCount?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  restoredRepositoriesCount?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  restoredRepositoryStarsCount?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  restoredRepositoryWatchesCount?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgRestoreMemberAuditEntryMembershipResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgRestoreMemberAuditEntryMembership'] = GQLResolversParentTypes['OrgRestoreMemberAuditEntryMembership']> = {
  __resolveType: TypeResolveFn<'OrgRestoreMemberMembershipOrganizationAuditEntryData' | 'OrgRestoreMemberMembershipRepositoryAuditEntryData' | 'OrgRestoreMemberMembershipTeamAuditEntryData', ParentType, ContextType>;
};

export type GQLOrgRestoreMemberMembershipOrganizationAuditEntryDataResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgRestoreMemberMembershipOrganizationAuditEntryData'] = GQLResolversParentTypes['OrgRestoreMemberMembershipOrganizationAuditEntryData']> = {
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgRestoreMemberMembershipRepositoryAuditEntryDataResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgRestoreMemberMembershipRepositoryAuditEntryData'] = GQLResolversParentTypes['OrgRestoreMemberMembershipRepositoryAuditEntryData']> = {
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgRestoreMemberMembershipTeamAuditEntryDataResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgRestoreMemberMembershipTeamAuditEntryData'] = GQLResolversParentTypes['OrgRestoreMemberMembershipTeamAuditEntryData']> = {
  team?: Resolver<Maybe<GQLResolversTypes['Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgUnblockUserAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgUnblockUserAuditEntry'] = GQLResolversParentTypes['OrgUnblockUserAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  blockedUser?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  blockedUserName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  blockedUserResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  blockedUserUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgUpdateDefaultRepositoryPermissionAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgUpdateDefaultRepositoryPermissionAuditEntry'] = GQLResolversParentTypes['OrgUpdateDefaultRepositoryPermissionAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  permission?: Resolver<Maybe<GQLResolversTypes['OrgUpdateDefaultRepositoryPermissionAuditEntryPermission']>, ParentType, ContextType>;
  permissionWas?: Resolver<Maybe<GQLResolversTypes['OrgUpdateDefaultRepositoryPermissionAuditEntryPermission']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgUpdateMemberAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgUpdateMemberAuditEntry'] = GQLResolversParentTypes['OrgUpdateMemberAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  permission?: Resolver<Maybe<GQLResolversTypes['OrgUpdateMemberAuditEntryPermission']>, ParentType, ContextType>;
  permissionWas?: Resolver<Maybe<GQLResolversTypes['OrgUpdateMemberAuditEntryPermission']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgUpdateMemberRepositoryCreationPermissionAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgUpdateMemberRepositoryCreationPermissionAuditEntry'] = GQLResolversParentTypes['OrgUpdateMemberRepositoryCreationPermissionAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  canCreateRepositories?: Resolver<Maybe<GQLResolversTypes['Boolean']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<GQLResolversTypes['OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrgUpdateMemberRepositoryInvitationPermissionAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrgUpdateMemberRepositoryInvitationPermissionAuditEntry'] = GQLResolversParentTypes['OrgUpdateMemberRepositoryInvitationPermissionAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  canInviteOutsideCollaboratorsToRepositories?: Resolver<Maybe<GQLResolversTypes['Boolean']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrganizationResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Organization'] = GQLResolversParentTypes['Organization']> = {
  anyPinnableItems?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType, RequireFields<GQLOrganizationAnyPinnableItemsArgs, never>>;
  auditLog?: Resolver<GQLResolversTypes['OrganizationAuditEntryConnection'], ParentType, ContextType, RequireFields<GQLOrganizationAuditLogArgs, 'orderBy'>>;
  avatarUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType, RequireFields<GQLOrganizationAvatarUrlArgs, never>>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  descriptionHTML?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  email?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  ipAllowListEnabledSetting?: Resolver<GQLResolversTypes['IpAllowListEnabledSettingValue'], ParentType, ContextType>;
  ipAllowListEntries?: Resolver<GQLResolversTypes['IpAllowListEntryConnection'], ParentType, ContextType, RequireFields<GQLOrganizationIpAllowListEntriesArgs, 'orderBy'>>;
  isVerified?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  itemShowcase?: Resolver<GQLResolversTypes['ProfileItemShowcase'], ParentType, ContextType>;
  location?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  login?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  memberStatuses?: Resolver<GQLResolversTypes['UserStatusConnection'], ParentType, ContextType, RequireFields<GQLOrganizationMemberStatusesArgs, 'orderBy'>>;
  membersWithRole?: Resolver<GQLResolversTypes['OrganizationMemberConnection'], ParentType, ContextType, RequireFields<GQLOrganizationMembersWithRoleArgs, never>>;
  name?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  newTeamResourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  newTeamUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  organizationBillingEmail?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  packages?: Resolver<GQLResolversTypes['PackageConnection'], ParentType, ContextType, RequireFields<GQLOrganizationPackagesArgs, 'orderBy'>>;
  pendingMembers?: Resolver<GQLResolversTypes['UserConnection'], ParentType, ContextType, RequireFields<GQLOrganizationPendingMembersArgs, never>>;
  pinnableItems?: Resolver<GQLResolversTypes['PinnableItemConnection'], ParentType, ContextType, RequireFields<GQLOrganizationPinnableItemsArgs, never>>;
  pinnedItems?: Resolver<GQLResolversTypes['PinnableItemConnection'], ParentType, ContextType, RequireFields<GQLOrganizationPinnedItemsArgs, never>>;
  pinnedItemsRemaining?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  project?: Resolver<Maybe<GQLResolversTypes['Project']>, ParentType, ContextType, RequireFields<GQLOrganizationProjectArgs, 'number'>>;
  projects?: Resolver<GQLResolversTypes['ProjectConnection'], ParentType, ContextType, RequireFields<GQLOrganizationProjectsArgs, never>>;
  projectsResourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  projectsUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  registryPackages?: Resolver<GQLResolversTypes['RegistryPackageConnection'], ParentType, ContextType, RequireFields<GQLOrganizationRegistryPackagesArgs, 'publicOnly'>>;
  registryPackagesForQuery?: Resolver<GQLResolversTypes['RegistryPackageConnection'], ParentType, ContextType, RequireFields<GQLOrganizationRegistryPackagesForQueryArgs, never>>;
  repositories?: Resolver<GQLResolversTypes['RepositoryConnection'], ParentType, ContextType, RequireFields<GQLOrganizationRepositoriesArgs, 'ownerAffiliations'>>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType, RequireFields<GQLOrganizationRepositoryArgs, 'name'>>;
  requiresTwoFactorAuthentication?: Resolver<Maybe<GQLResolversTypes['Boolean']>, ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  samlIdentityProvider?: Resolver<Maybe<GQLResolversTypes['OrganizationIdentityProvider']>, ParentType, ContextType>;
  sponsorsListing?: Resolver<Maybe<GQLResolversTypes['SponsorsListing']>, ParentType, ContextType>;
  sponsorshipsAsMaintainer?: Resolver<GQLResolversTypes['SponsorshipConnection'], ParentType, ContextType, RequireFields<GQLOrganizationSponsorshipsAsMaintainerArgs, 'includePrivate'>>;
  sponsorshipsAsSponsor?: Resolver<GQLResolversTypes['SponsorshipConnection'], ParentType, ContextType, RequireFields<GQLOrganizationSponsorshipsAsSponsorArgs, never>>;
  team?: Resolver<Maybe<GQLResolversTypes['Team']>, ParentType, ContextType, RequireFields<GQLOrganizationTeamArgs, 'slug'>>;
  teams?: Resolver<GQLResolversTypes['TeamConnection'], ParentType, ContextType, RequireFields<GQLOrganizationTeamsArgs, 'rootTeamsOnly'>>;
  teamsResourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  teamsUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  twitterUsername?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  viewerCanAdminister?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanChangePinnedItems?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanCreateProjects?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanCreateRepositories?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanCreateTeams?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerIsAMember?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  websiteUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrganizationAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrganizationAuditEntry'] = GQLResolversParentTypes['OrganizationAuditEntry']> = {
  __resolveType: TypeResolveFn<'MembersCanDeleteReposClearAuditEntry' | 'MembersCanDeleteReposDisableAuditEntry' | 'MembersCanDeleteReposEnableAuditEntry' | 'OauthApplicationCreateAuditEntry' | 'OrgAddBillingManagerAuditEntry' | 'OrgAddMemberAuditEntry' | 'OrgBlockUserAuditEntry' | 'OrgConfigDisableCollaboratorsOnlyAuditEntry' | 'OrgConfigEnableCollaboratorsOnlyAuditEntry' | 'OrgCreateAuditEntry' | 'OrgDisableOauthAppRestrictionsAuditEntry' | 'OrgDisableSamlAuditEntry' | 'OrgDisableTwoFactorRequirementAuditEntry' | 'OrgEnableOauthAppRestrictionsAuditEntry' | 'OrgEnableSamlAuditEntry' | 'OrgEnableTwoFactorRequirementAuditEntry' | 'OrgInviteMemberAuditEntry' | 'OrgInviteToBusinessAuditEntry' | 'OrgOauthAppAccessApprovedAuditEntry' | 'OrgOauthAppAccessDeniedAuditEntry' | 'OrgOauthAppAccessRequestedAuditEntry' | 'OrgRemoveBillingManagerAuditEntry' | 'OrgRemoveMemberAuditEntry' | 'OrgRemoveOutsideCollaboratorAuditEntry' | 'OrgRestoreMemberAuditEntry' | 'OrgUnblockUserAuditEntry' | 'OrgUpdateDefaultRepositoryPermissionAuditEntry' | 'OrgUpdateMemberAuditEntry' | 'OrgUpdateMemberRepositoryCreationPermissionAuditEntry' | 'OrgUpdateMemberRepositoryInvitationPermissionAuditEntry' | 'PrivateRepositoryForkingDisableAuditEntry' | 'PrivateRepositoryForkingEnableAuditEntry' | 'RepoAccessAuditEntry' | 'RepoAddMemberAuditEntry' | 'RepoAddTopicAuditEntry' | 'RepoArchivedAuditEntry' | 'RepoChangeMergeSettingAuditEntry' | 'RepoConfigDisableAnonymousGitAccessAuditEntry' | 'RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'RepoConfigDisableContributorsOnlyAuditEntry' | 'RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'RepoConfigEnableAnonymousGitAccessAuditEntry' | 'RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'RepoConfigEnableContributorsOnlyAuditEntry' | 'RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'RepoConfigLockAnonymousGitAccessAuditEntry' | 'RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'RepoCreateAuditEntry' | 'RepoDestroyAuditEntry' | 'RepoRemoveMemberAuditEntry' | 'RepoRemoveTopicAuditEntry' | 'RepositoryVisibilityChangeDisableAuditEntry' | 'RepositoryVisibilityChangeEnableAuditEntry' | 'TeamAddMemberAuditEntry' | 'TeamAddRepositoryAuditEntry' | 'TeamChangeParentTeamAuditEntry' | 'TeamRemoveMemberAuditEntry' | 'TeamRemoveRepositoryAuditEntry', ParentType, ContextType>;
};

export type GQLOrganizationAuditEntryConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrganizationAuditEntryConnection'] = GQLResolversParentTypes['OrganizationAuditEntryConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['OrganizationAuditEntryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['OrganizationAuditEntry']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrganizationAuditEntryDataResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrganizationAuditEntryData'] = GQLResolversParentTypes['OrganizationAuditEntryData']> = {
  __resolveType: TypeResolveFn<'MembersCanDeleteReposClearAuditEntry' | 'MembersCanDeleteReposDisableAuditEntry' | 'MembersCanDeleteReposEnableAuditEntry' | 'OauthApplicationCreateAuditEntry' | 'OrgAddBillingManagerAuditEntry' | 'OrgAddMemberAuditEntry' | 'OrgBlockUserAuditEntry' | 'OrgConfigDisableCollaboratorsOnlyAuditEntry' | 'OrgConfigEnableCollaboratorsOnlyAuditEntry' | 'OrgCreateAuditEntry' | 'OrgDisableOauthAppRestrictionsAuditEntry' | 'OrgDisableSamlAuditEntry' | 'OrgDisableTwoFactorRequirementAuditEntry' | 'OrgEnableOauthAppRestrictionsAuditEntry' | 'OrgEnableSamlAuditEntry' | 'OrgEnableTwoFactorRequirementAuditEntry' | 'OrgInviteMemberAuditEntry' | 'OrgInviteToBusinessAuditEntry' | 'OrgOauthAppAccessApprovedAuditEntry' | 'OrgOauthAppAccessDeniedAuditEntry' | 'OrgOauthAppAccessRequestedAuditEntry' | 'OrgRemoveBillingManagerAuditEntry' | 'OrgRemoveMemberAuditEntry' | 'OrgRemoveOutsideCollaboratorAuditEntry' | 'OrgRestoreMemberAuditEntry' | 'OrgRestoreMemberMembershipOrganizationAuditEntryData' | 'OrgUnblockUserAuditEntry' | 'OrgUpdateDefaultRepositoryPermissionAuditEntry' | 'OrgUpdateMemberAuditEntry' | 'OrgUpdateMemberRepositoryCreationPermissionAuditEntry' | 'OrgUpdateMemberRepositoryInvitationPermissionAuditEntry' | 'PrivateRepositoryForkingDisableAuditEntry' | 'PrivateRepositoryForkingEnableAuditEntry' | 'RepoAccessAuditEntry' | 'RepoAddMemberAuditEntry' | 'RepoAddTopicAuditEntry' | 'RepoArchivedAuditEntry' | 'RepoChangeMergeSettingAuditEntry' | 'RepoConfigDisableAnonymousGitAccessAuditEntry' | 'RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'RepoConfigDisableContributorsOnlyAuditEntry' | 'RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'RepoConfigEnableAnonymousGitAccessAuditEntry' | 'RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'RepoConfigEnableContributorsOnlyAuditEntry' | 'RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'RepoConfigLockAnonymousGitAccessAuditEntry' | 'RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'RepoCreateAuditEntry' | 'RepoDestroyAuditEntry' | 'RepoRemoveMemberAuditEntry' | 'RepoRemoveTopicAuditEntry' | 'RepositoryVisibilityChangeDisableAuditEntry' | 'RepositoryVisibilityChangeEnableAuditEntry' | 'TeamAddMemberAuditEntry' | 'TeamAddRepositoryAuditEntry' | 'TeamChangeParentTeamAuditEntry' | 'TeamRemoveMemberAuditEntry' | 'TeamRemoveRepositoryAuditEntry', ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
};

export type GQLOrganizationAuditEntryEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrganizationAuditEntryEdge'] = GQLResolversParentTypes['OrganizationAuditEntryEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['OrganizationAuditEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrganizationConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrganizationConnection'] = GQLResolversParentTypes['OrganizationConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['OrganizationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['Organization']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrganizationEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrganizationEdge'] = GQLResolversParentTypes['OrganizationEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrganizationIdentityProviderResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrganizationIdentityProvider'] = GQLResolversParentTypes['OrganizationIdentityProvider']> = {
  digestMethod?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  externalIdentities?: Resolver<GQLResolversTypes['ExternalIdentityConnection'], ParentType, ContextType, RequireFields<GQLOrganizationIdentityProviderExternalIdentitiesArgs, never>>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  idpCertificate?: Resolver<Maybe<GQLResolversTypes['X509Certificate']>, ParentType, ContextType>;
  issuer?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  signatureMethod?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  ssoUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrganizationInvitationResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrganizationInvitation'] = GQLResolversParentTypes['OrganizationInvitation']> = {
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  email?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  invitationType?: Resolver<GQLResolversTypes['OrganizationInvitationType'], ParentType, ContextType>;
  invitee?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  inviter?: Resolver<GQLResolversTypes['User'], ParentType, ContextType>;
  organization?: Resolver<GQLResolversTypes['Organization'], ParentType, ContextType>;
  role?: Resolver<GQLResolversTypes['OrganizationInvitationRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrganizationInvitationConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrganizationInvitationConnection'] = GQLResolversParentTypes['OrganizationInvitationConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['OrganizationInvitationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['OrganizationInvitation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrganizationInvitationEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrganizationInvitationEdge'] = GQLResolversParentTypes['OrganizationInvitationEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['OrganizationInvitation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrganizationMemberConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrganizationMemberConnection'] = GQLResolversParentTypes['OrganizationMemberConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['OrganizationMemberEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrganizationMemberEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrganizationMemberEdge'] = GQLResolversParentTypes['OrganizationMemberEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  hasTwoFactorEnabled?: Resolver<Maybe<GQLResolversTypes['Boolean']>, ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  role?: Resolver<Maybe<GQLResolversTypes['OrganizationMemberRole']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrganizationTeamsHovercardContextResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrganizationTeamsHovercardContext'] = GQLResolversParentTypes['OrganizationTeamsHovercardContext']> = {
  message?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  octicon?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  relevantTeams?: Resolver<GQLResolversTypes['TeamConnection'], ParentType, ContextType, RequireFields<GQLOrganizationTeamsHovercardContextRelevantTeamsArgs, never>>;
  teamsResourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  teamsUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  totalTeamCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLOrganizationsHovercardContextResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['OrganizationsHovercardContext'] = GQLResolversParentTypes['OrganizationsHovercardContext']> = {
  message?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  octicon?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  relevantOrganizations?: Resolver<GQLResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<GQLOrganizationsHovercardContextRelevantOrganizationsArgs, never>>;
  totalOrganizationCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPackageResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Package'] = GQLResolversParentTypes['Package']> = {
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  latestVersion?: Resolver<Maybe<GQLResolversTypes['PackageVersion']>, ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  packageType?: Resolver<GQLResolversTypes['PackageType'], ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  statistics?: Resolver<Maybe<GQLResolversTypes['PackageStatistics']>, ParentType, ContextType>;
  version?: Resolver<Maybe<GQLResolversTypes['PackageVersion']>, ParentType, ContextType, RequireFields<GQLPackageVersionArgs, 'version'>>;
  versions?: Resolver<GQLResolversTypes['PackageVersionConnection'], ParentType, ContextType, RequireFields<GQLPackageVersionsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPackageConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PackageConnection'] = GQLResolversParentTypes['PackageConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PackageEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['Package']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPackageEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PackageEdge'] = GQLResolversParentTypes['PackageEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['Package']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPackageFileResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PackageFile'] = GQLResolversParentTypes['PackageFile']> = {
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  md5?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  packageVersion?: Resolver<Maybe<GQLResolversTypes['PackageVersion']>, ParentType, ContextType>;
  sha1?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  sha256?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  size?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPackageFileConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PackageFileConnection'] = GQLResolversParentTypes['PackageFileConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PackageFileEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PackageFile']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPackageFileEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PackageFileEdge'] = GQLResolversParentTypes['PackageFileEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['PackageFile']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPackageOwnerResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PackageOwner'] = GQLResolversParentTypes['PackageOwner']> = {
  __resolveType: TypeResolveFn<'Organization' | 'Repository' | 'User', ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  packages?: Resolver<GQLResolversTypes['PackageConnection'], ParentType, ContextType, RequireFields<GQLPackageOwnerPackagesArgs, 'orderBy'>>;
};

export type GQLPackageStatisticsResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PackageStatistics'] = GQLResolversParentTypes['PackageStatistics']> = {
  downloadsTotalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPackageTagResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PackageTag'] = GQLResolversParentTypes['PackageTag']> = {
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  version?: Resolver<Maybe<GQLResolversTypes['PackageVersion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPackageVersionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PackageVersion'] = GQLResolversParentTypes['PackageVersion']> = {
  files?: Resolver<GQLResolversTypes['PackageFileConnection'], ParentType, ContextType, RequireFields<GQLPackageVersionFilesArgs, 'orderBy'>>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  package?: Resolver<Maybe<GQLResolversTypes['Package']>, ParentType, ContextType>;
  platform?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  preRelease?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  readme?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  release?: Resolver<Maybe<GQLResolversTypes['Release']>, ParentType, ContextType>;
  statistics?: Resolver<Maybe<GQLResolversTypes['PackageVersionStatistics']>, ParentType, ContextType>;
  summary?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  version?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPackageVersionConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PackageVersionConnection'] = GQLResolversParentTypes['PackageVersionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PackageVersionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PackageVersion']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPackageVersionEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PackageVersionEdge'] = GQLResolversParentTypes['PackageVersionEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['PackageVersion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPackageVersionStatisticsResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PackageVersionStatistics'] = GQLResolversParentTypes['PackageVersionStatistics']> = {
  downloadsTotalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPageInfoResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PageInfo'] = GQLResolversParentTypes['PageInfo']> = {
  endCursor?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  hasNextPage?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  hasPreviousPage?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  startCursor?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPermissionGranterResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PermissionGranter'] = GQLResolversParentTypes['PermissionGranter']> = {
  __resolveType: TypeResolveFn<'Organization' | 'Repository' | 'Team', ParentType, ContextType>;
};

export type GQLPermissionSourceResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PermissionSource'] = GQLResolversParentTypes['PermissionSource']> = {
  organization?: Resolver<GQLResolversTypes['Organization'], ParentType, ContextType>;
  permission?: Resolver<GQLResolversTypes['DefaultRepositoryPermissionField'], ParentType, ContextType>;
  source?: Resolver<GQLResolversTypes['PermissionGranter'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPinIssuePayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PinIssuePayload'] = GQLResolversParentTypes['PinIssuePayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<GQLResolversTypes['Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPinnableItemResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PinnableItem'] = GQLResolversParentTypes['PinnableItem']> = {
  __resolveType: TypeResolveFn<'Gist' | 'Repository', ParentType, ContextType>;
};

export type GQLPinnableItemConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PinnableItemConnection'] = GQLResolversParentTypes['PinnableItemConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PinnableItemEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PinnableItem']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPinnableItemEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PinnableItemEdge'] = GQLResolversParentTypes['PinnableItemEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['PinnableItem']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPinnedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PinnedEvent'] = GQLResolversParentTypes['PinnedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  issue?: Resolver<GQLResolversTypes['Issue'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPinnedIssueResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PinnedIssue'] = GQLResolversParentTypes['PinnedIssue']> = {
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  issue?: Resolver<GQLResolversTypes['Issue'], ParentType, ContextType>;
  pinnedBy?: Resolver<GQLResolversTypes['Actor'], ParentType, ContextType>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPinnedIssueConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PinnedIssueConnection'] = GQLResolversParentTypes['PinnedIssueConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PinnedIssueEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PinnedIssue']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPinnedIssueEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PinnedIssueEdge'] = GQLResolversParentTypes['PinnedIssueEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['PinnedIssue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export interface GQLPreciseDateTimeScalarConfig extends GraphQLScalarTypeConfig<GQLResolversTypes['PreciseDateTime'], any> {
  name: 'PreciseDateTime';
}

export type GQLPrivateRepositoryForkingDisableAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PrivateRepositoryForkingDisableAuditEntry'] = GQLResolversParentTypes['PrivateRepositoryForkingDisableAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPrivateRepositoryForkingEnableAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PrivateRepositoryForkingEnableAuditEntry'] = GQLResolversParentTypes['PrivateRepositoryForkingEnableAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLProfileItemShowcaseResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ProfileItemShowcase'] = GQLResolversParentTypes['ProfileItemShowcase']> = {
  hasPinnedItems?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  items?: Resolver<GQLResolversTypes['PinnableItemConnection'], ParentType, ContextType, RequireFields<GQLProfileItemShowcaseItemsArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLProfileOwnerResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ProfileOwner'] = GQLResolversParentTypes['ProfileOwner']> = {
  __resolveType: TypeResolveFn<'Organization' | 'User', ParentType, ContextType>;
  anyPinnableItems?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType, RequireFields<GQLProfileOwnerAnyPinnableItemsArgs, never>>;
  email?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  itemShowcase?: Resolver<GQLResolversTypes['ProfileItemShowcase'], ParentType, ContextType>;
  location?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  login?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  pinnableItems?: Resolver<GQLResolversTypes['PinnableItemConnection'], ParentType, ContextType, RequireFields<GQLProfileOwnerPinnableItemsArgs, never>>;
  pinnedItems?: Resolver<GQLResolversTypes['PinnableItemConnection'], ParentType, ContextType, RequireFields<GQLProfileOwnerPinnedItemsArgs, never>>;
  pinnedItemsRemaining?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  viewerCanChangePinnedItems?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  websiteUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
};

export type GQLProjectResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Project'] = GQLResolversParentTypes['Project']> = {
  body?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  bodyHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType>;
  closed?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  columns?: Resolver<GQLResolversTypes['ProjectColumnConnection'], ParentType, ContextType, RequireFields<GQLProjectColumnsArgs, never>>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  number?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  owner?: Resolver<GQLResolversTypes['ProjectOwner'], ParentType, ContextType>;
  pendingCards?: Resolver<GQLResolversTypes['ProjectCardConnection'], ParentType, ContextType, RequireFields<GQLProjectPendingCardsArgs, 'archivedStates'>>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  state?: Resolver<GQLResolversTypes['ProjectState'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLProjectCardResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ProjectCard'] = GQLResolversParentTypes['ProjectCard']> = {
  column?: Resolver<Maybe<GQLResolversTypes['ProjectColumn']>, ParentType, ContextType>;
  content?: Resolver<Maybe<GQLResolversTypes['ProjectCardItem']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isArchived?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  note?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<GQLResolversTypes['Project'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  state?: Resolver<Maybe<GQLResolversTypes['ProjectCardState']>, ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLProjectCardConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ProjectCardConnection'] = GQLResolversParentTypes['ProjectCardConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['ProjectCardEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['ProjectCard']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLProjectCardEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ProjectCardEdge'] = GQLResolversParentTypes['ProjectCardEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['ProjectCard']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLProjectCardItemResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ProjectCardItem'] = GQLResolversParentTypes['ProjectCardItem']> = {
  __resolveType: TypeResolveFn<'Issue' | 'PullRequest', ParentType, ContextType>;
};

export type GQLProjectColumnResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ProjectColumn'] = GQLResolversParentTypes['ProjectColumn']> = {
  cards?: Resolver<GQLResolversTypes['ProjectCardConnection'], ParentType, ContextType, RequireFields<GQLProjectColumnCardsArgs, 'archivedStates'>>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  project?: Resolver<GQLResolversTypes['Project'], ParentType, ContextType>;
  purpose?: Resolver<Maybe<GQLResolversTypes['ProjectColumnPurpose']>, ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLProjectColumnConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ProjectColumnConnection'] = GQLResolversParentTypes['ProjectColumnConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['ProjectColumnEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['ProjectColumn']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLProjectColumnEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ProjectColumnEdge'] = GQLResolversParentTypes['ProjectColumnEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['ProjectColumn']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLProjectConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ProjectConnection'] = GQLResolversParentTypes['ProjectConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['ProjectEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['Project']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLProjectEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ProjectEdge'] = GQLResolversParentTypes['ProjectEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLProjectOwnerResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ProjectOwner'] = GQLResolversParentTypes['ProjectOwner']> = {
  __resolveType: TypeResolveFn<'Organization' | 'Repository' | 'User', ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  project?: Resolver<Maybe<GQLResolversTypes['Project']>, ParentType, ContextType, RequireFields<GQLProjectOwnerProjectArgs, 'number'>>;
  projects?: Resolver<GQLResolversTypes['ProjectConnection'], ParentType, ContextType, RequireFields<GQLProjectOwnerProjectsArgs, never>>;
  projectsResourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  projectsUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  viewerCanCreateProjects?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
};

export type GQLPublicKeyResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PublicKey'] = GQLResolversParentTypes['PublicKey']> = {
  accessedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  createdAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  fingerprint?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isReadOnly?: Resolver<Maybe<GQLResolversTypes['Boolean']>, ParentType, ContextType>;
  key?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPublicKeyConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PublicKeyConnection'] = GQLResolversParentTypes['PublicKeyConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PublicKeyEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PublicKey']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPublicKeyEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PublicKeyEdge'] = GQLResolversParentTypes['PublicKeyEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['PublicKey']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequest'] = GQLResolversParentTypes['PullRequest']> = {
  activeLockReason?: Resolver<Maybe<GQLResolversTypes['LockReason']>, ParentType, ContextType>;
  additions?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  assignees?: Resolver<GQLResolversTypes['UserConnection'], ParentType, ContextType, RequireFields<GQLPullRequestAssigneesArgs, never>>;
  author?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<GQLResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>;
  baseRef?: Resolver<Maybe<GQLResolversTypes['Ref']>, ParentType, ContextType>;
  baseRefName?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  baseRefOid?: Resolver<GQLResolversTypes['GitObjectID'], ParentType, ContextType>;
  baseRepository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  body?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType>;
  bodyText?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  canBeRebased?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  changedFiles?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  checksResourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  checksUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  closed?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  closedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  comments?: Resolver<GQLResolversTypes['IssueCommentConnection'], ParentType, ContextType, RequireFields<GQLPullRequestCommentsArgs, never>>;
  commits?: Resolver<GQLResolversTypes['PullRequestCommitConnection'], ParentType, ContextType, RequireFields<GQLPullRequestCommitsArgs, never>>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  deletions?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  editor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  files?: Resolver<Maybe<GQLResolversTypes['PullRequestChangedFileConnection']>, ParentType, ContextType, RequireFields<GQLPullRequestFilesArgs, never>>;
  headRef?: Resolver<Maybe<GQLResolversTypes['Ref']>, ParentType, ContextType>;
  headRefName?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  headRefOid?: Resolver<GQLResolversTypes['GitObjectID'], ParentType, ContextType>;
  headRepository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  headRepositoryOwner?: Resolver<Maybe<GQLResolversTypes['RepositoryOwner']>, ParentType, ContextType>;
  hovercard?: Resolver<GQLResolversTypes['Hovercard'], ParentType, ContextType, RequireFields<GQLPullRequestHovercardArgs, 'includeNotificationContexts'>>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isCrossRepository?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isDraft?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  labels?: Resolver<Maybe<GQLResolversTypes['LabelConnection']>, ParentType, ContextType, RequireFields<GQLPullRequestLabelsArgs, 'orderBy'>>;
  lastEditedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  locked?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  maintainerCanModify?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  mergeCommit?: Resolver<Maybe<GQLResolversTypes['Commit']>, ParentType, ContextType>;
  mergeStateStatus?: Resolver<GQLResolversTypes['MergeStateStatus'], ParentType, ContextType>;
  mergeable?: Resolver<GQLResolversTypes['MergeableState'], ParentType, ContextType>;
  merged?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  mergedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  mergedBy?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  milestone?: Resolver<Maybe<GQLResolversTypes['Milestone']>, ParentType, ContextType>;
  number?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  participants?: Resolver<GQLResolversTypes['UserConnection'], ParentType, ContextType, RequireFields<GQLPullRequestParticipantsArgs, never>>;
  permalink?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  potentialMergeCommit?: Resolver<Maybe<GQLResolversTypes['Commit']>, ParentType, ContextType>;
  projectCards?: Resolver<GQLResolversTypes['ProjectCardConnection'], ParentType, ContextType, RequireFields<GQLPullRequestProjectCardsArgs, 'archivedStates'>>;
  publishedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<GQLResolversTypes['ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<GQLResolversTypes['ReactionConnection'], ParentType, ContextType, RequireFields<GQLPullRequestReactionsArgs, never>>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  revertResourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  revertUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  reviewDecision?: Resolver<Maybe<GQLResolversTypes['PullRequestReviewDecision']>, ParentType, ContextType>;
  reviewRequests?: Resolver<Maybe<GQLResolversTypes['ReviewRequestConnection']>, ParentType, ContextType, RequireFields<GQLPullRequestReviewRequestsArgs, never>>;
  reviewThreads?: Resolver<GQLResolversTypes['PullRequestReviewThreadConnection'], ParentType, ContextType, RequireFields<GQLPullRequestReviewThreadsArgs, never>>;
  reviews?: Resolver<Maybe<GQLResolversTypes['PullRequestReviewConnection']>, ParentType, ContextType, RequireFields<GQLPullRequestReviewsArgs, never>>;
  state?: Resolver<GQLResolversTypes['PullRequestState'], ParentType, ContextType>;
  suggestedReviewers?: Resolver<Array<Maybe<GQLResolversTypes['SuggestedReviewer']>>, ParentType, ContextType>;
  timeline?: Resolver<GQLResolversTypes['PullRequestTimelineConnection'], ParentType, ContextType, RequireFields<GQLPullRequestTimelineArgs, never>>;
  timelineItems?: Resolver<GQLResolversTypes['PullRequestTimelineItemsConnection'], ParentType, ContextType, RequireFields<GQLPullRequestTimelineItemsArgs, never>>;
  title?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<GQLResolversTypes['UserContentEditConnection']>, ParentType, ContextType, RequireFields<GQLPullRequestUserContentEditsArgs, never>>;
  viewerCanApplySuggestion?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<GQLResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<GQLResolversTypes['SubscriptionState']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestChangedFileResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestChangedFile'] = GQLResolversParentTypes['PullRequestChangedFile']> = {
  additions?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  deletions?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  path?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestChangedFileConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestChangedFileConnection'] = GQLResolversParentTypes['PullRequestChangedFileConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PullRequestChangedFileEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PullRequestChangedFile']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestChangedFileEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestChangedFileEdge'] = GQLResolversParentTypes['PullRequestChangedFileEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['PullRequestChangedFile']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestCommitResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestCommit'] = GQLResolversParentTypes['PullRequestCommit']> = {
  commit?: Resolver<GQLResolversTypes['Commit'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<GQLResolversTypes['PullRequest'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestCommitCommentThreadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestCommitCommentThread'] = GQLResolversParentTypes['PullRequestCommitCommentThread']> = {
  comments?: Resolver<GQLResolversTypes['CommitCommentConnection'], ParentType, ContextType, RequireFields<GQLPullRequestCommitCommentThreadCommentsArgs, never>>;
  commit?: Resolver<GQLResolversTypes['Commit'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  path?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  position?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  pullRequest?: Resolver<GQLResolversTypes['PullRequest'], ParentType, ContextType>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestCommitConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestCommitConnection'] = GQLResolversParentTypes['PullRequestCommitConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PullRequestCommitEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PullRequestCommit']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestCommitEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestCommitEdge'] = GQLResolversParentTypes['PullRequestCommitEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['PullRequestCommit']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestConnection'] = GQLResolversParentTypes['PullRequestConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PullRequestEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PullRequest']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestContributionsByRepositoryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestContributionsByRepository'] = GQLResolversParentTypes['PullRequestContributionsByRepository']> = {
  contributions?: Resolver<GQLResolversTypes['CreatedPullRequestContributionConnection'], ParentType, ContextType, RequireFields<GQLPullRequestContributionsByRepositoryContributionsArgs, 'orderBy'>>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestEdge'] = GQLResolversParentTypes['PullRequestEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestReviewResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestReview'] = GQLResolversParentTypes['PullRequestReview']> = {
  author?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<GQLResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType>;
  bodyText?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  comments?: Resolver<GQLResolversTypes['PullRequestReviewCommentConnection'], ParentType, ContextType, RequireFields<GQLPullRequestReviewCommentsArgs, never>>;
  commit?: Resolver<Maybe<GQLResolversTypes['Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  onBehalfOf?: Resolver<GQLResolversTypes['TeamConnection'], ParentType, ContextType, RequireFields<GQLPullRequestReviewOnBehalfOfArgs, never>>;
  publishedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  pullRequest?: Resolver<GQLResolversTypes['PullRequest'], ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<GQLResolversTypes['ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<GQLResolversTypes['ReactionConnection'], ParentType, ContextType, RequireFields<GQLPullRequestReviewReactionsArgs, never>>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  state?: Resolver<GQLResolversTypes['PullRequestReviewState'], ParentType, ContextType>;
  submittedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<GQLResolversTypes['UserContentEditConnection']>, ParentType, ContextType, RequireFields<GQLPullRequestReviewUserContentEditsArgs, never>>;
  viewerCanDelete?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<GQLResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestReviewCommentResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestReviewComment'] = GQLResolversParentTypes['PullRequestReviewComment']> = {
  author?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<GQLResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType>;
  bodyText?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  commit?: Resolver<Maybe<GQLResolversTypes['Commit']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  diffHunk?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  draftedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  editor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isMinimized?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  minimizedReason?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  originalCommit?: Resolver<Maybe<GQLResolversTypes['Commit']>, ParentType, ContextType>;
  originalPosition?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  outdated?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  path?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  position?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  pullRequest?: Resolver<GQLResolversTypes['PullRequest'], ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<GQLResolversTypes['PullRequestReview']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<GQLResolversTypes['ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<GQLResolversTypes['ReactionConnection'], ParentType, ContextType, RequireFields<GQLPullRequestReviewCommentReactionsArgs, never>>;
  replyTo?: Resolver<Maybe<GQLResolversTypes['PullRequestReviewComment']>, ParentType, ContextType>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  state?: Resolver<GQLResolversTypes['PullRequestReviewCommentState'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<GQLResolversTypes['UserContentEditConnection']>, ParentType, ContextType, RequireFields<GQLPullRequestReviewCommentUserContentEditsArgs, never>>;
  viewerCanDelete?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanMinimize?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<GQLResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestReviewCommentConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestReviewCommentConnection'] = GQLResolversParentTypes['PullRequestReviewCommentConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PullRequestReviewCommentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PullRequestReviewComment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestReviewCommentEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestReviewCommentEdge'] = GQLResolversParentTypes['PullRequestReviewCommentEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['PullRequestReviewComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestReviewConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestReviewConnection'] = GQLResolversParentTypes['PullRequestReviewConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PullRequestReviewEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PullRequestReview']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestReviewContributionsByRepositoryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestReviewContributionsByRepository'] = GQLResolversParentTypes['PullRequestReviewContributionsByRepository']> = {
  contributions?: Resolver<GQLResolversTypes['CreatedPullRequestReviewContributionConnection'], ParentType, ContextType, RequireFields<GQLPullRequestReviewContributionsByRepositoryContributionsArgs, 'orderBy'>>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestReviewEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestReviewEdge'] = GQLResolversParentTypes['PullRequestReviewEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['PullRequestReview']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestReviewThreadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestReviewThread'] = GQLResolversParentTypes['PullRequestReviewThread']> = {
  comments?: Resolver<GQLResolversTypes['PullRequestReviewCommentConnection'], ParentType, ContextType, RequireFields<GQLPullRequestReviewThreadCommentsArgs, never>>;
  diffSide?: Resolver<GQLResolversTypes['DiffSide'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isResolved?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  line?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  originalLine?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  originalStartLine?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  pullRequest?: Resolver<GQLResolversTypes['PullRequest'], ParentType, ContextType>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  resolvedBy?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  startDiffSide?: Resolver<Maybe<GQLResolversTypes['DiffSide']>, ParentType, ContextType>;
  startLine?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  viewerCanResolve?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUnresolve?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestReviewThreadConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestReviewThreadConnection'] = GQLResolversParentTypes['PullRequestReviewThreadConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PullRequestReviewThreadEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PullRequestReviewThread']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestReviewThreadEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestReviewThreadEdge'] = GQLResolversParentTypes['PullRequestReviewThreadEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['PullRequestReviewThread']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestRevisionMarkerResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestRevisionMarker'] = GQLResolversParentTypes['PullRequestRevisionMarker']> = {
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  lastSeenCommit?: Resolver<GQLResolversTypes['Commit'], ParentType, ContextType>;
  pullRequest?: Resolver<GQLResolversTypes['PullRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestTimelineConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestTimelineConnection'] = GQLResolversParentTypes['PullRequestTimelineConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PullRequestTimelineItemEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PullRequestTimelineItem']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestTimelineItemResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestTimelineItem'] = GQLResolversParentTypes['PullRequestTimelineItem']> = {
  __resolveType: TypeResolveFn<'AssignedEvent' | 'BaseRefForcePushedEvent' | 'ClosedEvent' | 'Commit' | 'CommitCommentThread' | 'CrossReferencedEvent' | 'DemilestonedEvent' | 'DeployedEvent' | 'DeploymentEnvironmentChangedEvent' | 'HeadRefDeletedEvent' | 'HeadRefForcePushedEvent' | 'HeadRefRestoredEvent' | 'IssueComment' | 'LabeledEvent' | 'LockedEvent' | 'MergedEvent' | 'MilestonedEvent' | 'PullRequestReview' | 'PullRequestReviewComment' | 'PullRequestReviewThread' | 'ReferencedEvent' | 'RenamedTitleEvent' | 'ReopenedEvent' | 'ReviewDismissedEvent' | 'ReviewRequestRemovedEvent' | 'ReviewRequestedEvent' | 'SubscribedEvent' | 'UnassignedEvent' | 'UnlabeledEvent' | 'UnlockedEvent' | 'UnsubscribedEvent' | 'UserBlockedEvent', ParentType, ContextType>;
};

export type GQLPullRequestTimelineItemEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestTimelineItemEdge'] = GQLResolversParentTypes['PullRequestTimelineItemEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['PullRequestTimelineItem']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestTimelineItemsResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestTimelineItems'] = GQLResolversParentTypes['PullRequestTimelineItems']> = {
  __resolveType: TypeResolveFn<'AddedToProjectEvent' | 'AssignedEvent' | 'AutomaticBaseChangeFailedEvent' | 'AutomaticBaseChangeSucceededEvent' | 'BaseRefChangedEvent' | 'BaseRefForcePushedEvent' | 'ClosedEvent' | 'CommentDeletedEvent' | 'ConnectedEvent' | 'ConvertToDraftEvent' | 'ConvertedNoteToIssueEvent' | 'CrossReferencedEvent' | 'DemilestonedEvent' | 'DeployedEvent' | 'DeploymentEnvironmentChangedEvent' | 'DisconnectedEvent' | 'HeadRefDeletedEvent' | 'HeadRefForcePushedEvent' | 'HeadRefRestoredEvent' | 'IssueComment' | 'LabeledEvent' | 'LockedEvent' | 'MarkedAsDuplicateEvent' | 'MentionedEvent' | 'MergedEvent' | 'MilestonedEvent' | 'MovedColumnsInProjectEvent' | 'PinnedEvent' | 'PullRequestCommit' | 'PullRequestCommitCommentThread' | 'PullRequestReview' | 'PullRequestReviewThread' | 'PullRequestRevisionMarker' | 'ReadyForReviewEvent' | 'ReferencedEvent' | 'RemovedFromProjectEvent' | 'RenamedTitleEvent' | 'ReopenedEvent' | 'ReviewDismissedEvent' | 'ReviewRequestRemovedEvent' | 'ReviewRequestedEvent' | 'SubscribedEvent' | 'TransferredEvent' | 'UnassignedEvent' | 'UnlabeledEvent' | 'UnlockedEvent' | 'UnmarkedAsDuplicateEvent' | 'UnpinnedEvent' | 'UnsubscribedEvent' | 'UserBlockedEvent', ParentType, ContextType>;
};

export type GQLPullRequestTimelineItemsConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestTimelineItemsConnection'] = GQLResolversParentTypes['PullRequestTimelineItemsConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PullRequestTimelineItemsEdge']>>>, ParentType, ContextType>;
  filteredCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PullRequestTimelineItems']>>>, ParentType, ContextType>;
  pageCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPullRequestTimelineItemsEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PullRequestTimelineItemsEdge'] = GQLResolversParentTypes['PullRequestTimelineItemsEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['PullRequestTimelineItems']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPushResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Push'] = GQLResolversParentTypes['Push']> = {
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  nextSha?: Resolver<Maybe<GQLResolversTypes['GitObjectID']>, ParentType, ContextType>;
  permalink?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  previousSha?: Resolver<Maybe<GQLResolversTypes['GitObjectID']>, ParentType, ContextType>;
  pusher?: Resolver<GQLResolversTypes['User'], ParentType, ContextType>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPushAllowanceResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PushAllowance'] = GQLResolversParentTypes['PushAllowance']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['PushAllowanceActor']>, ParentType, ContextType>;
  branchProtectionRule?: Resolver<Maybe<GQLResolversTypes['BranchProtectionRule']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPushAllowanceActorResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PushAllowanceActor'] = GQLResolversParentTypes['PushAllowanceActor']> = {
  __resolveType: TypeResolveFn<'App' | 'Team' | 'User', ParentType, ContextType>;
};

export type GQLPushAllowanceConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PushAllowanceConnection'] = GQLResolversParentTypes['PushAllowanceConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PushAllowanceEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['PushAllowance']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLPushAllowanceEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['PushAllowanceEdge'] = GQLResolversParentTypes['PushAllowanceEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['PushAllowance']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLQueryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Query'] = GQLResolversParentTypes['Query']> = {
  codeOfConduct?: Resolver<Maybe<GQLResolversTypes['CodeOfConduct']>, ParentType, ContextType, RequireFields<GQLQueryCodeOfConductArgs, 'key'>>;
  codesOfConduct?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['CodeOfConduct']>>>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<GQLResolversTypes['Enterprise']>, ParentType, ContextType, RequireFields<GQLQueryEnterpriseArgs, 'slug'>>;
  enterpriseAdministratorInvitation?: Resolver<Maybe<GQLResolversTypes['EnterpriseAdministratorInvitation']>, ParentType, ContextType, RequireFields<GQLQueryEnterpriseAdministratorInvitationArgs, 'enterpriseSlug' | 'role' | 'userLogin'>>;
  enterpriseAdministratorInvitationByToken?: Resolver<Maybe<GQLResolversTypes['EnterpriseAdministratorInvitation']>, ParentType, ContextType, RequireFields<GQLQueryEnterpriseAdministratorInvitationByTokenArgs, 'invitationToken'>>;
  license?: Resolver<Maybe<GQLResolversTypes['License']>, ParentType, ContextType, RequireFields<GQLQueryLicenseArgs, 'key'>>;
  licenses?: Resolver<Array<Maybe<GQLResolversTypes['License']>>, ParentType, ContextType>;
  marketplaceCategories?: Resolver<Array<GQLResolversTypes['MarketplaceCategory']>, ParentType, ContextType, RequireFields<GQLQueryMarketplaceCategoriesArgs, never>>;
  marketplaceCategory?: Resolver<Maybe<GQLResolversTypes['MarketplaceCategory']>, ParentType, ContextType, RequireFields<GQLQueryMarketplaceCategoryArgs, 'slug'>>;
  marketplaceListing?: Resolver<Maybe<GQLResolversTypes['MarketplaceListing']>, ParentType, ContextType, RequireFields<GQLQueryMarketplaceListingArgs, 'slug'>>;
  marketplaceListings?: Resolver<GQLResolversTypes['MarketplaceListingConnection'], ParentType, ContextType, RequireFields<GQLQueryMarketplaceListingsArgs, 'primaryCategoryOnly' | 'withFreeTrialsOnly'>>;
  meta?: Resolver<GQLResolversTypes['GitHubMetadata'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['Node']>, ParentType, ContextType, RequireFields<GQLQueryNodeArgs, 'id'>>;
  nodes?: Resolver<Array<Maybe<GQLResolversTypes['Node']>>, ParentType, ContextType, RequireFields<GQLQueryNodesArgs, 'ids'>>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType, RequireFields<GQLQueryOrganizationArgs, 'login'>>;
  rateLimit?: Resolver<Maybe<GQLResolversTypes['RateLimit']>, ParentType, ContextType, RequireFields<GQLQueryRateLimitArgs, 'dryRun'>>;
  relay?: Resolver<GQLResolversTypes['Query'], ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType, RequireFields<GQLQueryRepositoryArgs, 'name' | 'owner'>>;
  repositoryOwner?: Resolver<Maybe<GQLResolversTypes['RepositoryOwner']>, ParentType, ContextType, RequireFields<GQLQueryRepositoryOwnerArgs, 'login'>>;
  resource?: Resolver<Maybe<GQLResolversTypes['UniformResourceLocatable']>, ParentType, ContextType, RequireFields<GQLQueryResourceArgs, 'url'>>;
  search?: Resolver<GQLResolversTypes['SearchResultItemConnection'], ParentType, ContextType, RequireFields<GQLQuerySearchArgs, 'query' | 'type'>>;
  securityAdvisories?: Resolver<GQLResolversTypes['SecurityAdvisoryConnection'], ParentType, ContextType, RequireFields<GQLQuerySecurityAdvisoriesArgs, 'orderBy'>>;
  securityAdvisory?: Resolver<Maybe<GQLResolversTypes['SecurityAdvisory']>, ParentType, ContextType, RequireFields<GQLQuerySecurityAdvisoryArgs, 'ghsaId'>>;
  securityVulnerabilities?: Resolver<GQLResolversTypes['SecurityVulnerabilityConnection'], ParentType, ContextType, RequireFields<GQLQuerySecurityVulnerabilitiesArgs, 'orderBy'>>;
  sponsorsListing?: Resolver<Maybe<GQLResolversTypes['SponsorsListing']>, ParentType, ContextType, RequireFields<GQLQuerySponsorsListingArgs, 'slug'>>;
  topic?: Resolver<Maybe<GQLResolversTypes['Topic']>, ParentType, ContextType, RequireFields<GQLQueryTopicArgs, 'name'>>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType, RequireFields<GQLQueryUserArgs, 'login'>>;
  viewer?: Resolver<GQLResolversTypes['User'], ParentType, ContextType>;
};

export type GQLRateLimitResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RateLimit'] = GQLResolversParentTypes['RateLimit']> = {
  cost?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  limit?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  nodeCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  remaining?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  resetAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReactableResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Reactable'] = GQLResolversParentTypes['Reactable']> = {
  __resolveType: TypeResolveFn<'CommitComment' | 'Issue' | 'IssueComment' | 'PullRequest' | 'PullRequestReview' | 'PullRequestReviewComment' | 'TeamDiscussion' | 'TeamDiscussionComment', ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<GQLResolversTypes['ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<GQLResolversTypes['ReactionConnection'], ParentType, ContextType, RequireFields<GQLReactableReactionsArgs, never>>;
  viewerCanReact?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
};

export type GQLReactingUserConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReactingUserConnection'] = GQLResolversParentTypes['ReactingUserConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['ReactingUserEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReactingUserEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReactingUserEdge'] = GQLResolversParentTypes['ReactingUserEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<GQLResolversTypes['User'], ParentType, ContextType>;
  reactedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReactionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Reaction'] = GQLResolversParentTypes['Reaction']> = {
  content?: Resolver<GQLResolversTypes['ReactionContent'], ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  reactable?: Resolver<GQLResolversTypes['Reactable'], ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReactionConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReactionConnection'] = GQLResolversParentTypes['ReactionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['ReactionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['Reaction']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  viewerHasReacted?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReactionEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReactionEdge'] = GQLResolversParentTypes['ReactionEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['Reaction']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReactionGroupResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReactionGroup'] = GQLResolversParentTypes['ReactionGroup']> = {
  content?: Resolver<GQLResolversTypes['ReactionContent'], ParentType, ContextType>;
  createdAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  subject?: Resolver<GQLResolversTypes['Reactable'], ParentType, ContextType>;
  users?: Resolver<GQLResolversTypes['ReactingUserConnection'], ParentType, ContextType, RequireFields<GQLReactionGroupUsersArgs, never>>;
  viewerHasReacted?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReadyForReviewEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReadyForReviewEvent'] = GQLResolversParentTypes['ReadyForReviewEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<GQLResolversTypes['PullRequest'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRefResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Ref'] = GQLResolversParentTypes['Ref']> = {
  associatedPullRequests?: Resolver<GQLResolversTypes['PullRequestConnection'], ParentType, ContextType, RequireFields<GQLRefAssociatedPullRequestsArgs, never>>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  prefix?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  target?: Resolver<GQLResolversTypes['GitObject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRefConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RefConnection'] = GQLResolversParentTypes['RefConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['RefEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['Ref']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRefEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RefEdge'] = GQLResolversParentTypes['RefEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReferencedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReferencedEvent'] = GQLResolversParentTypes['ReferencedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  commit?: Resolver<Maybe<GQLResolversTypes['Commit']>, ParentType, ContextType>;
  commitRepository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isCrossRepository?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isDirectReference?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  subject?: Resolver<GQLResolversTypes['ReferencedSubject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReferencedSubjectResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReferencedSubject'] = GQLResolversParentTypes['ReferencedSubject']> = {
  __resolveType: TypeResolveFn<'Issue' | 'PullRequest', ParentType, ContextType>;
};

export type GQLRegenerateEnterpriseIdentityProviderRecoveryCodesPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RegenerateEnterpriseIdentityProviderRecoveryCodesPayload'] = GQLResolversParentTypes['RegenerateEnterpriseIdentityProviderRecoveryCodesPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  identityProvider?: Resolver<Maybe<GQLResolversTypes['EnterpriseIdentityProvider']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRegistryPackageResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RegistryPackage'] = GQLResolversParentTypes['RegistryPackage']> = {
  color?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  latestVersion?: Resolver<Maybe<GQLResolversTypes['RegistryPackageVersion']>, ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  nameWithOwner?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  packageFileByGuid?: Resolver<Maybe<GQLResolversTypes['RegistryPackageFile']>, ParentType, ContextType, RequireFields<GQLRegistryPackagePackageFileByGuidArgs, 'guid'>>;
  packageFileBySha256?: Resolver<Maybe<GQLResolversTypes['RegistryPackageFile']>, ParentType, ContextType, RequireFields<GQLRegistryPackagePackageFileBySha256Args, 'sha256'>>;
  packageType?: Resolver<GQLResolversTypes['RegistryPackageType'], ParentType, ContextType>;
  preReleaseVersions?: Resolver<Maybe<GQLResolversTypes['RegistryPackageVersionConnection']>, ParentType, ContextType, RequireFields<GQLRegistryPackagePreReleaseVersionsArgs, never>>;
  registryPackageType?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  statistics?: Resolver<Maybe<GQLResolversTypes['RegistryPackageStatistics']>, ParentType, ContextType>;
  tags?: Resolver<GQLResolversTypes['RegistryPackageTagConnection'], ParentType, ContextType, RequireFields<GQLRegistryPackageTagsArgs, never>>;
  topics?: Resolver<Maybe<GQLResolversTypes['TopicConnection']>, ParentType, ContextType, RequireFields<GQLRegistryPackageTopicsArgs, never>>;
  version?: Resolver<Maybe<GQLResolversTypes['RegistryPackageVersion']>, ParentType, ContextType, RequireFields<GQLRegistryPackageVersionArgs, 'version'>>;
  versionByPlatform?: Resolver<Maybe<GQLResolversTypes['RegistryPackageVersion']>, ParentType, ContextType, RequireFields<GQLRegistryPackageVersionByPlatformArgs, 'platform' | 'version'>>;
  versionBySha256?: Resolver<Maybe<GQLResolversTypes['RegistryPackageVersion']>, ParentType, ContextType, RequireFields<GQLRegistryPackageVersionBySha256Args, 'sha256'>>;
  versions?: Resolver<GQLResolversTypes['RegistryPackageVersionConnection'], ParentType, ContextType, RequireFields<GQLRegistryPackageVersionsArgs, never>>;
  versionsByMetadatum?: Resolver<Maybe<GQLResolversTypes['RegistryPackageVersionConnection']>, ParentType, ContextType, RequireFields<GQLRegistryPackageVersionsByMetadatumArgs, 'metadatum'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRegistryPackageConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RegistryPackageConnection'] = GQLResolversParentTypes['RegistryPackageConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['RegistryPackageEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['RegistryPackage']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRegistryPackageDependencyResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RegistryPackageDependency'] = GQLResolversParentTypes['RegistryPackageDependency']> = {
  dependencyType?: Resolver<GQLResolversTypes['RegistryPackageDependencyType'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  version?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRegistryPackageDependencyConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RegistryPackageDependencyConnection'] = GQLResolversParentTypes['RegistryPackageDependencyConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['RegistryPackageDependencyEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['RegistryPackageDependency']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRegistryPackageDependencyEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RegistryPackageDependencyEdge'] = GQLResolversParentTypes['RegistryPackageDependencyEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['RegistryPackageDependency']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRegistryPackageEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RegistryPackageEdge'] = GQLResolversParentTypes['RegistryPackageEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['RegistryPackage']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRegistryPackageFileResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RegistryPackageFile'] = GQLResolversParentTypes['RegistryPackageFile']> = {
  guid?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  md5?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  metadataUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  packageVersion?: Resolver<GQLResolversTypes['RegistryPackageVersion'], ParentType, ContextType>;
  sha1?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  sha256?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  size?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRegistryPackageFileConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RegistryPackageFileConnection'] = GQLResolversParentTypes['RegistryPackageFileConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['RegistryPackageFileEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['RegistryPackageFile']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRegistryPackageFileEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RegistryPackageFileEdge'] = GQLResolversParentTypes['RegistryPackageFileEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['RegistryPackageFile']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRegistryPackageOwnerResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RegistryPackageOwner'] = GQLResolversParentTypes['RegistryPackageOwner']> = {
  __resolveType: TypeResolveFn<'Organization' | 'Repository' | 'User', ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  registryPackages?: Resolver<GQLResolversTypes['RegistryPackageConnection'], ParentType, ContextType, RequireFields<GQLRegistryPackageOwnerRegistryPackagesArgs, 'publicOnly'>>;
};

export type GQLRegistryPackageSearchResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RegistryPackageSearch'] = GQLResolversParentTypes['RegistryPackageSearch']> = {
  __resolveType: TypeResolveFn<'Organization' | 'Repository' | 'User', ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  registryPackagesForQuery?: Resolver<GQLResolversTypes['RegistryPackageConnection'], ParentType, ContextType, RequireFields<GQLRegistryPackageSearchRegistryPackagesForQueryArgs, never>>;
};

export type GQLRegistryPackageStatisticsResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RegistryPackageStatistics'] = GQLResolversParentTypes['RegistryPackageStatistics']> = {
  downloadsThisMonth?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  downloadsThisWeek?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  downloadsThisYear?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  downloadsToday?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  downloadsTotalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRegistryPackageTagResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RegistryPackageTag'] = GQLResolversParentTypes['RegistryPackageTag']> = {
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  version?: Resolver<Maybe<GQLResolversTypes['RegistryPackageVersion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRegistryPackageTagConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RegistryPackageTagConnection'] = GQLResolversParentTypes['RegistryPackageTagConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['RegistryPackageTagEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['RegistryPackageTag']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRegistryPackageTagEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RegistryPackageTagEdge'] = GQLResolversParentTypes['RegistryPackageTagEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['RegistryPackageTag']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRegistryPackageVersionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RegistryPackageVersion'] = GQLResolversParentTypes['RegistryPackageVersion']> = {
  deleted?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  dependencies?: Resolver<GQLResolversTypes['RegistryPackageDependencyConnection'], ParentType, ContextType, RequireFields<GQLRegistryPackageVersionDependenciesArgs, never>>;
  fileByName?: Resolver<Maybe<GQLResolversTypes['RegistryPackageFile']>, ParentType, ContextType, RequireFields<GQLRegistryPackageVersionFileByNameArgs, 'filename'>>;
  files?: Resolver<GQLResolversTypes['RegistryPackageFileConnection'], ParentType, ContextType, RequireFields<GQLRegistryPackageVersionFilesArgs, never>>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  installationCommand?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  manifest?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  platform?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  preRelease?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  readme?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  readmeHtml?: Resolver<Maybe<GQLResolversTypes['HTML']>, ParentType, ContextType>;
  registryPackage?: Resolver<Maybe<GQLResolversTypes['RegistryPackage']>, ParentType, ContextType>;
  release?: Resolver<Maybe<GQLResolversTypes['Release']>, ParentType, ContextType>;
  sha256?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  size?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  statistics?: Resolver<Maybe<GQLResolversTypes['RegistryPackageVersionStatistics']>, ParentType, ContextType>;
  summary?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  version?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  viewerCanEdit?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRegistryPackageVersionConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RegistryPackageVersionConnection'] = GQLResolversParentTypes['RegistryPackageVersionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['RegistryPackageVersionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['RegistryPackageVersion']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRegistryPackageVersionEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RegistryPackageVersionEdge'] = GQLResolversParentTypes['RegistryPackageVersionEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['RegistryPackageVersion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRegistryPackageVersionStatisticsResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RegistryPackageVersionStatistics'] = GQLResolversParentTypes['RegistryPackageVersionStatistics']> = {
  downloadsThisMonth?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  downloadsThisWeek?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  downloadsThisYear?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  downloadsToday?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  downloadsTotalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReleaseResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Release'] = GQLResolversParentTypes['Release']> = {
  author?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  descriptionHTML?: Resolver<Maybe<GQLResolversTypes['HTML']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isDraft?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isPrerelease?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  releaseAssets?: Resolver<GQLResolversTypes['ReleaseAssetConnection'], ParentType, ContextType, RequireFields<GQLReleaseReleaseAssetsArgs, never>>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  shortDescriptionHTML?: Resolver<Maybe<GQLResolversTypes['HTML']>, ParentType, ContextType, RequireFields<GQLReleaseShortDescriptionHtmlArgs, 'limit'>>;
  tag?: Resolver<Maybe<GQLResolversTypes['Ref']>, ParentType, ContextType>;
  tagName?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReleaseAssetResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReleaseAsset'] = GQLResolversParentTypes['ReleaseAsset']> = {
  contentType?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  downloadCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  downloadUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  release?: Resolver<Maybe<GQLResolversTypes['Release']>, ParentType, ContextType>;
  size?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  uploadedBy?: Resolver<GQLResolversTypes['User'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReleaseAssetConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReleaseAssetConnection'] = GQLResolversParentTypes['ReleaseAssetConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['ReleaseAssetEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['ReleaseAsset']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReleaseAssetEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReleaseAssetEdge'] = GQLResolversParentTypes['ReleaseAssetEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['ReleaseAsset']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReleaseConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReleaseConnection'] = GQLResolversParentTypes['ReleaseConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['ReleaseEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['Release']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReleaseEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReleaseEdge'] = GQLResolversParentTypes['ReleaseEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['Release']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRemoveAssigneesFromAssignablePayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RemoveAssigneesFromAssignablePayload'] = GQLResolversParentTypes['RemoveAssigneesFromAssignablePayload']> = {
  assignable?: Resolver<Maybe<GQLResolversTypes['Assignable']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRemoveEnterpriseAdminPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RemoveEnterpriseAdminPayload'] = GQLResolversParentTypes['RemoveEnterpriseAdminPayload']> = {
  admin?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<GQLResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  viewer?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRemoveEnterpriseIdentityProviderPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RemoveEnterpriseIdentityProviderPayload'] = GQLResolversParentTypes['RemoveEnterpriseIdentityProviderPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  identityProvider?: Resolver<Maybe<GQLResolversTypes['EnterpriseIdentityProvider']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRemoveEnterpriseOrganizationPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RemoveEnterpriseOrganizationPayload'] = GQLResolversParentTypes['RemoveEnterpriseOrganizationPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<GQLResolversTypes['Enterprise']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  viewer?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRemoveLabelsFromLabelablePayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RemoveLabelsFromLabelablePayload'] = GQLResolversParentTypes['RemoveLabelsFromLabelablePayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  labelable?: Resolver<Maybe<GQLResolversTypes['Labelable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRemoveOutsideCollaboratorPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RemoveOutsideCollaboratorPayload'] = GQLResolversParentTypes['RemoveOutsideCollaboratorPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  removedUser?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRemoveReactionPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RemoveReactionPayload'] = GQLResolversParentTypes['RemoveReactionPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  reaction?: Resolver<Maybe<GQLResolversTypes['Reaction']>, ParentType, ContextType>;
  subject?: Resolver<Maybe<GQLResolversTypes['Reactable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRemoveStarPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RemoveStarPayload'] = GQLResolversParentTypes['RemoveStarPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  starrable?: Resolver<Maybe<GQLResolversTypes['Starrable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRemovedFromProjectEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RemovedFromProjectEvent'] = GQLResolversParentTypes['RemovedFromProjectEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  project?: Resolver<Maybe<GQLResolversTypes['Project']>, ParentType, ContextType>;
  projectColumnName?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRenamedTitleEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RenamedTitleEvent'] = GQLResolversParentTypes['RenamedTitleEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  currentTitle?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  previousTitle?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  subject?: Resolver<GQLResolversTypes['RenamedTitleSubject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRenamedTitleSubjectResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RenamedTitleSubject'] = GQLResolversParentTypes['RenamedTitleSubject']> = {
  __resolveType: TypeResolveFn<'Issue' | 'PullRequest', ParentType, ContextType>;
};

export type GQLReopenIssuePayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReopenIssuePayload'] = GQLResolversParentTypes['ReopenIssuePayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<GQLResolversTypes['Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReopenPullRequestPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReopenPullRequestPayload'] = GQLResolversParentTypes['ReopenPullRequestPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<GQLResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReopenedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReopenedEvent'] = GQLResolversParentTypes['ReopenedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  closable?: Resolver<GQLResolversTypes['Closable'], ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepoAccessAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepoAccessAuditEntry'] = GQLResolversParentTypes['RepoAccessAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<GQLResolversTypes['RepoAccessAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepoAddMemberAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepoAddMemberAuditEntry'] = GQLResolversParentTypes['RepoAddMemberAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<GQLResolversTypes['RepoAddMemberAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepoAddTopicAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepoAddTopicAuditEntry'] = GQLResolversParentTypes['RepoAddTopicAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  topic?: Resolver<Maybe<GQLResolversTypes['Topic']>, ParentType, ContextType>;
  topicName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepoArchivedAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepoArchivedAuditEntry'] = GQLResolversParentTypes['RepoArchivedAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<GQLResolversTypes['RepoArchivedAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepoChangeMergeSettingAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepoChangeMergeSettingAuditEntry'] = GQLResolversParentTypes['RepoChangeMergeSettingAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isEnabled?: Resolver<Maybe<GQLResolversTypes['Boolean']>, ParentType, ContextType>;
  mergeType?: Resolver<Maybe<GQLResolversTypes['RepoChangeMergeSettingAuditEntryMergeType']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepoConfigDisableAnonymousGitAccessAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepoConfigDisableAnonymousGitAccessAuditEntry'] = GQLResolversParentTypes['RepoConfigDisableAnonymousGitAccessAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepoConfigDisableCollaboratorsOnlyAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepoConfigDisableCollaboratorsOnlyAuditEntry'] = GQLResolversParentTypes['RepoConfigDisableCollaboratorsOnlyAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepoConfigDisableContributorsOnlyAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepoConfigDisableContributorsOnlyAuditEntry'] = GQLResolversParentTypes['RepoConfigDisableContributorsOnlyAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepoConfigDisableSockpuppetDisallowedAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepoConfigDisableSockpuppetDisallowedAuditEntry'] = GQLResolversParentTypes['RepoConfigDisableSockpuppetDisallowedAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepoConfigEnableAnonymousGitAccessAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepoConfigEnableAnonymousGitAccessAuditEntry'] = GQLResolversParentTypes['RepoConfigEnableAnonymousGitAccessAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepoConfigEnableCollaboratorsOnlyAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepoConfigEnableCollaboratorsOnlyAuditEntry'] = GQLResolversParentTypes['RepoConfigEnableCollaboratorsOnlyAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepoConfigEnableContributorsOnlyAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepoConfigEnableContributorsOnlyAuditEntry'] = GQLResolversParentTypes['RepoConfigEnableContributorsOnlyAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepoConfigEnableSockpuppetDisallowedAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepoConfigEnableSockpuppetDisallowedAuditEntry'] = GQLResolversParentTypes['RepoConfigEnableSockpuppetDisallowedAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepoConfigLockAnonymousGitAccessAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepoConfigLockAnonymousGitAccessAuditEntry'] = GQLResolversParentTypes['RepoConfigLockAnonymousGitAccessAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepoConfigUnlockAnonymousGitAccessAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepoConfigUnlockAnonymousGitAccessAuditEntry'] = GQLResolversParentTypes['RepoConfigUnlockAnonymousGitAccessAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepoCreateAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepoCreateAuditEntry'] = GQLResolversParentTypes['RepoCreateAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  forkParentName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  forkSourceName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<GQLResolversTypes['RepoCreateAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepoDestroyAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepoDestroyAuditEntry'] = GQLResolversParentTypes['RepoDestroyAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<GQLResolversTypes['RepoDestroyAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepoRemoveMemberAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepoRemoveMemberAuditEntry'] = GQLResolversParentTypes['RepoRemoveMemberAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  visibility?: Resolver<Maybe<GQLResolversTypes['RepoRemoveMemberAuditEntryVisibility']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepoRemoveTopicAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepoRemoveTopicAuditEntry'] = GQLResolversParentTypes['RepoRemoveTopicAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  topic?: Resolver<Maybe<GQLResolversTypes['Topic']>, ParentType, ContextType>;
  topicName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepositoryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Repository'] = GQLResolversParentTypes['Repository']> = {
  assignableUsers?: Resolver<GQLResolversTypes['UserConnection'], ParentType, ContextType, RequireFields<GQLRepositoryAssignableUsersArgs, never>>;
  branchProtectionRules?: Resolver<GQLResolversTypes['BranchProtectionRuleConnection'], ParentType, ContextType, RequireFields<GQLRepositoryBranchProtectionRulesArgs, never>>;
  codeOfConduct?: Resolver<Maybe<GQLResolversTypes['CodeOfConduct']>, ParentType, ContextType>;
  collaborators?: Resolver<Maybe<GQLResolversTypes['RepositoryCollaboratorConnection']>, ParentType, ContextType, RequireFields<GQLRepositoryCollaboratorsArgs, never>>;
  commitComments?: Resolver<GQLResolversTypes['CommitCommentConnection'], ParentType, ContextType, RequireFields<GQLRepositoryCommitCommentsArgs, never>>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  defaultBranchRef?: Resolver<Maybe<GQLResolversTypes['Ref']>, ParentType, ContextType>;
  deleteBranchOnMerge?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  dependencyGraphManifests?: Resolver<Maybe<GQLResolversTypes['DependencyGraphManifestConnection']>, ParentType, ContextType, RequireFields<GQLRepositoryDependencyGraphManifestsArgs, never>>;
  deployKeys?: Resolver<GQLResolversTypes['DeployKeyConnection'], ParentType, ContextType, RequireFields<GQLRepositoryDeployKeysArgs, never>>;
  deployments?: Resolver<GQLResolversTypes['DeploymentConnection'], ParentType, ContextType, RequireFields<GQLRepositoryDeploymentsArgs, 'orderBy'>>;
  description?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  descriptionHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType>;
  diskUsage?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  forkCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  forks?: Resolver<GQLResolversTypes['RepositoryConnection'], ParentType, ContextType, RequireFields<GQLRepositoryForksArgs, 'ownerAffiliations'>>;
  fundingLinks?: Resolver<Array<GQLResolversTypes['FundingLink']>, ParentType, ContextType>;
  hasIssuesEnabled?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  hasProjectsEnabled?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  hasWikiEnabled?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  homepageUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isArchived?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isDisabled?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isFork?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isLocked?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isMirror?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isPrivate?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isTemplate?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  issue?: Resolver<Maybe<GQLResolversTypes['Issue']>, ParentType, ContextType, RequireFields<GQLRepositoryIssueArgs, 'number'>>;
  issueOrPullRequest?: Resolver<Maybe<GQLResolversTypes['IssueOrPullRequest']>, ParentType, ContextType, RequireFields<GQLRepositoryIssueOrPullRequestArgs, 'number'>>;
  issues?: Resolver<GQLResolversTypes['IssueConnection'], ParentType, ContextType, RequireFields<GQLRepositoryIssuesArgs, never>>;
  label?: Resolver<Maybe<GQLResolversTypes['Label']>, ParentType, ContextType, RequireFields<GQLRepositoryLabelArgs, 'name'>>;
  labels?: Resolver<Maybe<GQLResolversTypes['LabelConnection']>, ParentType, ContextType, RequireFields<GQLRepositoryLabelsArgs, 'orderBy'>>;
  languages?: Resolver<Maybe<GQLResolversTypes['LanguageConnection']>, ParentType, ContextType, RequireFields<GQLRepositoryLanguagesArgs, never>>;
  licenseInfo?: Resolver<Maybe<GQLResolversTypes['License']>, ParentType, ContextType>;
  lockReason?: Resolver<Maybe<GQLResolversTypes['RepositoryLockReason']>, ParentType, ContextType>;
  mentionableUsers?: Resolver<GQLResolversTypes['UserConnection'], ParentType, ContextType, RequireFields<GQLRepositoryMentionableUsersArgs, never>>;
  mergeCommitAllowed?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  milestone?: Resolver<Maybe<GQLResolversTypes['Milestone']>, ParentType, ContextType, RequireFields<GQLRepositoryMilestoneArgs, 'number'>>;
  milestones?: Resolver<Maybe<GQLResolversTypes['MilestoneConnection']>, ParentType, ContextType, RequireFields<GQLRepositoryMilestonesArgs, never>>;
  mirrorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  nameWithOwner?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  object?: Resolver<Maybe<GQLResolversTypes['GitObject']>, ParentType, ContextType, RequireFields<GQLRepositoryObjectArgs, never>>;
  openGraphImageUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  owner?: Resolver<GQLResolversTypes['RepositoryOwner'], ParentType, ContextType>;
  packages?: Resolver<GQLResolversTypes['PackageConnection'], ParentType, ContextType, RequireFields<GQLRepositoryPackagesArgs, 'orderBy'>>;
  parent?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  pinnedIssues?: Resolver<Maybe<GQLResolversTypes['PinnedIssueConnection']>, ParentType, ContextType, RequireFields<GQLRepositoryPinnedIssuesArgs, never>>;
  primaryLanguage?: Resolver<Maybe<GQLResolversTypes['Language']>, ParentType, ContextType>;
  project?: Resolver<Maybe<GQLResolversTypes['Project']>, ParentType, ContextType, RequireFields<GQLRepositoryProjectArgs, 'number'>>;
  projects?: Resolver<GQLResolversTypes['ProjectConnection'], ParentType, ContextType, RequireFields<GQLRepositoryProjectsArgs, never>>;
  projectsResourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  projectsUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<GQLResolversTypes['PullRequest']>, ParentType, ContextType, RequireFields<GQLRepositoryPullRequestArgs, 'number'>>;
  pullRequests?: Resolver<GQLResolversTypes['PullRequestConnection'], ParentType, ContextType, RequireFields<GQLRepositoryPullRequestsArgs, never>>;
  pushedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  rebaseMergeAllowed?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  ref?: Resolver<Maybe<GQLResolversTypes['Ref']>, ParentType, ContextType, RequireFields<GQLRepositoryRefArgs, 'qualifiedName'>>;
  refs?: Resolver<Maybe<GQLResolversTypes['RefConnection']>, ParentType, ContextType, RequireFields<GQLRepositoryRefsArgs, 'refPrefix'>>;
  registryPackages?: Resolver<GQLResolversTypes['RegistryPackageConnection'], ParentType, ContextType, RequireFields<GQLRepositoryRegistryPackagesArgs, 'publicOnly'>>;
  registryPackagesForQuery?: Resolver<GQLResolversTypes['RegistryPackageConnection'], ParentType, ContextType, RequireFields<GQLRepositoryRegistryPackagesForQueryArgs, never>>;
  release?: Resolver<Maybe<GQLResolversTypes['Release']>, ParentType, ContextType, RequireFields<GQLRepositoryReleaseArgs, 'tagName'>>;
  releases?: Resolver<GQLResolversTypes['ReleaseConnection'], ParentType, ContextType, RequireFields<GQLRepositoryReleasesArgs, never>>;
  repositoryTopics?: Resolver<GQLResolversTypes['RepositoryTopicConnection'], ParentType, ContextType, RequireFields<GQLRepositoryRepositoryTopicsArgs, never>>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  shortDescriptionHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType, RequireFields<GQLRepositoryShortDescriptionHtmlArgs, 'limit'>>;
  squashMergeAllowed?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  sshUrl?: Resolver<GQLResolversTypes['GitSSHRemote'], ParentType, ContextType>;
  stargazers?: Resolver<GQLResolversTypes['StargazerConnection'], ParentType, ContextType, RequireFields<GQLRepositoryStargazersArgs, never>>;
  submodules?: Resolver<GQLResolversTypes['SubmoduleConnection'], ParentType, ContextType, RequireFields<GQLRepositorySubmodulesArgs, never>>;
  tempCloneToken?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  templateRepository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  usesCustomOpenGraphImage?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanAdminister?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanCreateProjects?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdateTopics?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerHasStarred?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerPermission?: Resolver<Maybe<GQLResolversTypes['RepositoryPermission']>, ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<GQLResolversTypes['SubscriptionState']>, ParentType, ContextType>;
  vulnerabilityAlerts?: Resolver<Maybe<GQLResolversTypes['RepositoryVulnerabilityAlertConnection']>, ParentType, ContextType, RequireFields<GQLRepositoryVulnerabilityAlertsArgs, never>>;
  watchers?: Resolver<GQLResolversTypes['UserConnection'], ParentType, ContextType, RequireFields<GQLRepositoryWatchersArgs, never>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepositoryAuditEntryDataResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepositoryAuditEntryData'] = GQLResolversParentTypes['RepositoryAuditEntryData']> = {
  __resolveType: TypeResolveFn<'OrgRestoreMemberMembershipRepositoryAuditEntryData' | 'PrivateRepositoryForkingDisableAuditEntry' | 'PrivateRepositoryForkingEnableAuditEntry' | 'RepoAccessAuditEntry' | 'RepoAddMemberAuditEntry' | 'RepoAddTopicAuditEntry' | 'RepoArchivedAuditEntry' | 'RepoChangeMergeSettingAuditEntry' | 'RepoConfigDisableAnonymousGitAccessAuditEntry' | 'RepoConfigDisableCollaboratorsOnlyAuditEntry' | 'RepoConfigDisableContributorsOnlyAuditEntry' | 'RepoConfigDisableSockpuppetDisallowedAuditEntry' | 'RepoConfigEnableAnonymousGitAccessAuditEntry' | 'RepoConfigEnableCollaboratorsOnlyAuditEntry' | 'RepoConfigEnableContributorsOnlyAuditEntry' | 'RepoConfigEnableSockpuppetDisallowedAuditEntry' | 'RepoConfigLockAnonymousGitAccessAuditEntry' | 'RepoConfigUnlockAnonymousGitAccessAuditEntry' | 'RepoCreateAuditEntry' | 'RepoDestroyAuditEntry' | 'RepoRemoveMemberAuditEntry' | 'RepoRemoveTopicAuditEntry' | 'TeamAddRepositoryAuditEntry' | 'TeamRemoveRepositoryAuditEntry', ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
};

export type GQLRepositoryCollaboratorConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepositoryCollaboratorConnection'] = GQLResolversParentTypes['RepositoryCollaboratorConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['RepositoryCollaboratorEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepositoryCollaboratorEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepositoryCollaboratorEdge'] = GQLResolversParentTypes['RepositoryCollaboratorEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<GQLResolversTypes['User'], ParentType, ContextType>;
  permission?: Resolver<GQLResolversTypes['RepositoryPermission'], ParentType, ContextType>;
  permissionSources?: Resolver<Maybe<Array<GQLResolversTypes['PermissionSource']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepositoryConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepositoryConnection'] = GQLResolversParentTypes['RepositoryConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['RepositoryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['Repository']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  totalDiskUsage?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepositoryEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepositoryEdge'] = GQLResolversParentTypes['RepositoryEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepositoryInfoResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepositoryInfo'] = GQLResolversParentTypes['RepositoryInfo']> = {
  __resolveType: TypeResolveFn<'Repository', ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  descriptionHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType>;
  forkCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  hasIssuesEnabled?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  hasProjectsEnabled?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  hasWikiEnabled?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  homepageUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  isArchived?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isFork?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isLocked?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isMirror?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isPrivate?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isTemplate?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  licenseInfo?: Resolver<Maybe<GQLResolversTypes['License']>, ParentType, ContextType>;
  lockReason?: Resolver<Maybe<GQLResolversTypes['RepositoryLockReason']>, ParentType, ContextType>;
  mirrorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  nameWithOwner?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  openGraphImageUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  owner?: Resolver<GQLResolversTypes['RepositoryOwner'], ParentType, ContextType>;
  pushedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  shortDescriptionHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType, RequireFields<GQLRepositoryInfoShortDescriptionHtmlArgs, 'limit'>>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  usesCustomOpenGraphImage?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
};

export type GQLRepositoryInvitationResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepositoryInvitation'] = GQLResolversParentTypes['RepositoryInvitation']> = {
  email?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  invitee?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  inviter?: Resolver<GQLResolversTypes['User'], ParentType, ContextType>;
  permission?: Resolver<GQLResolversTypes['RepositoryPermission'], ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['RepositoryInfo']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepositoryInvitationConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepositoryInvitationConnection'] = GQLResolversParentTypes['RepositoryInvitationConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['RepositoryInvitationEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['RepositoryInvitation']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepositoryInvitationEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepositoryInvitationEdge'] = GQLResolversParentTypes['RepositoryInvitationEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['RepositoryInvitation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepositoryNodeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepositoryNode'] = GQLResolversParentTypes['RepositoryNode']> = {
  __resolveType: TypeResolveFn<'CommitComment' | 'CommitCommentThread' | 'Issue' | 'IssueComment' | 'PullRequest' | 'PullRequestCommitCommentThread' | 'PullRequestReview' | 'PullRequestReviewComment' | 'RepositoryVulnerabilityAlert', ParentType, ContextType>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
};

export type GQLRepositoryOwnerResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepositoryOwner'] = GQLResolversParentTypes['RepositoryOwner']> = {
  __resolveType: TypeResolveFn<'Organization' | 'User', ParentType, ContextType>;
  avatarUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType, RequireFields<GQLRepositoryOwnerAvatarUrlArgs, never>>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  login?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  repositories?: Resolver<GQLResolversTypes['RepositoryConnection'], ParentType, ContextType, RequireFields<GQLRepositoryOwnerRepositoriesArgs, 'ownerAffiliations'>>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType, RequireFields<GQLRepositoryOwnerRepositoryArgs, 'name'>>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
};

export type GQLRepositoryTopicResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepositoryTopic'] = GQLResolversParentTypes['RepositoryTopic']> = {
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  topic?: Resolver<GQLResolversTypes['Topic'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepositoryTopicConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepositoryTopicConnection'] = GQLResolversParentTypes['RepositoryTopicConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['RepositoryTopicEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['RepositoryTopic']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepositoryTopicEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepositoryTopicEdge'] = GQLResolversParentTypes['RepositoryTopicEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['RepositoryTopic']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepositoryVisibilityChangeDisableAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepositoryVisibilityChangeDisableAuditEntry'] = GQLResolversParentTypes['RepositoryVisibilityChangeDisableAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepositoryVisibilityChangeEnableAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepositoryVisibilityChangeEnableAuditEntry'] = GQLResolversParentTypes['RepositoryVisibilityChangeEnableAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  enterpriseResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  enterpriseSlug?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterpriseUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepositoryVulnerabilityAlertResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepositoryVulnerabilityAlert'] = GQLResolversParentTypes['RepositoryVulnerabilityAlert']> = {
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  dismissReason?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  dismissedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  dismisser?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  securityAdvisory?: Resolver<Maybe<GQLResolversTypes['SecurityAdvisory']>, ParentType, ContextType>;
  securityVulnerability?: Resolver<Maybe<GQLResolversTypes['SecurityVulnerability']>, ParentType, ContextType>;
  vulnerableManifestFilename?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  vulnerableManifestPath?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  vulnerableRequirements?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepositoryVulnerabilityAlertConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepositoryVulnerabilityAlertConnection'] = GQLResolversParentTypes['RepositoryVulnerabilityAlertConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['RepositoryVulnerabilityAlertEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['RepositoryVulnerabilityAlert']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRepositoryVulnerabilityAlertEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RepositoryVulnerabilityAlertEdge'] = GQLResolversParentTypes['RepositoryVulnerabilityAlertEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['RepositoryVulnerabilityAlert']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRequestReviewsPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RequestReviewsPayload'] = GQLResolversParentTypes['RequestReviewsPayload']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<GQLResolversTypes['PullRequest']>, ParentType, ContextType>;
  requestedReviewersEdge?: Resolver<Maybe<GQLResolversTypes['UserEdge']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRequestedReviewerResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RequestedReviewer'] = GQLResolversParentTypes['RequestedReviewer']> = {
  __resolveType: TypeResolveFn<'Mannequin' | 'Team' | 'User', ParentType, ContextType>;
};

export type GQLRerequestCheckSuitePayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RerequestCheckSuitePayload'] = GQLResolversParentTypes['RerequestCheckSuitePayload']> = {
  checkSuite?: Resolver<Maybe<GQLResolversTypes['CheckSuite']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLResolveReviewThreadPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ResolveReviewThreadPayload'] = GQLResolversParentTypes['ResolveReviewThreadPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  thread?: Resolver<Maybe<GQLResolversTypes['PullRequestReviewThread']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLRestrictedContributionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['RestrictedContribution'] = GQLResolversParentTypes['RestrictedContribution']> = {
  isRestricted?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  occurredAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  user?: Resolver<GQLResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReviewDismissalAllowanceResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReviewDismissalAllowance'] = GQLResolversParentTypes['ReviewDismissalAllowance']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['ReviewDismissalAllowanceActor']>, ParentType, ContextType>;
  branchProtectionRule?: Resolver<Maybe<GQLResolversTypes['BranchProtectionRule']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReviewDismissalAllowanceActorResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReviewDismissalAllowanceActor'] = GQLResolversParentTypes['ReviewDismissalAllowanceActor']> = {
  __resolveType: TypeResolveFn<'Team' | 'User', ParentType, ContextType>;
};

export type GQLReviewDismissalAllowanceConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReviewDismissalAllowanceConnection'] = GQLResolversParentTypes['ReviewDismissalAllowanceConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['ReviewDismissalAllowanceEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['ReviewDismissalAllowance']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReviewDismissalAllowanceEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReviewDismissalAllowanceEdge'] = GQLResolversParentTypes['ReviewDismissalAllowanceEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['ReviewDismissalAllowance']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReviewDismissedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReviewDismissedEvent'] = GQLResolversParentTypes['ReviewDismissedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  dismissalMessage?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  dismissalMessageHTML?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  previousReviewState?: Resolver<GQLResolversTypes['PullRequestReviewState'], ParentType, ContextType>;
  pullRequest?: Resolver<GQLResolversTypes['PullRequest'], ParentType, ContextType>;
  pullRequestCommit?: Resolver<Maybe<GQLResolversTypes['PullRequestCommit']>, ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  review?: Resolver<Maybe<GQLResolversTypes['PullRequestReview']>, ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReviewRequestResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReviewRequest'] = GQLResolversParentTypes['ReviewRequest']> = {
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<GQLResolversTypes['PullRequest'], ParentType, ContextType>;
  requestedReviewer?: Resolver<Maybe<GQLResolversTypes['RequestedReviewer']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReviewRequestConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReviewRequestConnection'] = GQLResolversParentTypes['ReviewRequestConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['ReviewRequestEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['ReviewRequest']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReviewRequestEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReviewRequestEdge'] = GQLResolversParentTypes['ReviewRequestEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['ReviewRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReviewRequestRemovedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReviewRequestRemovedEvent'] = GQLResolversParentTypes['ReviewRequestRemovedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<GQLResolversTypes['PullRequest'], ParentType, ContextType>;
  requestedReviewer?: Resolver<Maybe<GQLResolversTypes['RequestedReviewer']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReviewRequestedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReviewRequestedEvent'] = GQLResolversParentTypes['ReviewRequestedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  pullRequest?: Resolver<GQLResolversTypes['PullRequest'], ParentType, ContextType>;
  requestedReviewer?: Resolver<Maybe<GQLResolversTypes['RequestedReviewer']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLReviewStatusHovercardContextResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ReviewStatusHovercardContext'] = GQLResolversParentTypes['ReviewStatusHovercardContext']> = {
  message?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  octicon?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  reviewDecision?: Resolver<Maybe<GQLResolversTypes['PullRequestReviewDecision']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSavedReplyResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SavedReply'] = GQLResolversParentTypes['SavedReply']> = {
  body?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  title?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSavedReplyConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SavedReplyConnection'] = GQLResolversParentTypes['SavedReplyConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['SavedReplyEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['SavedReply']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSavedReplyEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SavedReplyEdge'] = GQLResolversParentTypes['SavedReplyEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['SavedReply']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSearchResultItemResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SearchResultItem'] = GQLResolversParentTypes['SearchResultItem']> = {
  __resolveType: TypeResolveFn<'App' | 'Issue' | 'MarketplaceListing' | 'Organization' | 'PullRequest' | 'Repository' | 'User', ParentType, ContextType>;
};

export type GQLSearchResultItemConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SearchResultItemConnection'] = GQLResolversParentTypes['SearchResultItemConnection']> = {
  codeCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['SearchResultItemEdge']>>>, ParentType, ContextType>;
  issueCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['SearchResultItem']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  repositoryCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  userCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  wikiCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSearchResultItemEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SearchResultItemEdge'] = GQLResolversParentTypes['SearchResultItemEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['SearchResultItem']>, ParentType, ContextType>;
  textMatches?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['TextMatch']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSecurityAdvisoryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SecurityAdvisory'] = GQLResolversParentTypes['SecurityAdvisory']> = {
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  description?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  ghsaId?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  identifiers?: Resolver<Array<GQLResolversTypes['SecurityAdvisoryIdentifier']>, ParentType, ContextType>;
  origin?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  permalink?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  publishedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  references?: Resolver<Array<GQLResolversTypes['SecurityAdvisoryReference']>, ParentType, ContextType>;
  severity?: Resolver<GQLResolversTypes['SecurityAdvisorySeverity'], ParentType, ContextType>;
  summary?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  vulnerabilities?: Resolver<GQLResolversTypes['SecurityVulnerabilityConnection'], ParentType, ContextType, RequireFields<GQLSecurityAdvisoryVulnerabilitiesArgs, 'orderBy'>>;
  withdrawnAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSecurityAdvisoryConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SecurityAdvisoryConnection'] = GQLResolversParentTypes['SecurityAdvisoryConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['SecurityAdvisoryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['SecurityAdvisory']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSecurityAdvisoryEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SecurityAdvisoryEdge'] = GQLResolversParentTypes['SecurityAdvisoryEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['SecurityAdvisory']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSecurityAdvisoryIdentifierResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SecurityAdvisoryIdentifier'] = GQLResolversParentTypes['SecurityAdvisoryIdentifier']> = {
  type?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSecurityAdvisoryPackageResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SecurityAdvisoryPackage'] = GQLResolversParentTypes['SecurityAdvisoryPackage']> = {
  ecosystem?: Resolver<GQLResolversTypes['SecurityAdvisoryEcosystem'], ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSecurityAdvisoryPackageVersionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SecurityAdvisoryPackageVersion'] = GQLResolversParentTypes['SecurityAdvisoryPackageVersion']> = {
  identifier?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSecurityAdvisoryReferenceResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SecurityAdvisoryReference'] = GQLResolversParentTypes['SecurityAdvisoryReference']> = {
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSecurityVulnerabilityResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SecurityVulnerability'] = GQLResolversParentTypes['SecurityVulnerability']> = {
  advisory?: Resolver<GQLResolversTypes['SecurityAdvisory'], ParentType, ContextType>;
  firstPatchedVersion?: Resolver<Maybe<GQLResolversTypes['SecurityAdvisoryPackageVersion']>, ParentType, ContextType>;
  package?: Resolver<GQLResolversTypes['SecurityAdvisoryPackage'], ParentType, ContextType>;
  severity?: Resolver<GQLResolversTypes['SecurityAdvisorySeverity'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  vulnerableVersionRange?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSecurityVulnerabilityConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SecurityVulnerabilityConnection'] = GQLResolversParentTypes['SecurityVulnerabilityConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['SecurityVulnerabilityEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['SecurityVulnerability']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSecurityVulnerabilityEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SecurityVulnerabilityEdge'] = GQLResolversParentTypes['SecurityVulnerabilityEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['SecurityVulnerability']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSetEnterpriseIdentityProviderPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SetEnterpriseIdentityProviderPayload'] = GQLResolversParentTypes['SetEnterpriseIdentityProviderPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  identityProvider?: Resolver<Maybe<GQLResolversTypes['EnterpriseIdentityProvider']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSmimeSignatureResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SmimeSignature'] = GQLResolversParentTypes['SmimeSignature']> = {
  email?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  isValid?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  payload?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  signature?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  signer?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  state?: Resolver<GQLResolversTypes['GitSignatureState'], ParentType, ContextType>;
  wasSignedByGitHub?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSponsorResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Sponsor'] = GQLResolversParentTypes['Sponsor']> = {
  __resolveType: TypeResolveFn<'Organization' | 'User', ParentType, ContextType>;
};

export type GQLSponsorableResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Sponsorable'] = GQLResolversParentTypes['Sponsorable']> = {
  __resolveType: TypeResolveFn<'Organization' | 'User', ParentType, ContextType>;
  sponsorsListing?: Resolver<Maybe<GQLResolversTypes['SponsorsListing']>, ParentType, ContextType>;
  sponsorshipsAsMaintainer?: Resolver<GQLResolversTypes['SponsorshipConnection'], ParentType, ContextType, RequireFields<GQLSponsorableSponsorshipsAsMaintainerArgs, 'includePrivate'>>;
  sponsorshipsAsSponsor?: Resolver<GQLResolversTypes['SponsorshipConnection'], ParentType, ContextType, RequireFields<GQLSponsorableSponsorshipsAsSponsorArgs, never>>;
};

export type GQLSponsorsListingResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SponsorsListing'] = GQLResolversParentTypes['SponsorsListing']> = {
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  fullDescription?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  fullDescriptionHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  shortDescription?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  tiers?: Resolver<Maybe<GQLResolversTypes['SponsorsTierConnection']>, ParentType, ContextType, RequireFields<GQLSponsorsListingTiersArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSponsorsTierResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SponsorsTier'] = GQLResolversParentTypes['SponsorsTier']> = {
  adminInfo?: Resolver<Maybe<GQLResolversTypes['SponsorsTierAdminInfo']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  descriptionHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  monthlyPriceInCents?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  monthlyPriceInDollars?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  sponsorsListing?: Resolver<GQLResolversTypes['SponsorsListing'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSponsorsTierAdminInfoResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SponsorsTierAdminInfo'] = GQLResolversParentTypes['SponsorsTierAdminInfo']> = {
  sponsorships?: Resolver<GQLResolversTypes['SponsorshipConnection'], ParentType, ContextType, RequireFields<GQLSponsorsTierAdminInfoSponsorshipsArgs, 'includePrivate'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSponsorsTierConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SponsorsTierConnection'] = GQLResolversParentTypes['SponsorsTierConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['SponsorsTierEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['SponsorsTier']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSponsorsTierEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SponsorsTierEdge'] = GQLResolversParentTypes['SponsorsTierEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['SponsorsTier']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSponsorshipResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Sponsorship'] = GQLResolversParentTypes['Sponsorship']> = {
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  maintainer?: Resolver<GQLResolversTypes['User'], ParentType, ContextType>;
  privacyLevel?: Resolver<GQLResolversTypes['SponsorshipPrivacy'], ParentType, ContextType>;
  sponsor?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  sponsorEntity?: Resolver<Maybe<GQLResolversTypes['Sponsor']>, ParentType, ContextType>;
  sponsorable?: Resolver<GQLResolversTypes['Sponsorable'], ParentType, ContextType>;
  tier?: Resolver<Maybe<GQLResolversTypes['SponsorsTier']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSponsorshipConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SponsorshipConnection'] = GQLResolversParentTypes['SponsorshipConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['SponsorshipEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['Sponsorship']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSponsorshipEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SponsorshipEdge'] = GQLResolversParentTypes['SponsorshipEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['Sponsorship']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLStargazerConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['StargazerConnection'] = GQLResolversParentTypes['StargazerConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['StargazerEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLStargazerEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['StargazerEdge'] = GQLResolversParentTypes['StargazerEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<GQLResolversTypes['User'], ParentType, ContextType>;
  starredAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLStarrableResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Starrable'] = GQLResolversParentTypes['Starrable']> = {
  __resolveType: TypeResolveFn<'Gist' | 'Repository' | 'Topic', ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  stargazers?: Resolver<GQLResolversTypes['StargazerConnection'], ParentType, ContextType, RequireFields<GQLStarrableStargazersArgs, never>>;
  viewerHasStarred?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
};

export type GQLStarredRepositoryConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['StarredRepositoryConnection'] = GQLResolversParentTypes['StarredRepositoryConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['StarredRepositoryEdge']>>>, ParentType, ContextType>;
  isOverLimit?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['Repository']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLStarredRepositoryEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['StarredRepositoryEdge'] = GQLResolversParentTypes['StarredRepositoryEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  starredAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLStatusResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Status'] = GQLResolversParentTypes['Status']> = {
  commit?: Resolver<Maybe<GQLResolversTypes['Commit']>, ParentType, ContextType>;
  context?: Resolver<Maybe<GQLResolversTypes['StatusContext']>, ParentType, ContextType, RequireFields<GQLStatusContextArgs, 'name'>>;
  contexts?: Resolver<Array<GQLResolversTypes['StatusContext']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  state?: Resolver<GQLResolversTypes['StatusState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLStatusCheckRollupResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['StatusCheckRollup'] = GQLResolversParentTypes['StatusCheckRollup']> = {
  commit?: Resolver<Maybe<GQLResolversTypes['Commit']>, ParentType, ContextType>;
  contexts?: Resolver<GQLResolversTypes['StatusCheckRollupContextConnection'], ParentType, ContextType, RequireFields<GQLStatusCheckRollupContextsArgs, never>>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  state?: Resolver<GQLResolversTypes['StatusState'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLStatusCheckRollupContextResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['StatusCheckRollupContext'] = GQLResolversParentTypes['StatusCheckRollupContext']> = {
  __resolveType: TypeResolveFn<'CheckRun' | 'StatusContext', ParentType, ContextType>;
};

export type GQLStatusCheckRollupContextConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['StatusCheckRollupContextConnection'] = GQLResolversParentTypes['StatusCheckRollupContextConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['StatusCheckRollupContextEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['StatusCheckRollupContext']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLStatusCheckRollupContextEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['StatusCheckRollupContextEdge'] = GQLResolversParentTypes['StatusCheckRollupContextEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['StatusCheckRollupContext']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLStatusContextResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['StatusContext'] = GQLResolversParentTypes['StatusContext']> = {
  avatarUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType, RequireFields<GQLStatusContextAvatarUrlArgs, 'size'>>;
  commit?: Resolver<Maybe<GQLResolversTypes['Commit']>, ParentType, ContextType>;
  context?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  creator?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  description?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  state?: Resolver<GQLResolversTypes['StatusState'], ParentType, ContextType>;
  targetUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSubmitPullRequestReviewPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SubmitPullRequestReviewPayload'] = GQLResolversParentTypes['SubmitPullRequestReviewPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<GQLResolversTypes['PullRequestReview']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSubmoduleResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Submodule'] = GQLResolversParentTypes['Submodule']> = {
  branch?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  gitUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  subprojectCommitOid?: Resolver<Maybe<GQLResolversTypes['GitObjectID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSubmoduleConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SubmoduleConnection'] = GQLResolversParentTypes['SubmoduleConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['SubmoduleEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['Submodule']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSubmoduleEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SubmoduleEdge'] = GQLResolversParentTypes['SubmoduleEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['Submodule']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSubscribableResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Subscribable'] = GQLResolversParentTypes['Subscribable']> = {
  __resolveType: TypeResolveFn<'Commit' | 'Issue' | 'PullRequest' | 'Repository' | 'Team' | 'TeamDiscussion', ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<GQLResolversTypes['SubscriptionState']>, ParentType, ContextType>;
};

export type GQLSubscribedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SubscribedEvent'] = GQLResolversParentTypes['SubscribedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  subscribable?: Resolver<GQLResolversTypes['Subscribable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLSuggestedReviewerResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['SuggestedReviewer'] = GQLResolversParentTypes['SuggestedReviewer']> = {
  isAuthor?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isCommenter?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  reviewer?: Resolver<GQLResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTagResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Tag'] = GQLResolversParentTypes['Tag']> = {
  abbreviatedOid?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  commitResourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  commitUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  message?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  oid?: Resolver<GQLResolversTypes['GitObjectID'], ParentType, ContextType>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  tagger?: Resolver<Maybe<GQLResolversTypes['GitActor']>, ParentType, ContextType>;
  target?: Resolver<GQLResolversTypes['GitObject'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTeamResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Team'] = GQLResolversParentTypes['Team']> = {
  ancestors?: Resolver<GQLResolversTypes['TeamConnection'], ParentType, ContextType, RequireFields<GQLTeamAncestorsArgs, never>>;
  avatarUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType, RequireFields<GQLTeamAvatarUrlArgs, 'size'>>;
  childTeams?: Resolver<GQLResolversTypes['TeamConnection'], ParentType, ContextType, RequireFields<GQLTeamChildTeamsArgs, 'immediateOnly'>>;
  combinedSlug?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  description?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  discussion?: Resolver<Maybe<GQLResolversTypes['TeamDiscussion']>, ParentType, ContextType, RequireFields<GQLTeamDiscussionArgs, 'number'>>;
  discussions?: Resolver<GQLResolversTypes['TeamDiscussionConnection'], ParentType, ContextType, RequireFields<GQLTeamDiscussionsArgs, never>>;
  discussionsResourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  discussionsUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  editTeamResourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  editTeamUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  invitations?: Resolver<Maybe<GQLResolversTypes['OrganizationInvitationConnection']>, ParentType, ContextType, RequireFields<GQLTeamInvitationsArgs, never>>;
  memberStatuses?: Resolver<GQLResolversTypes['UserStatusConnection'], ParentType, ContextType, RequireFields<GQLTeamMemberStatusesArgs, 'orderBy'>>;
  members?: Resolver<GQLResolversTypes['TeamMemberConnection'], ParentType, ContextType, RequireFields<GQLTeamMembersArgs, 'membership'>>;
  membersResourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  membersUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  newTeamResourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  newTeamUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  organization?: Resolver<GQLResolversTypes['Organization'], ParentType, ContextType>;
  parentTeam?: Resolver<Maybe<GQLResolversTypes['Team']>, ParentType, ContextType>;
  privacy?: Resolver<GQLResolversTypes['TeamPrivacy'], ParentType, ContextType>;
  repositories?: Resolver<GQLResolversTypes['TeamRepositoryConnection'], ParentType, ContextType, RequireFields<GQLTeamRepositoriesArgs, never>>;
  repositoriesResourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  repositoriesUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  reviewRequestDelegationAlgorithm?: Resolver<Maybe<GQLResolversTypes['TeamReviewAssignmentAlgorithm']>, ParentType, ContextType>;
  reviewRequestDelegationEnabled?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  reviewRequestDelegationMemberCount?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  reviewRequestDelegationNotifyTeam?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  slug?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  teamsResourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  teamsUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  viewerCanAdminister?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<GQLResolversTypes['SubscriptionState']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTeamAddMemberAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TeamAddMemberAuditEntry'] = GQLResolversParentTypes['TeamAddMemberAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isLdapMapped?: Resolver<Maybe<GQLResolversTypes['Boolean']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  team?: Resolver<Maybe<GQLResolversTypes['Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTeamAddRepositoryAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TeamAddRepositoryAuditEntry'] = GQLResolversParentTypes['TeamAddRepositoryAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isLdapMapped?: Resolver<Maybe<GQLResolversTypes['Boolean']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  team?: Resolver<Maybe<GQLResolversTypes['Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTeamAuditEntryDataResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TeamAuditEntryData'] = GQLResolversParentTypes['TeamAuditEntryData']> = {
  __resolveType: TypeResolveFn<'OrgRestoreMemberMembershipTeamAuditEntryData' | 'TeamAddMemberAuditEntry' | 'TeamAddRepositoryAuditEntry' | 'TeamChangeParentTeamAuditEntry' | 'TeamRemoveMemberAuditEntry' | 'TeamRemoveRepositoryAuditEntry', ParentType, ContextType>;
  team?: Resolver<Maybe<GQLResolversTypes['Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
};

export type GQLTeamChangeParentTeamAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TeamChangeParentTeamAuditEntry'] = GQLResolversParentTypes['TeamChangeParentTeamAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isLdapMapped?: Resolver<Maybe<GQLResolversTypes['Boolean']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  parentTeam?: Resolver<Maybe<GQLResolversTypes['Team']>, ParentType, ContextType>;
  parentTeamName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  parentTeamNameWas?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  parentTeamResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  parentTeamUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  parentTeamWas?: Resolver<Maybe<GQLResolversTypes['Team']>, ParentType, ContextType>;
  parentTeamWasResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  parentTeamWasUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  team?: Resolver<Maybe<GQLResolversTypes['Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTeamConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TeamConnection'] = GQLResolversParentTypes['TeamConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['TeamEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['Team']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTeamDiscussionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TeamDiscussion'] = GQLResolversParentTypes['TeamDiscussion']> = {
  author?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<GQLResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType>;
  bodyText?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  bodyVersion?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  comments?: Resolver<GQLResolversTypes['TeamDiscussionCommentConnection'], ParentType, ContextType, RequireFields<GQLTeamDiscussionCommentsArgs, never>>;
  commentsResourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  commentsUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  editor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isPinned?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isPrivate?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  number?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<GQLResolversTypes['ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<GQLResolversTypes['ReactionConnection'], ParentType, ContextType, RequireFields<GQLTeamDiscussionReactionsArgs, never>>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  team?: Resolver<GQLResolversTypes['Team'], ParentType, ContextType>;
  title?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<GQLResolversTypes['UserContentEditConnection']>, ParentType, ContextType, RequireFields<GQLTeamDiscussionUserContentEditsArgs, never>>;
  viewerCanDelete?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanPin?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanSubscribe?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<GQLResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerSubscription?: Resolver<Maybe<GQLResolversTypes['SubscriptionState']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTeamDiscussionCommentResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TeamDiscussionComment'] = GQLResolversParentTypes['TeamDiscussionComment']> = {
  author?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  authorAssociation?: Resolver<GQLResolversTypes['CommentAuthorAssociation'], ParentType, ContextType>;
  body?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  bodyHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType>;
  bodyText?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  bodyVersion?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  createdViaEmail?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  discussion?: Resolver<GQLResolversTypes['TeamDiscussion'], ParentType, ContextType>;
  editor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  includesCreatedEdit?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  lastEditedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  number?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  reactionGroups?: Resolver<Maybe<Array<GQLResolversTypes['ReactionGroup']>>, ParentType, ContextType>;
  reactions?: Resolver<GQLResolversTypes['ReactionConnection'], ParentType, ContextType, RequireFields<GQLTeamDiscussionCommentReactionsArgs, never>>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  userContentEdits?: Resolver<Maybe<GQLResolversTypes['UserContentEditConnection']>, ParentType, ContextType, RequireFields<GQLTeamDiscussionCommentUserContentEditsArgs, never>>;
  viewerCanDelete?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanReact?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanUpdate?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<GQLResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>;
  viewerDidAuthor?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTeamDiscussionCommentConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TeamDiscussionCommentConnection'] = GQLResolversParentTypes['TeamDiscussionCommentConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['TeamDiscussionCommentEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['TeamDiscussionComment']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTeamDiscussionCommentEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TeamDiscussionCommentEdge'] = GQLResolversParentTypes['TeamDiscussionCommentEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['TeamDiscussionComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTeamDiscussionConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TeamDiscussionConnection'] = GQLResolversParentTypes['TeamDiscussionConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['TeamDiscussionEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['TeamDiscussion']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTeamDiscussionEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TeamDiscussionEdge'] = GQLResolversParentTypes['TeamDiscussionEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['TeamDiscussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTeamEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TeamEdge'] = GQLResolversParentTypes['TeamEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['Team']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTeamMemberConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TeamMemberConnection'] = GQLResolversParentTypes['TeamMemberConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['TeamMemberEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTeamMemberEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TeamMemberEdge'] = GQLResolversParentTypes['TeamMemberEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  memberAccessResourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  memberAccessUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  node?: Resolver<GQLResolversTypes['User'], ParentType, ContextType>;
  role?: Resolver<GQLResolversTypes['TeamMemberRole'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTeamRemoveMemberAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TeamRemoveMemberAuditEntry'] = GQLResolversParentTypes['TeamRemoveMemberAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isLdapMapped?: Resolver<Maybe<GQLResolversTypes['Boolean']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  team?: Resolver<Maybe<GQLResolversTypes['Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTeamRemoveRepositoryAuditEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TeamRemoveRepositoryAuditEntry'] = GQLResolversParentTypes['TeamRemoveRepositoryAuditEntry']> = {
  action?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  actor?: Resolver<Maybe<GQLResolversTypes['AuditEntryActor']>, ParentType, ContextType>;
  actorIp?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorLocation?: Resolver<Maybe<GQLResolversTypes['ActorLocation']>, ParentType, ContextType>;
  actorLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  actorResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  actorUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['PreciseDateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isLdapMapped?: Resolver<Maybe<GQLResolversTypes['Boolean']>, ParentType, ContextType>;
  operationType?: Resolver<Maybe<GQLResolversTypes['OperationType']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  organizationName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organizationResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  organizationUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  repositoryName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repositoryResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  repositoryUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  team?: Resolver<Maybe<GQLResolversTypes['Team']>, ParentType, ContextType>;
  teamName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  teamResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  teamUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  userLogin?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  userResourcePath?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  userUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTeamRepositoryConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TeamRepositoryConnection'] = GQLResolversParentTypes['TeamRepositoryConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['TeamRepositoryEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['Repository']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTeamRepositoryEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TeamRepositoryEdge'] = GQLResolversParentTypes['TeamRepositoryEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  permission?: Resolver<GQLResolversTypes['RepositoryPermission'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTextMatchResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TextMatch'] = GQLResolversParentTypes['TextMatch']> = {
  fragment?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  highlights?: Resolver<Array<GQLResolversTypes['TextMatchHighlight']>, ParentType, ContextType>;
  property?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTextMatchHighlightResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TextMatchHighlight'] = GQLResolversParentTypes['TextMatchHighlight']> = {
  beginIndice?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  endIndice?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  text?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTopicResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Topic'] = GQLResolversParentTypes['Topic']> = {
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  relatedTopics?: Resolver<Array<GQLResolversTypes['Topic']>, ParentType, ContextType, RequireFields<GQLTopicRelatedTopicsArgs, 'first'>>;
  stargazers?: Resolver<GQLResolversTypes['StargazerConnection'], ParentType, ContextType, RequireFields<GQLTopicStargazersArgs, never>>;
  viewerHasStarred?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTopicAuditEntryDataResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TopicAuditEntryData'] = GQLResolversParentTypes['TopicAuditEntryData']> = {
  __resolveType: TypeResolveFn<'RepoAddTopicAuditEntry' | 'RepoRemoveTopicAuditEntry', ParentType, ContextType>;
  topic?: Resolver<Maybe<GQLResolversTypes['Topic']>, ParentType, ContextType>;
  topicName?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
};

export type GQLTopicConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TopicConnection'] = GQLResolversParentTypes['TopicConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['TopicEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['Topic']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTopicEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TopicEdge'] = GQLResolversParentTypes['TopicEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['Topic']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTransferIssuePayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TransferIssuePayload'] = GQLResolversParentTypes['TransferIssuePayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<GQLResolversTypes['Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTransferredEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TransferredEvent'] = GQLResolversParentTypes['TransferredEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  fromRepository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  issue?: Resolver<GQLResolversTypes['Issue'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTreeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Tree'] = GQLResolversParentTypes['Tree']> = {
  abbreviatedOid?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  commitResourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  commitUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  entries?: Resolver<Maybe<Array<GQLResolversTypes['TreeEntry']>>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  oid?: Resolver<GQLResolversTypes['GitObjectID'], ParentType, ContextType>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLTreeEntryResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['TreeEntry'] = GQLResolversParentTypes['TreeEntry']> = {
  mode?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  object?: Resolver<Maybe<GQLResolversTypes['GitObject']>, ParentType, ContextType>;
  oid?: Resolver<GQLResolversTypes['GitObjectID'], ParentType, ContextType>;
  repository?: Resolver<GQLResolversTypes['Repository'], ParentType, ContextType>;
  submodule?: Resolver<Maybe<GQLResolversTypes['Submodule']>, ParentType, ContextType>;
  type?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export interface GQLUriScalarConfig extends GraphQLScalarTypeConfig<GQLResolversTypes['URI'], any> {
  name: 'URI';
}

export type GQLUnarchiveRepositoryPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UnarchiveRepositoryPayload'] = GQLResolversParentTypes['UnarchiveRepositoryPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUnassignedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UnassignedEvent'] = GQLResolversParentTypes['UnassignedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  assignable?: Resolver<GQLResolversTypes['Assignable'], ParentType, ContextType>;
  assignee?: Resolver<Maybe<GQLResolversTypes['Assignee']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUnfollowUserPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UnfollowUserPayload'] = GQLResolversParentTypes['UnfollowUserPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUniformResourceLocatableResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UniformResourceLocatable'] = GQLResolversParentTypes['UniformResourceLocatable']> = {
  __resolveType: TypeResolveFn<'Bot' | 'CheckRun' | 'ClosedEvent' | 'Commit' | 'ConvertToDraftEvent' | 'CrossReferencedEvent' | 'Gist' | 'Issue' | 'Mannequin' | 'MergedEvent' | 'Milestone' | 'Organization' | 'PullRequest' | 'PullRequestCommit' | 'ReadyForReviewEvent' | 'Release' | 'Repository' | 'RepositoryTopic' | 'ReviewDismissedEvent' | 'TeamDiscussion' | 'TeamDiscussionComment' | 'User', ParentType, ContextType>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
};

export type GQLUnknownSignatureResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UnknownSignature'] = GQLResolversParentTypes['UnknownSignature']> = {
  email?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  isValid?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  payload?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  signature?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  signer?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  state?: Resolver<GQLResolversTypes['GitSignatureState'], ParentType, ContextType>;
  wasSignedByGitHub?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUnlabeledEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UnlabeledEvent'] = GQLResolversParentTypes['UnlabeledEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  label?: Resolver<GQLResolversTypes['Label'], ParentType, ContextType>;
  labelable?: Resolver<GQLResolversTypes['Labelable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUnlinkRepositoryFromProjectPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UnlinkRepositoryFromProjectPayload'] = GQLResolversParentTypes['UnlinkRepositoryFromProjectPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<GQLResolversTypes['Project']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUnlockLockablePayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UnlockLockablePayload'] = GQLResolversParentTypes['UnlockLockablePayload']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  unlockedRecord?: Resolver<Maybe<GQLResolversTypes['Lockable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUnlockedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UnlockedEvent'] = GQLResolversParentTypes['UnlockedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  lockable?: Resolver<GQLResolversTypes['Lockable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUnmarkIssueAsDuplicatePayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UnmarkIssueAsDuplicatePayload'] = GQLResolversParentTypes['UnmarkIssueAsDuplicatePayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  duplicate?: Resolver<Maybe<GQLResolversTypes['IssueOrPullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUnmarkedAsDuplicateEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UnmarkedAsDuplicateEvent'] = GQLResolversParentTypes['UnmarkedAsDuplicateEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUnminimizeCommentPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UnminimizeCommentPayload'] = GQLResolversParentTypes['UnminimizeCommentPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  unminimizedComment?: Resolver<Maybe<GQLResolversTypes['Minimizable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUnpinIssuePayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UnpinIssuePayload'] = GQLResolversParentTypes['UnpinIssuePayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<GQLResolversTypes['Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUnpinnedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UnpinnedEvent'] = GQLResolversParentTypes['UnpinnedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  issue?: Resolver<GQLResolversTypes['Issue'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUnresolveReviewThreadPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UnresolveReviewThreadPayload'] = GQLResolversParentTypes['UnresolveReviewThreadPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  thread?: Resolver<Maybe<GQLResolversTypes['PullRequestReviewThread']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUnsubscribedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UnsubscribedEvent'] = GQLResolversParentTypes['UnsubscribedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  subscribable?: Resolver<GQLResolversTypes['Subscribable'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdatableResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['Updatable'] = GQLResolversParentTypes['Updatable']> = {
  __resolveType: TypeResolveFn<'CommitComment' | 'GistComment' | 'Issue' | 'IssueComment' | 'Project' | 'PullRequest' | 'PullRequestReview' | 'PullRequestReviewComment' | 'TeamDiscussion' | 'TeamDiscussionComment', ParentType, ContextType>;
  viewerCanUpdate?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
};

export type GQLUpdatableCommentResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdatableComment'] = GQLResolversParentTypes['UpdatableComment']> = {
  __resolveType: TypeResolveFn<'CommitComment' | 'GistComment' | 'Issue' | 'IssueComment' | 'PullRequest' | 'PullRequestReview' | 'PullRequestReviewComment' | 'TeamDiscussion' | 'TeamDiscussionComment', ParentType, ContextType>;
  viewerCannotUpdateReasons?: Resolver<Array<GQLResolversTypes['CommentCannotUpdateReason']>, ParentType, ContextType>;
};

export type GQLUpdateBranchProtectionRulePayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateBranchProtectionRulePayload'] = GQLResolversParentTypes['UpdateBranchProtectionRulePayload']> = {
  branchProtectionRule?: Resolver<Maybe<GQLResolversTypes['BranchProtectionRule']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateCheckRunPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateCheckRunPayload'] = GQLResolversParentTypes['UpdateCheckRunPayload']> = {
  checkRun?: Resolver<Maybe<GQLResolversTypes['CheckRun']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateCheckSuitePreferencesPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateCheckSuitePreferencesPayload'] = GQLResolversParentTypes['UpdateCheckSuitePreferencesPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateEnterpriseActionExecutionCapabilitySettingPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateEnterpriseActionExecutionCapabilitySettingPayload'] = GQLResolversParentTypes['UpdateEnterpriseActionExecutionCapabilitySettingPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<GQLResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateEnterpriseAdministratorRolePayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateEnterpriseAdministratorRolePayload'] = GQLResolversParentTypes['UpdateEnterpriseAdministratorRolePayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateEnterpriseAllowPrivateRepositoryForkingSettingPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload'] = GQLResolversParentTypes['UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<GQLResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateEnterpriseDefaultRepositoryPermissionSettingPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateEnterpriseDefaultRepositoryPermissionSettingPayload'] = GQLResolversParentTypes['UpdateEnterpriseDefaultRepositoryPermissionSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<GQLResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload'] = GQLResolversParentTypes['UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<GQLResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateEnterpriseMembersCanCreateRepositoriesSettingPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload'] = GQLResolversParentTypes['UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<GQLResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateEnterpriseMembersCanDeleteIssuesSettingPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateEnterpriseMembersCanDeleteIssuesSettingPayload'] = GQLResolversParentTypes['UpdateEnterpriseMembersCanDeleteIssuesSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<GQLResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateEnterpriseMembersCanDeleteRepositoriesSettingPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload'] = GQLResolversParentTypes['UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<GQLResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateEnterpriseMembersCanInviteCollaboratorsSettingPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload'] = GQLResolversParentTypes['UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<GQLResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateEnterpriseMembersCanMakePurchasesSettingPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateEnterpriseMembersCanMakePurchasesSettingPayload'] = GQLResolversParentTypes['UpdateEnterpriseMembersCanMakePurchasesSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<GQLResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload'] = GQLResolversParentTypes['UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<GQLResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateEnterpriseMembersCanViewDependencyInsightsSettingPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload'] = GQLResolversParentTypes['UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<GQLResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateEnterpriseOrganizationProjectsSettingPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateEnterpriseOrganizationProjectsSettingPayload'] = GQLResolversParentTypes['UpdateEnterpriseOrganizationProjectsSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<GQLResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateEnterpriseProfilePayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateEnterpriseProfilePayload'] = GQLResolversParentTypes['UpdateEnterpriseProfilePayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<GQLResolversTypes['Enterprise']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateEnterpriseRepositoryProjectsSettingPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateEnterpriseRepositoryProjectsSettingPayload'] = GQLResolversParentTypes['UpdateEnterpriseRepositoryProjectsSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<GQLResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateEnterpriseTeamDiscussionsSettingPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateEnterpriseTeamDiscussionsSettingPayload'] = GQLResolversParentTypes['UpdateEnterpriseTeamDiscussionsSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<GQLResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload'] = GQLResolversParentTypes['UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  enterprise?: Resolver<Maybe<GQLResolversTypes['Enterprise']>, ParentType, ContextType>;
  message?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateIpAllowListEnabledSettingPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateIpAllowListEnabledSettingPayload'] = GQLResolversParentTypes['UpdateIpAllowListEnabledSettingPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  owner?: Resolver<Maybe<GQLResolversTypes['IpAllowListOwner']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateIpAllowListEntryPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateIpAllowListEntryPayload'] = GQLResolversParentTypes['UpdateIpAllowListEntryPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  ipAllowListEntry?: Resolver<Maybe<GQLResolversTypes['IpAllowListEntry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateIssueCommentPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateIssueCommentPayload'] = GQLResolversParentTypes['UpdateIssueCommentPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  issueComment?: Resolver<Maybe<GQLResolversTypes['IssueComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateIssuePayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateIssuePayload'] = GQLResolversParentTypes['UpdateIssuePayload']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  issue?: Resolver<Maybe<GQLResolversTypes['Issue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateLabelPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateLabelPayload'] = GQLResolversParentTypes['UpdateLabelPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  label?: Resolver<Maybe<GQLResolversTypes['Label']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateProjectCardPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateProjectCardPayload'] = GQLResolversParentTypes['UpdateProjectCardPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  projectCard?: Resolver<Maybe<GQLResolversTypes['ProjectCard']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateProjectColumnPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateProjectColumnPayload'] = GQLResolversParentTypes['UpdateProjectColumnPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  projectColumn?: Resolver<Maybe<GQLResolversTypes['ProjectColumn']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateProjectPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateProjectPayload'] = GQLResolversParentTypes['UpdateProjectPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  project?: Resolver<Maybe<GQLResolversTypes['Project']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdatePullRequestPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdatePullRequestPayload'] = GQLResolversParentTypes['UpdatePullRequestPayload']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  pullRequest?: Resolver<Maybe<GQLResolversTypes['PullRequest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdatePullRequestReviewCommentPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdatePullRequestReviewCommentPayload'] = GQLResolversParentTypes['UpdatePullRequestReviewCommentPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReviewComment?: Resolver<Maybe<GQLResolversTypes['PullRequestReviewComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdatePullRequestReviewPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdatePullRequestReviewPayload'] = GQLResolversParentTypes['UpdatePullRequestReviewPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  pullRequestReview?: Resolver<Maybe<GQLResolversTypes['PullRequestReview']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateRefPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateRefPayload'] = GQLResolversParentTypes['UpdateRefPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  ref?: Resolver<Maybe<GQLResolversTypes['Ref']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateRefsPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateRefsPayload'] = GQLResolversParentTypes['UpdateRefsPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateRepositoryPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateRepositoryPayload'] = GQLResolversParentTypes['UpdateRepositoryPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateSubscriptionPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateSubscriptionPayload'] = GQLResolversParentTypes['UpdateSubscriptionPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  subscribable?: Resolver<Maybe<GQLResolversTypes['Subscribable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateTeamDiscussionCommentPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateTeamDiscussionCommentPayload'] = GQLResolversParentTypes['UpdateTeamDiscussionCommentPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  teamDiscussionComment?: Resolver<Maybe<GQLResolversTypes['TeamDiscussionComment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateTeamDiscussionPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateTeamDiscussionPayload'] = GQLResolversParentTypes['UpdateTeamDiscussionPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  teamDiscussion?: Resolver<Maybe<GQLResolversTypes['TeamDiscussion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateTeamReviewAssignmentPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateTeamReviewAssignmentPayload'] = GQLResolversParentTypes['UpdateTeamReviewAssignmentPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  team?: Resolver<Maybe<GQLResolversTypes['Team']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUpdateTopicsPayloadResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UpdateTopicsPayload'] = GQLResolversParentTypes['UpdateTopicsPayload']> = {
  clientMutationId?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  invalidTopicNames?: Resolver<Maybe<Array<GQLResolversTypes['String']>>, ParentType, ContextType>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUserResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['User'] = GQLResolversParentTypes['User']> = {
  anyPinnableItems?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType, RequireFields<GQLUserAnyPinnableItemsArgs, never>>;
  avatarUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType, RequireFields<GQLUserAvatarUrlArgs, never>>;
  bio?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  bioHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType>;
  commitComments?: Resolver<GQLResolversTypes['CommitCommentConnection'], ParentType, ContextType, RequireFields<GQLUserCommitCommentsArgs, never>>;
  company?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  companyHTML?: Resolver<GQLResolversTypes['HTML'], ParentType, ContextType>;
  contributionsCollection?: Resolver<GQLResolversTypes['ContributionsCollection'], ParentType, ContextType, RequireFields<GQLUserContributionsCollectionArgs, never>>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  databaseId?: Resolver<Maybe<GQLResolversTypes['Int']>, ParentType, ContextType>;
  email?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  followers?: Resolver<GQLResolversTypes['FollowerConnection'], ParentType, ContextType, RequireFields<GQLUserFollowersArgs, never>>;
  following?: Resolver<GQLResolversTypes['FollowingConnection'], ParentType, ContextType, RequireFields<GQLUserFollowingArgs, never>>;
  gist?: Resolver<Maybe<GQLResolversTypes['Gist']>, ParentType, ContextType, RequireFields<GQLUserGistArgs, 'name'>>;
  gistComments?: Resolver<GQLResolversTypes['GistCommentConnection'], ParentType, ContextType, RequireFields<GQLUserGistCommentsArgs, never>>;
  gists?: Resolver<GQLResolversTypes['GistConnection'], ParentType, ContextType, RequireFields<GQLUserGistsArgs, never>>;
  hovercard?: Resolver<GQLResolversTypes['Hovercard'], ParentType, ContextType, RequireFields<GQLUserHovercardArgs, never>>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  isBountyHunter?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isCampusExpert?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isDeveloperProgramMember?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isEmployee?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isHireable?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isSiteAdmin?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  isViewer?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  issueComments?: Resolver<GQLResolversTypes['IssueCommentConnection'], ParentType, ContextType, RequireFields<GQLUserIssueCommentsArgs, never>>;
  issues?: Resolver<GQLResolversTypes['IssueConnection'], ParentType, ContextType, RequireFields<GQLUserIssuesArgs, never>>;
  itemShowcase?: Resolver<GQLResolversTypes['ProfileItemShowcase'], ParentType, ContextType>;
  location?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  login?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType, RequireFields<GQLUserOrganizationArgs, 'login'>>;
  organizationVerifiedDomainEmails?: Resolver<Array<GQLResolversTypes['String']>, ParentType, ContextType, RequireFields<GQLUserOrganizationVerifiedDomainEmailsArgs, 'login'>>;
  organizations?: Resolver<GQLResolversTypes['OrganizationConnection'], ParentType, ContextType, RequireFields<GQLUserOrganizationsArgs, never>>;
  packages?: Resolver<GQLResolversTypes['PackageConnection'], ParentType, ContextType, RequireFields<GQLUserPackagesArgs, 'orderBy'>>;
  pinnableItems?: Resolver<GQLResolversTypes['PinnableItemConnection'], ParentType, ContextType, RequireFields<GQLUserPinnableItemsArgs, never>>;
  pinnedItems?: Resolver<GQLResolversTypes['PinnableItemConnection'], ParentType, ContextType, RequireFields<GQLUserPinnedItemsArgs, never>>;
  pinnedItemsRemaining?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  project?: Resolver<Maybe<GQLResolversTypes['Project']>, ParentType, ContextType, RequireFields<GQLUserProjectArgs, 'number'>>;
  projects?: Resolver<GQLResolversTypes['ProjectConnection'], ParentType, ContextType, RequireFields<GQLUserProjectsArgs, never>>;
  projectsResourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  projectsUrl?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  publicKeys?: Resolver<GQLResolversTypes['PublicKeyConnection'], ParentType, ContextType, RequireFields<GQLUserPublicKeysArgs, never>>;
  pullRequests?: Resolver<GQLResolversTypes['PullRequestConnection'], ParentType, ContextType, RequireFields<GQLUserPullRequestsArgs, never>>;
  registryPackages?: Resolver<GQLResolversTypes['RegistryPackageConnection'], ParentType, ContextType, RequireFields<GQLUserRegistryPackagesArgs, 'publicOnly'>>;
  registryPackagesForQuery?: Resolver<GQLResolversTypes['RegistryPackageConnection'], ParentType, ContextType, RequireFields<GQLUserRegistryPackagesForQueryArgs, never>>;
  repositories?: Resolver<GQLResolversTypes['RepositoryConnection'], ParentType, ContextType, RequireFields<GQLUserRepositoriesArgs, 'ownerAffiliations'>>;
  repositoriesContributedTo?: Resolver<GQLResolversTypes['RepositoryConnection'], ParentType, ContextType, RequireFields<GQLUserRepositoriesContributedToArgs, never>>;
  repository?: Resolver<Maybe<GQLResolversTypes['Repository']>, ParentType, ContextType, RequireFields<GQLUserRepositoryArgs, 'name'>>;
  resourcePath?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  savedReplies?: Resolver<Maybe<GQLResolversTypes['SavedReplyConnection']>, ParentType, ContextType, RequireFields<GQLUserSavedRepliesArgs, 'orderBy'>>;
  sponsorsListing?: Resolver<Maybe<GQLResolversTypes['SponsorsListing']>, ParentType, ContextType>;
  sponsorshipsAsMaintainer?: Resolver<GQLResolversTypes['SponsorshipConnection'], ParentType, ContextType, RequireFields<GQLUserSponsorshipsAsMaintainerArgs, 'includePrivate'>>;
  sponsorshipsAsSponsor?: Resolver<GQLResolversTypes['SponsorshipConnection'], ParentType, ContextType, RequireFields<GQLUserSponsorshipsAsSponsorArgs, never>>;
  starredRepositories?: Resolver<GQLResolversTypes['StarredRepositoryConnection'], ParentType, ContextType, RequireFields<GQLUserStarredRepositoriesArgs, never>>;
  status?: Resolver<Maybe<GQLResolversTypes['UserStatus']>, ParentType, ContextType>;
  topRepositories?: Resolver<GQLResolversTypes['RepositoryConnection'], ParentType, ContextType, RequireFields<GQLUserTopRepositoriesArgs, 'orderBy'>>;
  twitterUsername?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<GQLResolversTypes['URI'], ParentType, ContextType>;
  viewerCanChangePinnedItems?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanCreateProjects?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerCanFollow?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  viewerIsFollowing?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  watching?: Resolver<GQLResolversTypes['RepositoryConnection'], ParentType, ContextType, RequireFields<GQLUserWatchingArgs, 'ownerAffiliations'>>;
  websiteUrl?: Resolver<Maybe<GQLResolversTypes['URI']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUserBlockedEventResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UserBlockedEvent'] = GQLResolversParentTypes['UserBlockedEvent']> = {
  actor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  blockDuration?: Resolver<GQLResolversTypes['UserBlockDuration'], ParentType, ContextType>;
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  subject?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUserConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UserConnection'] = GQLResolversParentTypes['UserConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['UserEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['User']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUserContentEditResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UserContentEdit'] = GQLResolversParentTypes['UserContentEdit']> = {
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  deletedAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  deletedBy?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  diff?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  editedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  editor?: Resolver<Maybe<GQLResolversTypes['Actor']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUserContentEditConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UserContentEditConnection'] = GQLResolversParentTypes['UserContentEditConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['UserContentEditEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['UserContentEdit']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUserContentEditEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UserContentEditEdge'] = GQLResolversParentTypes['UserContentEditEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['UserContentEdit']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUserEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UserEdge'] = GQLResolversParentTypes['UserEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUserStatusResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UserStatus'] = GQLResolversParentTypes['UserStatus']> = {
  createdAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  emoji?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  emojiHTML?: Resolver<Maybe<GQLResolversTypes['HTML']>, ParentType, ContextType>;
  expiresAt?: Resolver<Maybe<GQLResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<GQLResolversTypes['ID'], ParentType, ContextType>;
  indicatesLimitedAvailability?: Resolver<GQLResolversTypes['Boolean'], ParentType, ContextType>;
  message?: Resolver<Maybe<GQLResolversTypes['String']>, ParentType, ContextType>;
  organization?: Resolver<Maybe<GQLResolversTypes['Organization']>, ParentType, ContextType>;
  updatedAt?: Resolver<GQLResolversTypes['DateTime'], ParentType, ContextType>;
  user?: Resolver<GQLResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUserStatusConnectionResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UserStatusConnection'] = GQLResolversParentTypes['UserStatusConnection']> = {
  edges?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['UserStatusEdge']>>>, ParentType, ContextType>;
  nodes?: Resolver<Maybe<Array<Maybe<GQLResolversTypes['UserStatus']>>>, ParentType, ContextType>;
  pageInfo?: Resolver<GQLResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<GQLResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLUserStatusEdgeResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['UserStatusEdge'] = GQLResolversParentTypes['UserStatusEdge']> = {
  cursor?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<Maybe<GQLResolversTypes['UserStatus']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export type GQLViewerHovercardContextResolvers<ContextType = any, ParentType extends GQLResolversParentTypes['ViewerHovercardContext'] = GQLResolversParentTypes['ViewerHovercardContext']> = {
  message?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  octicon?: Resolver<GQLResolversTypes['String'], ParentType, ContextType>;
  viewer?: Resolver<GQLResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType>;
};

export interface GQLX509CertificateScalarConfig extends GraphQLScalarTypeConfig<GQLResolversTypes['X509Certificate'], any> {
  name: 'X509Certificate';
}

export type GQLResolvers<ContextType = any> = {
  AcceptEnterpriseAdministratorInvitationPayload?: GQLAcceptEnterpriseAdministratorInvitationPayloadResolvers<ContextType>;
  AcceptTopicSuggestionPayload?: GQLAcceptTopicSuggestionPayloadResolvers<ContextType>;
  Actor?: GQLActorResolvers;
  ActorLocation?: GQLActorLocationResolvers<ContextType>;
  AddAssigneesToAssignablePayload?: GQLAddAssigneesToAssignablePayloadResolvers<ContextType>;
  AddCommentPayload?: GQLAddCommentPayloadResolvers<ContextType>;
  AddLabelsToLabelablePayload?: GQLAddLabelsToLabelablePayloadResolvers<ContextType>;
  AddProjectCardPayload?: GQLAddProjectCardPayloadResolvers<ContextType>;
  AddProjectColumnPayload?: GQLAddProjectColumnPayloadResolvers<ContextType>;
  AddPullRequestReviewCommentPayload?: GQLAddPullRequestReviewCommentPayloadResolvers<ContextType>;
  AddPullRequestReviewPayload?: GQLAddPullRequestReviewPayloadResolvers<ContextType>;
  AddPullRequestReviewThreadPayload?: GQLAddPullRequestReviewThreadPayloadResolvers<ContextType>;
  AddReactionPayload?: GQLAddReactionPayloadResolvers<ContextType>;
  AddStarPayload?: GQLAddStarPayloadResolvers<ContextType>;
  AddedToProjectEvent?: GQLAddedToProjectEventResolvers<ContextType>;
  App?: GQLAppResolvers<ContextType>;
  ArchiveRepositoryPayload?: GQLArchiveRepositoryPayloadResolvers<ContextType>;
  Assignable?: GQLAssignableResolvers;
  AssignedEvent?: GQLAssignedEventResolvers<ContextType>;
  Assignee?: GQLAssigneeResolvers;
  AuditEntry?: GQLAuditEntryResolvers;
  AuditEntryActor?: GQLAuditEntryActorResolvers;
  AutomaticBaseChangeFailedEvent?: GQLAutomaticBaseChangeFailedEventResolvers<ContextType>;
  AutomaticBaseChangeSucceededEvent?: GQLAutomaticBaseChangeSucceededEventResolvers<ContextType>;
  BaseRefChangedEvent?: GQLBaseRefChangedEventResolvers<ContextType>;
  BaseRefForcePushedEvent?: GQLBaseRefForcePushedEventResolvers<ContextType>;
  Blame?: GQLBlameResolvers<ContextType>;
  BlameRange?: GQLBlameRangeResolvers<ContextType>;
  Blob?: GQLBlobResolvers<ContextType>;
  Bot?: GQLBotResolvers<ContextType>;
  BranchProtectionRule?: GQLBranchProtectionRuleResolvers<ContextType>;
  BranchProtectionRuleConflict?: GQLBranchProtectionRuleConflictResolvers<ContextType>;
  BranchProtectionRuleConflictConnection?: GQLBranchProtectionRuleConflictConnectionResolvers<ContextType>;
  BranchProtectionRuleConflictEdge?: GQLBranchProtectionRuleConflictEdgeResolvers<ContextType>;
  BranchProtectionRuleConnection?: GQLBranchProtectionRuleConnectionResolvers<ContextType>;
  BranchProtectionRuleEdge?: GQLBranchProtectionRuleEdgeResolvers<ContextType>;
  CancelEnterpriseAdminInvitationPayload?: GQLCancelEnterpriseAdminInvitationPayloadResolvers<ContextType>;
  ChangeUserStatusPayload?: GQLChangeUserStatusPayloadResolvers<ContextType>;
  CheckAnnotation?: GQLCheckAnnotationResolvers<ContextType>;
  CheckAnnotationConnection?: GQLCheckAnnotationConnectionResolvers<ContextType>;
  CheckAnnotationEdge?: GQLCheckAnnotationEdgeResolvers<ContextType>;
  CheckAnnotationPosition?: GQLCheckAnnotationPositionResolvers<ContextType>;
  CheckAnnotationSpan?: GQLCheckAnnotationSpanResolvers<ContextType>;
  CheckRun?: GQLCheckRunResolvers<ContextType>;
  CheckRunConnection?: GQLCheckRunConnectionResolvers<ContextType>;
  CheckRunEdge?: GQLCheckRunEdgeResolvers<ContextType>;
  CheckSuite?: GQLCheckSuiteResolvers<ContextType>;
  CheckSuiteConnection?: GQLCheckSuiteConnectionResolvers<ContextType>;
  CheckSuiteEdge?: GQLCheckSuiteEdgeResolvers<ContextType>;
  ClearLabelsFromLabelablePayload?: GQLClearLabelsFromLabelablePayloadResolvers<ContextType>;
  CloneProjectPayload?: GQLCloneProjectPayloadResolvers<ContextType>;
  CloneTemplateRepositoryPayload?: GQLCloneTemplateRepositoryPayloadResolvers<ContextType>;
  Closable?: GQLClosableResolvers;
  CloseIssuePayload?: GQLCloseIssuePayloadResolvers<ContextType>;
  ClosePullRequestPayload?: GQLClosePullRequestPayloadResolvers<ContextType>;
  ClosedEvent?: GQLClosedEventResolvers<ContextType>;
  Closer?: GQLCloserResolvers;
  CodeOfConduct?: GQLCodeOfConductResolvers<ContextType>;
  Comment?: GQLCommentResolvers;
  CommentDeletedEvent?: GQLCommentDeletedEventResolvers<ContextType>;
  Commit?: GQLCommitResolvers<ContextType>;
  CommitComment?: GQLCommitCommentResolvers<ContextType>;
  CommitCommentConnection?: GQLCommitCommentConnectionResolvers<ContextType>;
  CommitCommentEdge?: GQLCommitCommentEdgeResolvers<ContextType>;
  CommitCommentThread?: GQLCommitCommentThreadResolvers<ContextType>;
  CommitConnection?: GQLCommitConnectionResolvers<ContextType>;
  CommitContributionsByRepository?: GQLCommitContributionsByRepositoryResolvers<ContextType>;
  CommitEdge?: GQLCommitEdgeResolvers<ContextType>;
  CommitHistoryConnection?: GQLCommitHistoryConnectionResolvers<ContextType>;
  ConnectedEvent?: GQLConnectedEventResolvers<ContextType>;
  ContentAttachment?: GQLContentAttachmentResolvers<ContextType>;
  ContentReference?: GQLContentReferenceResolvers<ContextType>;
  Contribution?: GQLContributionResolvers;
  ContributionCalendar?: GQLContributionCalendarResolvers<ContextType>;
  ContributionCalendarDay?: GQLContributionCalendarDayResolvers<ContextType>;
  ContributionCalendarMonth?: GQLContributionCalendarMonthResolvers<ContextType>;
  ContributionCalendarWeek?: GQLContributionCalendarWeekResolvers<ContextType>;
  ContributionsCollection?: GQLContributionsCollectionResolvers<ContextType>;
  ConvertProjectCardNoteToIssuePayload?: GQLConvertProjectCardNoteToIssuePayloadResolvers<ContextType>;
  ConvertToDraftEvent?: GQLConvertToDraftEventResolvers<ContextType>;
  ConvertedNoteToIssueEvent?: GQLConvertedNoteToIssueEventResolvers<ContextType>;
  CreateBranchProtectionRulePayload?: GQLCreateBranchProtectionRulePayloadResolvers<ContextType>;
  CreateCheckRunPayload?: GQLCreateCheckRunPayloadResolvers<ContextType>;
  CreateCheckSuitePayload?: GQLCreateCheckSuitePayloadResolvers<ContextType>;
  CreateContentAttachmentPayload?: GQLCreateContentAttachmentPayloadResolvers<ContextType>;
  CreateDeploymentPayload?: GQLCreateDeploymentPayloadResolvers<ContextType>;
  CreateDeploymentStatusPayload?: GQLCreateDeploymentStatusPayloadResolvers<ContextType>;
  CreateEnterpriseOrganizationPayload?: GQLCreateEnterpriseOrganizationPayloadResolvers<ContextType>;
  CreateIpAllowListEntryPayload?: GQLCreateIpAllowListEntryPayloadResolvers<ContextType>;
  CreateIssuePayload?: GQLCreateIssuePayloadResolvers<ContextType>;
  CreateLabelPayload?: GQLCreateLabelPayloadResolvers<ContextType>;
  CreateProjectPayload?: GQLCreateProjectPayloadResolvers<ContextType>;
  CreatePullRequestPayload?: GQLCreatePullRequestPayloadResolvers<ContextType>;
  CreateRefPayload?: GQLCreateRefPayloadResolvers<ContextType>;
  CreateRepositoryPayload?: GQLCreateRepositoryPayloadResolvers<ContextType>;
  CreateTeamDiscussionCommentPayload?: GQLCreateTeamDiscussionCommentPayloadResolvers<ContextType>;
  CreateTeamDiscussionPayload?: GQLCreateTeamDiscussionPayloadResolvers<ContextType>;
  CreatedCommitContribution?: GQLCreatedCommitContributionResolvers<ContextType>;
  CreatedCommitContributionConnection?: GQLCreatedCommitContributionConnectionResolvers<ContextType>;
  CreatedCommitContributionEdge?: GQLCreatedCommitContributionEdgeResolvers<ContextType>;
  CreatedIssueContribution?: GQLCreatedIssueContributionResolvers<ContextType>;
  CreatedIssueContributionConnection?: GQLCreatedIssueContributionConnectionResolvers<ContextType>;
  CreatedIssueContributionEdge?: GQLCreatedIssueContributionEdgeResolvers<ContextType>;
  CreatedIssueOrRestrictedContribution?: GQLCreatedIssueOrRestrictedContributionResolvers;
  CreatedPullRequestContribution?: GQLCreatedPullRequestContributionResolvers<ContextType>;
  CreatedPullRequestContributionConnection?: GQLCreatedPullRequestContributionConnectionResolvers<ContextType>;
  CreatedPullRequestContributionEdge?: GQLCreatedPullRequestContributionEdgeResolvers<ContextType>;
  CreatedPullRequestOrRestrictedContribution?: GQLCreatedPullRequestOrRestrictedContributionResolvers;
  CreatedPullRequestReviewContribution?: GQLCreatedPullRequestReviewContributionResolvers<ContextType>;
  CreatedPullRequestReviewContributionConnection?: GQLCreatedPullRequestReviewContributionConnectionResolvers<ContextType>;
  CreatedPullRequestReviewContributionEdge?: GQLCreatedPullRequestReviewContributionEdgeResolvers<ContextType>;
  CreatedRepositoryContribution?: GQLCreatedRepositoryContributionResolvers<ContextType>;
  CreatedRepositoryContributionConnection?: GQLCreatedRepositoryContributionConnectionResolvers<ContextType>;
  CreatedRepositoryContributionEdge?: GQLCreatedRepositoryContributionEdgeResolvers<ContextType>;
  CreatedRepositoryOrRestrictedContribution?: GQLCreatedRepositoryOrRestrictedContributionResolvers;
  CrossReferencedEvent?: GQLCrossReferencedEventResolvers<ContextType>;
  Date?: GraphQLScalarType;
  DateTime?: GraphQLScalarType;
  DeclineTopicSuggestionPayload?: GQLDeclineTopicSuggestionPayloadResolvers<ContextType>;
  Deletable?: GQLDeletableResolvers;
  DeleteBranchProtectionRulePayload?: GQLDeleteBranchProtectionRulePayloadResolvers<ContextType>;
  DeleteDeploymentPayload?: GQLDeleteDeploymentPayloadResolvers<ContextType>;
  DeleteIpAllowListEntryPayload?: GQLDeleteIpAllowListEntryPayloadResolvers<ContextType>;
  DeleteIssueCommentPayload?: GQLDeleteIssueCommentPayloadResolvers<ContextType>;
  DeleteIssuePayload?: GQLDeleteIssuePayloadResolvers<ContextType>;
  DeleteLabelPayload?: GQLDeleteLabelPayloadResolvers<ContextType>;
  DeletePackageVersionPayload?: GQLDeletePackageVersionPayloadResolvers<ContextType>;
  DeleteProjectCardPayload?: GQLDeleteProjectCardPayloadResolvers<ContextType>;
  DeleteProjectColumnPayload?: GQLDeleteProjectColumnPayloadResolvers<ContextType>;
  DeleteProjectPayload?: GQLDeleteProjectPayloadResolvers<ContextType>;
  DeletePullRequestReviewCommentPayload?: GQLDeletePullRequestReviewCommentPayloadResolvers<ContextType>;
  DeletePullRequestReviewPayload?: GQLDeletePullRequestReviewPayloadResolvers<ContextType>;
  DeleteRefPayload?: GQLDeleteRefPayloadResolvers<ContextType>;
  DeleteTeamDiscussionCommentPayload?: GQLDeleteTeamDiscussionCommentPayloadResolvers<ContextType>;
  DeleteTeamDiscussionPayload?: GQLDeleteTeamDiscussionPayloadResolvers<ContextType>;
  DemilestonedEvent?: GQLDemilestonedEventResolvers<ContextType>;
  DependencyGraphDependency?: GQLDependencyGraphDependencyResolvers<ContextType>;
  DependencyGraphDependencyConnection?: GQLDependencyGraphDependencyConnectionResolvers<ContextType>;
  DependencyGraphDependencyEdge?: GQLDependencyGraphDependencyEdgeResolvers<ContextType>;
  DependencyGraphManifest?: GQLDependencyGraphManifestResolvers<ContextType>;
  DependencyGraphManifestConnection?: GQLDependencyGraphManifestConnectionResolvers<ContextType>;
  DependencyGraphManifestEdge?: GQLDependencyGraphManifestEdgeResolvers<ContextType>;
  DeployKey?: GQLDeployKeyResolvers<ContextType>;
  DeployKeyConnection?: GQLDeployKeyConnectionResolvers<ContextType>;
  DeployKeyEdge?: GQLDeployKeyEdgeResolvers<ContextType>;
  DeployedEvent?: GQLDeployedEventResolvers<ContextType>;
  Deployment?: GQLDeploymentResolvers<ContextType>;
  DeploymentConnection?: GQLDeploymentConnectionResolvers<ContextType>;
  DeploymentEdge?: GQLDeploymentEdgeResolvers<ContextType>;
  DeploymentEnvironmentChangedEvent?: GQLDeploymentEnvironmentChangedEventResolvers<ContextType>;
  DeploymentStatus?: GQLDeploymentStatusResolvers<ContextType>;
  DeploymentStatusConnection?: GQLDeploymentStatusConnectionResolvers<ContextType>;
  DeploymentStatusEdge?: GQLDeploymentStatusEdgeResolvers<ContextType>;
  DisconnectedEvent?: GQLDisconnectedEventResolvers<ContextType>;
  DismissPullRequestReviewPayload?: GQLDismissPullRequestReviewPayloadResolvers<ContextType>;
  Enterprise?: GQLEnterpriseResolvers<ContextType>;
  EnterpriseAdministratorConnection?: GQLEnterpriseAdministratorConnectionResolvers<ContextType>;
  EnterpriseAdministratorEdge?: GQLEnterpriseAdministratorEdgeResolvers<ContextType>;
  EnterpriseAdministratorInvitation?: GQLEnterpriseAdministratorInvitationResolvers<ContextType>;
  EnterpriseAdministratorInvitationConnection?: GQLEnterpriseAdministratorInvitationConnectionResolvers<ContextType>;
  EnterpriseAdministratorInvitationEdge?: GQLEnterpriseAdministratorInvitationEdgeResolvers<ContextType>;
  EnterpriseAuditEntryData?: GQLEnterpriseAuditEntryDataResolvers;
  EnterpriseBillingInfo?: GQLEnterpriseBillingInfoResolvers<ContextType>;
  EnterpriseIdentityProvider?: GQLEnterpriseIdentityProviderResolvers<ContextType>;
  EnterpriseMember?: GQLEnterpriseMemberResolvers;
  EnterpriseMemberConnection?: GQLEnterpriseMemberConnectionResolvers<ContextType>;
  EnterpriseMemberEdge?: GQLEnterpriseMemberEdgeResolvers<ContextType>;
  EnterpriseOrganizationMembershipConnection?: GQLEnterpriseOrganizationMembershipConnectionResolvers<ContextType>;
  EnterpriseOrganizationMembershipEdge?: GQLEnterpriseOrganizationMembershipEdgeResolvers<ContextType>;
  EnterpriseOutsideCollaboratorConnection?: GQLEnterpriseOutsideCollaboratorConnectionResolvers<ContextType>;
  EnterpriseOutsideCollaboratorEdge?: GQLEnterpriseOutsideCollaboratorEdgeResolvers<ContextType>;
  EnterpriseOwnerInfo?: GQLEnterpriseOwnerInfoResolvers<ContextType>;
  EnterprisePendingCollaboratorConnection?: GQLEnterprisePendingCollaboratorConnectionResolvers<ContextType>;
  EnterprisePendingCollaboratorEdge?: GQLEnterprisePendingCollaboratorEdgeResolvers<ContextType>;
  EnterprisePendingMemberInvitationConnection?: GQLEnterprisePendingMemberInvitationConnectionResolvers<ContextType>;
  EnterprisePendingMemberInvitationEdge?: GQLEnterprisePendingMemberInvitationEdgeResolvers<ContextType>;
  EnterpriseRepositoryInfo?: GQLEnterpriseRepositoryInfoResolvers<ContextType>;
  EnterpriseRepositoryInfoConnection?: GQLEnterpriseRepositoryInfoConnectionResolvers<ContextType>;
  EnterpriseRepositoryInfoEdge?: GQLEnterpriseRepositoryInfoEdgeResolvers<ContextType>;
  EnterpriseServerInstallation?: GQLEnterpriseServerInstallationResolvers<ContextType>;
  EnterpriseServerInstallationConnection?: GQLEnterpriseServerInstallationConnectionResolvers<ContextType>;
  EnterpriseServerInstallationEdge?: GQLEnterpriseServerInstallationEdgeResolvers<ContextType>;
  EnterpriseServerUserAccount?: GQLEnterpriseServerUserAccountResolvers<ContextType>;
  EnterpriseServerUserAccountConnection?: GQLEnterpriseServerUserAccountConnectionResolvers<ContextType>;
  EnterpriseServerUserAccountEdge?: GQLEnterpriseServerUserAccountEdgeResolvers<ContextType>;
  EnterpriseServerUserAccountEmail?: GQLEnterpriseServerUserAccountEmailResolvers<ContextType>;
  EnterpriseServerUserAccountEmailConnection?: GQLEnterpriseServerUserAccountEmailConnectionResolvers<ContextType>;
  EnterpriseServerUserAccountEmailEdge?: GQLEnterpriseServerUserAccountEmailEdgeResolvers<ContextType>;
  EnterpriseServerUserAccountsUpload?: GQLEnterpriseServerUserAccountsUploadResolvers<ContextType>;
  EnterpriseServerUserAccountsUploadConnection?: GQLEnterpriseServerUserAccountsUploadConnectionResolvers<ContextType>;
  EnterpriseServerUserAccountsUploadEdge?: GQLEnterpriseServerUserAccountsUploadEdgeResolvers<ContextType>;
  EnterpriseUserAccount?: GQLEnterpriseUserAccountResolvers<ContextType>;
  EnterpriseUserAccountConnection?: GQLEnterpriseUserAccountConnectionResolvers<ContextType>;
  EnterpriseUserAccountEdge?: GQLEnterpriseUserAccountEdgeResolvers<ContextType>;
  ExternalIdentity?: GQLExternalIdentityResolvers<ContextType>;
  ExternalIdentityConnection?: GQLExternalIdentityConnectionResolvers<ContextType>;
  ExternalIdentityEdge?: GQLExternalIdentityEdgeResolvers<ContextType>;
  ExternalIdentitySamlAttributes?: GQLExternalIdentitySamlAttributesResolvers<ContextType>;
  ExternalIdentityScimAttributes?: GQLExternalIdentityScimAttributesResolvers<ContextType>;
  FollowUserPayload?: GQLFollowUserPayloadResolvers<ContextType>;
  FollowerConnection?: GQLFollowerConnectionResolvers<ContextType>;
  FollowingConnection?: GQLFollowingConnectionResolvers<ContextType>;
  FundingLink?: GQLFundingLinkResolvers<ContextType>;
  GenericHovercardContext?: GQLGenericHovercardContextResolvers<ContextType>;
  Gist?: GQLGistResolvers<ContextType>;
  GistComment?: GQLGistCommentResolvers<ContextType>;
  GistCommentConnection?: GQLGistCommentConnectionResolvers<ContextType>;
  GistCommentEdge?: GQLGistCommentEdgeResolvers<ContextType>;
  GistConnection?: GQLGistConnectionResolvers<ContextType>;
  GistEdge?: GQLGistEdgeResolvers<ContextType>;
  GistFile?: GQLGistFileResolvers<ContextType>;
  GitActor?: GQLGitActorResolvers<ContextType>;
  GitHubMetadata?: GQLGitHubMetadataResolvers<ContextType>;
  GitObject?: GQLGitObjectResolvers;
  GitObjectID?: GraphQLScalarType;
  GitRefname?: GraphQLScalarType;
  GitSSHRemote?: GraphQLScalarType;
  GitSignature?: GQLGitSignatureResolvers;
  GitTimestamp?: GraphQLScalarType;
  GpgSignature?: GQLGpgSignatureResolvers<ContextType>;
  HTML?: GraphQLScalarType;
  HeadRefDeletedEvent?: GQLHeadRefDeletedEventResolvers<ContextType>;
  HeadRefForcePushedEvent?: GQLHeadRefForcePushedEventResolvers<ContextType>;
  HeadRefRestoredEvent?: GQLHeadRefRestoredEventResolvers<ContextType>;
  Hovercard?: GQLHovercardResolvers<ContextType>;
  HovercardContext?: GQLHovercardContextResolvers;
  ImportProjectPayload?: GQLImportProjectPayloadResolvers<ContextType>;
  InviteEnterpriseAdminPayload?: GQLInviteEnterpriseAdminPayloadResolvers<ContextType>;
  IpAllowListEntry?: GQLIpAllowListEntryResolvers<ContextType>;
  IpAllowListEntryConnection?: GQLIpAllowListEntryConnectionResolvers<ContextType>;
  IpAllowListEntryEdge?: GQLIpAllowListEntryEdgeResolvers<ContextType>;
  IpAllowListOwner?: GQLIpAllowListOwnerResolvers;
  Issue?: GQLIssueResolvers<ContextType>;
  IssueComment?: GQLIssueCommentResolvers<ContextType>;
  IssueCommentConnection?: GQLIssueCommentConnectionResolvers<ContextType>;
  IssueCommentEdge?: GQLIssueCommentEdgeResolvers<ContextType>;
  IssueConnection?: GQLIssueConnectionResolvers<ContextType>;
  IssueContributionsByRepository?: GQLIssueContributionsByRepositoryResolvers<ContextType>;
  IssueEdge?: GQLIssueEdgeResolvers<ContextType>;
  IssueOrPullRequest?: GQLIssueOrPullRequestResolvers;
  IssueTimelineConnection?: GQLIssueTimelineConnectionResolvers<ContextType>;
  IssueTimelineItem?: GQLIssueTimelineItemResolvers;
  IssueTimelineItemEdge?: GQLIssueTimelineItemEdgeResolvers<ContextType>;
  IssueTimelineItems?: GQLIssueTimelineItemsResolvers;
  IssueTimelineItemsConnection?: GQLIssueTimelineItemsConnectionResolvers<ContextType>;
  IssueTimelineItemsEdge?: GQLIssueTimelineItemsEdgeResolvers<ContextType>;
  JoinedGitHubContribution?: GQLJoinedGitHubContributionResolvers<ContextType>;
  Label?: GQLLabelResolvers<ContextType>;
  LabelConnection?: GQLLabelConnectionResolvers<ContextType>;
  LabelEdge?: GQLLabelEdgeResolvers<ContextType>;
  Labelable?: GQLLabelableResolvers;
  LabeledEvent?: GQLLabeledEventResolvers<ContextType>;
  Language?: GQLLanguageResolvers<ContextType>;
  LanguageConnection?: GQLLanguageConnectionResolvers<ContextType>;
  LanguageEdge?: GQLLanguageEdgeResolvers<ContextType>;
  License?: GQLLicenseResolvers<ContextType>;
  LicenseRule?: GQLLicenseRuleResolvers<ContextType>;
  LinkRepositoryToProjectPayload?: GQLLinkRepositoryToProjectPayloadResolvers<ContextType>;
  LockLockablePayload?: GQLLockLockablePayloadResolvers<ContextType>;
  Lockable?: GQLLockableResolvers;
  LockedEvent?: GQLLockedEventResolvers<ContextType>;
  Mannequin?: GQLMannequinResolvers<ContextType>;
  MarkPullRequestReadyForReviewPayload?: GQLMarkPullRequestReadyForReviewPayloadResolvers<ContextType>;
  MarkedAsDuplicateEvent?: GQLMarkedAsDuplicateEventResolvers<ContextType>;
  MarketplaceCategory?: GQLMarketplaceCategoryResolvers<ContextType>;
  MarketplaceListing?: GQLMarketplaceListingResolvers<ContextType>;
  MarketplaceListingConnection?: GQLMarketplaceListingConnectionResolvers<ContextType>;
  MarketplaceListingEdge?: GQLMarketplaceListingEdgeResolvers<ContextType>;
  MemberStatusable?: GQLMemberStatusableResolvers;
  MembersCanDeleteReposClearAuditEntry?: GQLMembersCanDeleteReposClearAuditEntryResolvers<ContextType>;
  MembersCanDeleteReposDisableAuditEntry?: GQLMembersCanDeleteReposDisableAuditEntryResolvers<ContextType>;
  MembersCanDeleteReposEnableAuditEntry?: GQLMembersCanDeleteReposEnableAuditEntryResolvers<ContextType>;
  MentionedEvent?: GQLMentionedEventResolvers<ContextType>;
  MergeBranchPayload?: GQLMergeBranchPayloadResolvers<ContextType>;
  MergePullRequestPayload?: GQLMergePullRequestPayloadResolvers<ContextType>;
  MergedEvent?: GQLMergedEventResolvers<ContextType>;
  Milestone?: GQLMilestoneResolvers<ContextType>;
  MilestoneConnection?: GQLMilestoneConnectionResolvers<ContextType>;
  MilestoneEdge?: GQLMilestoneEdgeResolvers<ContextType>;
  MilestoneItem?: GQLMilestoneItemResolvers;
  MilestonedEvent?: GQLMilestonedEventResolvers<ContextType>;
  Minimizable?: GQLMinimizableResolvers;
  MinimizeCommentPayload?: GQLMinimizeCommentPayloadResolvers<ContextType>;
  MoveProjectCardPayload?: GQLMoveProjectCardPayloadResolvers<ContextType>;
  MoveProjectColumnPayload?: GQLMoveProjectColumnPayloadResolvers<ContextType>;
  MovedColumnsInProjectEvent?: GQLMovedColumnsInProjectEventResolvers<ContextType>;
  Mutation?: GQLMutationResolvers<ContextType>;
  Node?: GQLNodeResolvers;
  OauthApplicationAuditEntryData?: GQLOauthApplicationAuditEntryDataResolvers;
  OauthApplicationCreateAuditEntry?: GQLOauthApplicationCreateAuditEntryResolvers<ContextType>;
  OrgAddBillingManagerAuditEntry?: GQLOrgAddBillingManagerAuditEntryResolvers<ContextType>;
  OrgAddMemberAuditEntry?: GQLOrgAddMemberAuditEntryResolvers<ContextType>;
  OrgBlockUserAuditEntry?: GQLOrgBlockUserAuditEntryResolvers<ContextType>;
  OrgConfigDisableCollaboratorsOnlyAuditEntry?: GQLOrgConfigDisableCollaboratorsOnlyAuditEntryResolvers<ContextType>;
  OrgConfigEnableCollaboratorsOnlyAuditEntry?: GQLOrgConfigEnableCollaboratorsOnlyAuditEntryResolvers<ContextType>;
  OrgCreateAuditEntry?: GQLOrgCreateAuditEntryResolvers<ContextType>;
  OrgDisableOauthAppRestrictionsAuditEntry?: GQLOrgDisableOauthAppRestrictionsAuditEntryResolvers<ContextType>;
  OrgDisableSamlAuditEntry?: GQLOrgDisableSamlAuditEntryResolvers<ContextType>;
  OrgDisableTwoFactorRequirementAuditEntry?: GQLOrgDisableTwoFactorRequirementAuditEntryResolvers<ContextType>;
  OrgEnableOauthAppRestrictionsAuditEntry?: GQLOrgEnableOauthAppRestrictionsAuditEntryResolvers<ContextType>;
  OrgEnableSamlAuditEntry?: GQLOrgEnableSamlAuditEntryResolvers<ContextType>;
  OrgEnableTwoFactorRequirementAuditEntry?: GQLOrgEnableTwoFactorRequirementAuditEntryResolvers<ContextType>;
  OrgInviteMemberAuditEntry?: GQLOrgInviteMemberAuditEntryResolvers<ContextType>;
  OrgInviteToBusinessAuditEntry?: GQLOrgInviteToBusinessAuditEntryResolvers<ContextType>;
  OrgOauthAppAccessApprovedAuditEntry?: GQLOrgOauthAppAccessApprovedAuditEntryResolvers<ContextType>;
  OrgOauthAppAccessDeniedAuditEntry?: GQLOrgOauthAppAccessDeniedAuditEntryResolvers<ContextType>;
  OrgOauthAppAccessRequestedAuditEntry?: GQLOrgOauthAppAccessRequestedAuditEntryResolvers<ContextType>;
  OrgRemoveBillingManagerAuditEntry?: GQLOrgRemoveBillingManagerAuditEntryResolvers<ContextType>;
  OrgRemoveMemberAuditEntry?: GQLOrgRemoveMemberAuditEntryResolvers<ContextType>;
  OrgRemoveOutsideCollaboratorAuditEntry?: GQLOrgRemoveOutsideCollaboratorAuditEntryResolvers<ContextType>;
  OrgRestoreMemberAuditEntry?: GQLOrgRestoreMemberAuditEntryResolvers<ContextType>;
  OrgRestoreMemberAuditEntryMembership?: GQLOrgRestoreMemberAuditEntryMembershipResolvers;
  OrgRestoreMemberMembershipOrganizationAuditEntryData?: GQLOrgRestoreMemberMembershipOrganizationAuditEntryDataResolvers<ContextType>;
  OrgRestoreMemberMembershipRepositoryAuditEntryData?: GQLOrgRestoreMemberMembershipRepositoryAuditEntryDataResolvers<ContextType>;
  OrgRestoreMemberMembershipTeamAuditEntryData?: GQLOrgRestoreMemberMembershipTeamAuditEntryDataResolvers<ContextType>;
  OrgUnblockUserAuditEntry?: GQLOrgUnblockUserAuditEntryResolvers<ContextType>;
  OrgUpdateDefaultRepositoryPermissionAuditEntry?: GQLOrgUpdateDefaultRepositoryPermissionAuditEntryResolvers<ContextType>;
  OrgUpdateMemberAuditEntry?: GQLOrgUpdateMemberAuditEntryResolvers<ContextType>;
  OrgUpdateMemberRepositoryCreationPermissionAuditEntry?: GQLOrgUpdateMemberRepositoryCreationPermissionAuditEntryResolvers<ContextType>;
  OrgUpdateMemberRepositoryInvitationPermissionAuditEntry?: GQLOrgUpdateMemberRepositoryInvitationPermissionAuditEntryResolvers<ContextType>;
  Organization?: GQLOrganizationResolvers<ContextType>;
  OrganizationAuditEntry?: GQLOrganizationAuditEntryResolvers;
  OrganizationAuditEntryConnection?: GQLOrganizationAuditEntryConnectionResolvers<ContextType>;
  OrganizationAuditEntryData?: GQLOrganizationAuditEntryDataResolvers;
  OrganizationAuditEntryEdge?: GQLOrganizationAuditEntryEdgeResolvers<ContextType>;
  OrganizationConnection?: GQLOrganizationConnectionResolvers<ContextType>;
  OrganizationEdge?: GQLOrganizationEdgeResolvers<ContextType>;
  OrganizationIdentityProvider?: GQLOrganizationIdentityProviderResolvers<ContextType>;
  OrganizationInvitation?: GQLOrganizationInvitationResolvers<ContextType>;
  OrganizationInvitationConnection?: GQLOrganizationInvitationConnectionResolvers<ContextType>;
  OrganizationInvitationEdge?: GQLOrganizationInvitationEdgeResolvers<ContextType>;
  OrganizationMemberConnection?: GQLOrganizationMemberConnectionResolvers<ContextType>;
  OrganizationMemberEdge?: GQLOrganizationMemberEdgeResolvers<ContextType>;
  OrganizationTeamsHovercardContext?: GQLOrganizationTeamsHovercardContextResolvers<ContextType>;
  OrganizationsHovercardContext?: GQLOrganizationsHovercardContextResolvers<ContextType>;
  Package?: GQLPackageResolvers<ContextType>;
  PackageConnection?: GQLPackageConnectionResolvers<ContextType>;
  PackageEdge?: GQLPackageEdgeResolvers<ContextType>;
  PackageFile?: GQLPackageFileResolvers<ContextType>;
  PackageFileConnection?: GQLPackageFileConnectionResolvers<ContextType>;
  PackageFileEdge?: GQLPackageFileEdgeResolvers<ContextType>;
  PackageOwner?: GQLPackageOwnerResolvers;
  PackageStatistics?: GQLPackageStatisticsResolvers<ContextType>;
  PackageTag?: GQLPackageTagResolvers<ContextType>;
  PackageVersion?: GQLPackageVersionResolvers<ContextType>;
  PackageVersionConnection?: GQLPackageVersionConnectionResolvers<ContextType>;
  PackageVersionEdge?: GQLPackageVersionEdgeResolvers<ContextType>;
  PackageVersionStatistics?: GQLPackageVersionStatisticsResolvers<ContextType>;
  PageInfo?: GQLPageInfoResolvers<ContextType>;
  PermissionGranter?: GQLPermissionGranterResolvers;
  PermissionSource?: GQLPermissionSourceResolvers<ContextType>;
  PinIssuePayload?: GQLPinIssuePayloadResolvers<ContextType>;
  PinnableItem?: GQLPinnableItemResolvers;
  PinnableItemConnection?: GQLPinnableItemConnectionResolvers<ContextType>;
  PinnableItemEdge?: GQLPinnableItemEdgeResolvers<ContextType>;
  PinnedEvent?: GQLPinnedEventResolvers<ContextType>;
  PinnedIssue?: GQLPinnedIssueResolvers<ContextType>;
  PinnedIssueConnection?: GQLPinnedIssueConnectionResolvers<ContextType>;
  PinnedIssueEdge?: GQLPinnedIssueEdgeResolvers<ContextType>;
  PreciseDateTime?: GraphQLScalarType;
  PrivateRepositoryForkingDisableAuditEntry?: GQLPrivateRepositoryForkingDisableAuditEntryResolvers<ContextType>;
  PrivateRepositoryForkingEnableAuditEntry?: GQLPrivateRepositoryForkingEnableAuditEntryResolvers<ContextType>;
  ProfileItemShowcase?: GQLProfileItemShowcaseResolvers<ContextType>;
  ProfileOwner?: GQLProfileOwnerResolvers;
  Project?: GQLProjectResolvers<ContextType>;
  ProjectCard?: GQLProjectCardResolvers<ContextType>;
  ProjectCardConnection?: GQLProjectCardConnectionResolvers<ContextType>;
  ProjectCardEdge?: GQLProjectCardEdgeResolvers<ContextType>;
  ProjectCardItem?: GQLProjectCardItemResolvers;
  ProjectColumn?: GQLProjectColumnResolvers<ContextType>;
  ProjectColumnConnection?: GQLProjectColumnConnectionResolvers<ContextType>;
  ProjectColumnEdge?: GQLProjectColumnEdgeResolvers<ContextType>;
  ProjectConnection?: GQLProjectConnectionResolvers<ContextType>;
  ProjectEdge?: GQLProjectEdgeResolvers<ContextType>;
  ProjectOwner?: GQLProjectOwnerResolvers;
  PublicKey?: GQLPublicKeyResolvers<ContextType>;
  PublicKeyConnection?: GQLPublicKeyConnectionResolvers<ContextType>;
  PublicKeyEdge?: GQLPublicKeyEdgeResolvers<ContextType>;
  PullRequest?: GQLPullRequestResolvers<ContextType>;
  PullRequestChangedFile?: GQLPullRequestChangedFileResolvers<ContextType>;
  PullRequestChangedFileConnection?: GQLPullRequestChangedFileConnectionResolvers<ContextType>;
  PullRequestChangedFileEdge?: GQLPullRequestChangedFileEdgeResolvers<ContextType>;
  PullRequestCommit?: GQLPullRequestCommitResolvers<ContextType>;
  PullRequestCommitCommentThread?: GQLPullRequestCommitCommentThreadResolvers<ContextType>;
  PullRequestCommitConnection?: GQLPullRequestCommitConnectionResolvers<ContextType>;
  PullRequestCommitEdge?: GQLPullRequestCommitEdgeResolvers<ContextType>;
  PullRequestConnection?: GQLPullRequestConnectionResolvers<ContextType>;
  PullRequestContributionsByRepository?: GQLPullRequestContributionsByRepositoryResolvers<ContextType>;
  PullRequestEdge?: GQLPullRequestEdgeResolvers<ContextType>;
  PullRequestReview?: GQLPullRequestReviewResolvers<ContextType>;
  PullRequestReviewComment?: GQLPullRequestReviewCommentResolvers<ContextType>;
  PullRequestReviewCommentConnection?: GQLPullRequestReviewCommentConnectionResolvers<ContextType>;
  PullRequestReviewCommentEdge?: GQLPullRequestReviewCommentEdgeResolvers<ContextType>;
  PullRequestReviewConnection?: GQLPullRequestReviewConnectionResolvers<ContextType>;
  PullRequestReviewContributionsByRepository?: GQLPullRequestReviewContributionsByRepositoryResolvers<ContextType>;
  PullRequestReviewEdge?: GQLPullRequestReviewEdgeResolvers<ContextType>;
  PullRequestReviewThread?: GQLPullRequestReviewThreadResolvers<ContextType>;
  PullRequestReviewThreadConnection?: GQLPullRequestReviewThreadConnectionResolvers<ContextType>;
  PullRequestReviewThreadEdge?: GQLPullRequestReviewThreadEdgeResolvers<ContextType>;
  PullRequestRevisionMarker?: GQLPullRequestRevisionMarkerResolvers<ContextType>;
  PullRequestTimelineConnection?: GQLPullRequestTimelineConnectionResolvers<ContextType>;
  PullRequestTimelineItem?: GQLPullRequestTimelineItemResolvers;
  PullRequestTimelineItemEdge?: GQLPullRequestTimelineItemEdgeResolvers<ContextType>;
  PullRequestTimelineItems?: GQLPullRequestTimelineItemsResolvers;
  PullRequestTimelineItemsConnection?: GQLPullRequestTimelineItemsConnectionResolvers<ContextType>;
  PullRequestTimelineItemsEdge?: GQLPullRequestTimelineItemsEdgeResolvers<ContextType>;
  Push?: GQLPushResolvers<ContextType>;
  PushAllowance?: GQLPushAllowanceResolvers<ContextType>;
  PushAllowanceActor?: GQLPushAllowanceActorResolvers;
  PushAllowanceConnection?: GQLPushAllowanceConnectionResolvers<ContextType>;
  PushAllowanceEdge?: GQLPushAllowanceEdgeResolvers<ContextType>;
  Query?: GQLQueryResolvers<ContextType>;
  RateLimit?: GQLRateLimitResolvers<ContextType>;
  Reactable?: GQLReactableResolvers;
  ReactingUserConnection?: GQLReactingUserConnectionResolvers<ContextType>;
  ReactingUserEdge?: GQLReactingUserEdgeResolvers<ContextType>;
  Reaction?: GQLReactionResolvers<ContextType>;
  ReactionConnection?: GQLReactionConnectionResolvers<ContextType>;
  ReactionEdge?: GQLReactionEdgeResolvers<ContextType>;
  ReactionGroup?: GQLReactionGroupResolvers<ContextType>;
  ReadyForReviewEvent?: GQLReadyForReviewEventResolvers<ContextType>;
  Ref?: GQLRefResolvers<ContextType>;
  RefConnection?: GQLRefConnectionResolvers<ContextType>;
  RefEdge?: GQLRefEdgeResolvers<ContextType>;
  ReferencedEvent?: GQLReferencedEventResolvers<ContextType>;
  ReferencedSubject?: GQLReferencedSubjectResolvers;
  RegenerateEnterpriseIdentityProviderRecoveryCodesPayload?: GQLRegenerateEnterpriseIdentityProviderRecoveryCodesPayloadResolvers<ContextType>;
  RegistryPackage?: GQLRegistryPackageResolvers<ContextType>;
  RegistryPackageConnection?: GQLRegistryPackageConnectionResolvers<ContextType>;
  RegistryPackageDependency?: GQLRegistryPackageDependencyResolvers<ContextType>;
  RegistryPackageDependencyConnection?: GQLRegistryPackageDependencyConnectionResolvers<ContextType>;
  RegistryPackageDependencyEdge?: GQLRegistryPackageDependencyEdgeResolvers<ContextType>;
  RegistryPackageEdge?: GQLRegistryPackageEdgeResolvers<ContextType>;
  RegistryPackageFile?: GQLRegistryPackageFileResolvers<ContextType>;
  RegistryPackageFileConnection?: GQLRegistryPackageFileConnectionResolvers<ContextType>;
  RegistryPackageFileEdge?: GQLRegistryPackageFileEdgeResolvers<ContextType>;
  RegistryPackageOwner?: GQLRegistryPackageOwnerResolvers;
  RegistryPackageSearch?: GQLRegistryPackageSearchResolvers;
  RegistryPackageStatistics?: GQLRegistryPackageStatisticsResolvers<ContextType>;
  RegistryPackageTag?: GQLRegistryPackageTagResolvers<ContextType>;
  RegistryPackageTagConnection?: GQLRegistryPackageTagConnectionResolvers<ContextType>;
  RegistryPackageTagEdge?: GQLRegistryPackageTagEdgeResolvers<ContextType>;
  RegistryPackageVersion?: GQLRegistryPackageVersionResolvers<ContextType>;
  RegistryPackageVersionConnection?: GQLRegistryPackageVersionConnectionResolvers<ContextType>;
  RegistryPackageVersionEdge?: GQLRegistryPackageVersionEdgeResolvers<ContextType>;
  RegistryPackageVersionStatistics?: GQLRegistryPackageVersionStatisticsResolvers<ContextType>;
  Release?: GQLReleaseResolvers<ContextType>;
  ReleaseAsset?: GQLReleaseAssetResolvers<ContextType>;
  ReleaseAssetConnection?: GQLReleaseAssetConnectionResolvers<ContextType>;
  ReleaseAssetEdge?: GQLReleaseAssetEdgeResolvers<ContextType>;
  ReleaseConnection?: GQLReleaseConnectionResolvers<ContextType>;
  ReleaseEdge?: GQLReleaseEdgeResolvers<ContextType>;
  RemoveAssigneesFromAssignablePayload?: GQLRemoveAssigneesFromAssignablePayloadResolvers<ContextType>;
  RemoveEnterpriseAdminPayload?: GQLRemoveEnterpriseAdminPayloadResolvers<ContextType>;
  RemoveEnterpriseIdentityProviderPayload?: GQLRemoveEnterpriseIdentityProviderPayloadResolvers<ContextType>;
  RemoveEnterpriseOrganizationPayload?: GQLRemoveEnterpriseOrganizationPayloadResolvers<ContextType>;
  RemoveLabelsFromLabelablePayload?: GQLRemoveLabelsFromLabelablePayloadResolvers<ContextType>;
  RemoveOutsideCollaboratorPayload?: GQLRemoveOutsideCollaboratorPayloadResolvers<ContextType>;
  RemoveReactionPayload?: GQLRemoveReactionPayloadResolvers<ContextType>;
  RemoveStarPayload?: GQLRemoveStarPayloadResolvers<ContextType>;
  RemovedFromProjectEvent?: GQLRemovedFromProjectEventResolvers<ContextType>;
  RenamedTitleEvent?: GQLRenamedTitleEventResolvers<ContextType>;
  RenamedTitleSubject?: GQLRenamedTitleSubjectResolvers;
  ReopenIssuePayload?: GQLReopenIssuePayloadResolvers<ContextType>;
  ReopenPullRequestPayload?: GQLReopenPullRequestPayloadResolvers<ContextType>;
  ReopenedEvent?: GQLReopenedEventResolvers<ContextType>;
  RepoAccessAuditEntry?: GQLRepoAccessAuditEntryResolvers<ContextType>;
  RepoAddMemberAuditEntry?: GQLRepoAddMemberAuditEntryResolvers<ContextType>;
  RepoAddTopicAuditEntry?: GQLRepoAddTopicAuditEntryResolvers<ContextType>;
  RepoArchivedAuditEntry?: GQLRepoArchivedAuditEntryResolvers<ContextType>;
  RepoChangeMergeSettingAuditEntry?: GQLRepoChangeMergeSettingAuditEntryResolvers<ContextType>;
  RepoConfigDisableAnonymousGitAccessAuditEntry?: GQLRepoConfigDisableAnonymousGitAccessAuditEntryResolvers<ContextType>;
  RepoConfigDisableCollaboratorsOnlyAuditEntry?: GQLRepoConfigDisableCollaboratorsOnlyAuditEntryResolvers<ContextType>;
  RepoConfigDisableContributorsOnlyAuditEntry?: GQLRepoConfigDisableContributorsOnlyAuditEntryResolvers<ContextType>;
  RepoConfigDisableSockpuppetDisallowedAuditEntry?: GQLRepoConfigDisableSockpuppetDisallowedAuditEntryResolvers<ContextType>;
  RepoConfigEnableAnonymousGitAccessAuditEntry?: GQLRepoConfigEnableAnonymousGitAccessAuditEntryResolvers<ContextType>;
  RepoConfigEnableCollaboratorsOnlyAuditEntry?: GQLRepoConfigEnableCollaboratorsOnlyAuditEntryResolvers<ContextType>;
  RepoConfigEnableContributorsOnlyAuditEntry?: GQLRepoConfigEnableContributorsOnlyAuditEntryResolvers<ContextType>;
  RepoConfigEnableSockpuppetDisallowedAuditEntry?: GQLRepoConfigEnableSockpuppetDisallowedAuditEntryResolvers<ContextType>;
  RepoConfigLockAnonymousGitAccessAuditEntry?: GQLRepoConfigLockAnonymousGitAccessAuditEntryResolvers<ContextType>;
  RepoConfigUnlockAnonymousGitAccessAuditEntry?: GQLRepoConfigUnlockAnonymousGitAccessAuditEntryResolvers<ContextType>;
  RepoCreateAuditEntry?: GQLRepoCreateAuditEntryResolvers<ContextType>;
  RepoDestroyAuditEntry?: GQLRepoDestroyAuditEntryResolvers<ContextType>;
  RepoRemoveMemberAuditEntry?: GQLRepoRemoveMemberAuditEntryResolvers<ContextType>;
  RepoRemoveTopicAuditEntry?: GQLRepoRemoveTopicAuditEntryResolvers<ContextType>;
  Repository?: GQLRepositoryResolvers<ContextType>;
  RepositoryAuditEntryData?: GQLRepositoryAuditEntryDataResolvers;
  RepositoryCollaboratorConnection?: GQLRepositoryCollaboratorConnectionResolvers<ContextType>;
  RepositoryCollaboratorEdge?: GQLRepositoryCollaboratorEdgeResolvers<ContextType>;
  RepositoryConnection?: GQLRepositoryConnectionResolvers<ContextType>;
  RepositoryEdge?: GQLRepositoryEdgeResolvers<ContextType>;
  RepositoryInfo?: GQLRepositoryInfoResolvers;
  RepositoryInvitation?: GQLRepositoryInvitationResolvers<ContextType>;
  RepositoryInvitationConnection?: GQLRepositoryInvitationConnectionResolvers<ContextType>;
  RepositoryInvitationEdge?: GQLRepositoryInvitationEdgeResolvers<ContextType>;
  RepositoryNode?: GQLRepositoryNodeResolvers;
  RepositoryOwner?: GQLRepositoryOwnerResolvers;
  RepositoryTopic?: GQLRepositoryTopicResolvers<ContextType>;
  RepositoryTopicConnection?: GQLRepositoryTopicConnectionResolvers<ContextType>;
  RepositoryTopicEdge?: GQLRepositoryTopicEdgeResolvers<ContextType>;
  RepositoryVisibilityChangeDisableAuditEntry?: GQLRepositoryVisibilityChangeDisableAuditEntryResolvers<ContextType>;
  RepositoryVisibilityChangeEnableAuditEntry?: GQLRepositoryVisibilityChangeEnableAuditEntryResolvers<ContextType>;
  RepositoryVulnerabilityAlert?: GQLRepositoryVulnerabilityAlertResolvers<ContextType>;
  RepositoryVulnerabilityAlertConnection?: GQLRepositoryVulnerabilityAlertConnectionResolvers<ContextType>;
  RepositoryVulnerabilityAlertEdge?: GQLRepositoryVulnerabilityAlertEdgeResolvers<ContextType>;
  RequestReviewsPayload?: GQLRequestReviewsPayloadResolvers<ContextType>;
  RequestedReviewer?: GQLRequestedReviewerResolvers;
  RerequestCheckSuitePayload?: GQLRerequestCheckSuitePayloadResolvers<ContextType>;
  ResolveReviewThreadPayload?: GQLResolveReviewThreadPayloadResolvers<ContextType>;
  RestrictedContribution?: GQLRestrictedContributionResolvers<ContextType>;
  ReviewDismissalAllowance?: GQLReviewDismissalAllowanceResolvers<ContextType>;
  ReviewDismissalAllowanceActor?: GQLReviewDismissalAllowanceActorResolvers;
  ReviewDismissalAllowanceConnection?: GQLReviewDismissalAllowanceConnectionResolvers<ContextType>;
  ReviewDismissalAllowanceEdge?: GQLReviewDismissalAllowanceEdgeResolvers<ContextType>;
  ReviewDismissedEvent?: GQLReviewDismissedEventResolvers<ContextType>;
  ReviewRequest?: GQLReviewRequestResolvers<ContextType>;
  ReviewRequestConnection?: GQLReviewRequestConnectionResolvers<ContextType>;
  ReviewRequestEdge?: GQLReviewRequestEdgeResolvers<ContextType>;
  ReviewRequestRemovedEvent?: GQLReviewRequestRemovedEventResolvers<ContextType>;
  ReviewRequestedEvent?: GQLReviewRequestedEventResolvers<ContextType>;
  ReviewStatusHovercardContext?: GQLReviewStatusHovercardContextResolvers<ContextType>;
  SavedReply?: GQLSavedReplyResolvers<ContextType>;
  SavedReplyConnection?: GQLSavedReplyConnectionResolvers<ContextType>;
  SavedReplyEdge?: GQLSavedReplyEdgeResolvers<ContextType>;
  SearchResultItem?: GQLSearchResultItemResolvers;
  SearchResultItemConnection?: GQLSearchResultItemConnectionResolvers<ContextType>;
  SearchResultItemEdge?: GQLSearchResultItemEdgeResolvers<ContextType>;
  SecurityAdvisory?: GQLSecurityAdvisoryResolvers<ContextType>;
  SecurityAdvisoryConnection?: GQLSecurityAdvisoryConnectionResolvers<ContextType>;
  SecurityAdvisoryEdge?: GQLSecurityAdvisoryEdgeResolvers<ContextType>;
  SecurityAdvisoryIdentifier?: GQLSecurityAdvisoryIdentifierResolvers<ContextType>;
  SecurityAdvisoryPackage?: GQLSecurityAdvisoryPackageResolvers<ContextType>;
  SecurityAdvisoryPackageVersion?: GQLSecurityAdvisoryPackageVersionResolvers<ContextType>;
  SecurityAdvisoryReference?: GQLSecurityAdvisoryReferenceResolvers<ContextType>;
  SecurityVulnerability?: GQLSecurityVulnerabilityResolvers<ContextType>;
  SecurityVulnerabilityConnection?: GQLSecurityVulnerabilityConnectionResolvers<ContextType>;
  SecurityVulnerabilityEdge?: GQLSecurityVulnerabilityEdgeResolvers<ContextType>;
  SetEnterpriseIdentityProviderPayload?: GQLSetEnterpriseIdentityProviderPayloadResolvers<ContextType>;
  SmimeSignature?: GQLSmimeSignatureResolvers<ContextType>;
  Sponsor?: GQLSponsorResolvers;
  Sponsorable?: GQLSponsorableResolvers;
  SponsorsListing?: GQLSponsorsListingResolvers<ContextType>;
  SponsorsTier?: GQLSponsorsTierResolvers<ContextType>;
  SponsorsTierAdminInfo?: GQLSponsorsTierAdminInfoResolvers<ContextType>;
  SponsorsTierConnection?: GQLSponsorsTierConnectionResolvers<ContextType>;
  SponsorsTierEdge?: GQLSponsorsTierEdgeResolvers<ContextType>;
  Sponsorship?: GQLSponsorshipResolvers<ContextType>;
  SponsorshipConnection?: GQLSponsorshipConnectionResolvers<ContextType>;
  SponsorshipEdge?: GQLSponsorshipEdgeResolvers<ContextType>;
  StargazerConnection?: GQLStargazerConnectionResolvers<ContextType>;
  StargazerEdge?: GQLStargazerEdgeResolvers<ContextType>;
  Starrable?: GQLStarrableResolvers;
  StarredRepositoryConnection?: GQLStarredRepositoryConnectionResolvers<ContextType>;
  StarredRepositoryEdge?: GQLStarredRepositoryEdgeResolvers<ContextType>;
  Status?: GQLStatusResolvers<ContextType>;
  StatusCheckRollup?: GQLStatusCheckRollupResolvers<ContextType>;
  StatusCheckRollupContext?: GQLStatusCheckRollupContextResolvers;
  StatusCheckRollupContextConnection?: GQLStatusCheckRollupContextConnectionResolvers<ContextType>;
  StatusCheckRollupContextEdge?: GQLStatusCheckRollupContextEdgeResolvers<ContextType>;
  StatusContext?: GQLStatusContextResolvers<ContextType>;
  SubmitPullRequestReviewPayload?: GQLSubmitPullRequestReviewPayloadResolvers<ContextType>;
  Submodule?: GQLSubmoduleResolvers<ContextType>;
  SubmoduleConnection?: GQLSubmoduleConnectionResolvers<ContextType>;
  SubmoduleEdge?: GQLSubmoduleEdgeResolvers<ContextType>;
  Subscribable?: GQLSubscribableResolvers;
  SubscribedEvent?: GQLSubscribedEventResolvers<ContextType>;
  SuggestedReviewer?: GQLSuggestedReviewerResolvers<ContextType>;
  Tag?: GQLTagResolvers<ContextType>;
  Team?: GQLTeamResolvers<ContextType>;
  TeamAddMemberAuditEntry?: GQLTeamAddMemberAuditEntryResolvers<ContextType>;
  TeamAddRepositoryAuditEntry?: GQLTeamAddRepositoryAuditEntryResolvers<ContextType>;
  TeamAuditEntryData?: GQLTeamAuditEntryDataResolvers;
  TeamChangeParentTeamAuditEntry?: GQLTeamChangeParentTeamAuditEntryResolvers<ContextType>;
  TeamConnection?: GQLTeamConnectionResolvers<ContextType>;
  TeamDiscussion?: GQLTeamDiscussionResolvers<ContextType>;
  TeamDiscussionComment?: GQLTeamDiscussionCommentResolvers<ContextType>;
  TeamDiscussionCommentConnection?: GQLTeamDiscussionCommentConnectionResolvers<ContextType>;
  TeamDiscussionCommentEdge?: GQLTeamDiscussionCommentEdgeResolvers<ContextType>;
  TeamDiscussionConnection?: GQLTeamDiscussionConnectionResolvers<ContextType>;
  TeamDiscussionEdge?: GQLTeamDiscussionEdgeResolvers<ContextType>;
  TeamEdge?: GQLTeamEdgeResolvers<ContextType>;
  TeamMemberConnection?: GQLTeamMemberConnectionResolvers<ContextType>;
  TeamMemberEdge?: GQLTeamMemberEdgeResolvers<ContextType>;
  TeamRemoveMemberAuditEntry?: GQLTeamRemoveMemberAuditEntryResolvers<ContextType>;
  TeamRemoveRepositoryAuditEntry?: GQLTeamRemoveRepositoryAuditEntryResolvers<ContextType>;
  TeamRepositoryConnection?: GQLTeamRepositoryConnectionResolvers<ContextType>;
  TeamRepositoryEdge?: GQLTeamRepositoryEdgeResolvers<ContextType>;
  TextMatch?: GQLTextMatchResolvers<ContextType>;
  TextMatchHighlight?: GQLTextMatchHighlightResolvers<ContextType>;
  Topic?: GQLTopicResolvers<ContextType>;
  TopicAuditEntryData?: GQLTopicAuditEntryDataResolvers;
  TopicConnection?: GQLTopicConnectionResolvers<ContextType>;
  TopicEdge?: GQLTopicEdgeResolvers<ContextType>;
  TransferIssuePayload?: GQLTransferIssuePayloadResolvers<ContextType>;
  TransferredEvent?: GQLTransferredEventResolvers<ContextType>;
  Tree?: GQLTreeResolvers<ContextType>;
  TreeEntry?: GQLTreeEntryResolvers<ContextType>;
  URI?: GraphQLScalarType;
  UnarchiveRepositoryPayload?: GQLUnarchiveRepositoryPayloadResolvers<ContextType>;
  UnassignedEvent?: GQLUnassignedEventResolvers<ContextType>;
  UnfollowUserPayload?: GQLUnfollowUserPayloadResolvers<ContextType>;
  UniformResourceLocatable?: GQLUniformResourceLocatableResolvers;
  UnknownSignature?: GQLUnknownSignatureResolvers<ContextType>;
  UnlabeledEvent?: GQLUnlabeledEventResolvers<ContextType>;
  UnlinkRepositoryFromProjectPayload?: GQLUnlinkRepositoryFromProjectPayloadResolvers<ContextType>;
  UnlockLockablePayload?: GQLUnlockLockablePayloadResolvers<ContextType>;
  UnlockedEvent?: GQLUnlockedEventResolvers<ContextType>;
  UnmarkIssueAsDuplicatePayload?: GQLUnmarkIssueAsDuplicatePayloadResolvers<ContextType>;
  UnmarkedAsDuplicateEvent?: GQLUnmarkedAsDuplicateEventResolvers<ContextType>;
  UnminimizeCommentPayload?: GQLUnminimizeCommentPayloadResolvers<ContextType>;
  UnpinIssuePayload?: GQLUnpinIssuePayloadResolvers<ContextType>;
  UnpinnedEvent?: GQLUnpinnedEventResolvers<ContextType>;
  UnresolveReviewThreadPayload?: GQLUnresolveReviewThreadPayloadResolvers<ContextType>;
  UnsubscribedEvent?: GQLUnsubscribedEventResolvers<ContextType>;
  Updatable?: GQLUpdatableResolvers;
  UpdatableComment?: GQLUpdatableCommentResolvers;
  UpdateBranchProtectionRulePayload?: GQLUpdateBranchProtectionRulePayloadResolvers<ContextType>;
  UpdateCheckRunPayload?: GQLUpdateCheckRunPayloadResolvers<ContextType>;
  UpdateCheckSuitePreferencesPayload?: GQLUpdateCheckSuitePreferencesPayloadResolvers<ContextType>;
  UpdateEnterpriseActionExecutionCapabilitySettingPayload?: GQLUpdateEnterpriseActionExecutionCapabilitySettingPayloadResolvers<ContextType>;
  UpdateEnterpriseAdministratorRolePayload?: GQLUpdateEnterpriseAdministratorRolePayloadResolvers<ContextType>;
  UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload?: GQLUpdateEnterpriseAllowPrivateRepositoryForkingSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseDefaultRepositoryPermissionSettingPayload?: GQLUpdateEnterpriseDefaultRepositoryPermissionSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload?: GQLUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayloadResolvers<ContextType>;
  UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload?: GQLUpdateEnterpriseMembersCanCreateRepositoriesSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseMembersCanDeleteIssuesSettingPayload?: GQLUpdateEnterpriseMembersCanDeleteIssuesSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload?: GQLUpdateEnterpriseMembersCanDeleteRepositoriesSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload?: GQLUpdateEnterpriseMembersCanInviteCollaboratorsSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseMembersCanMakePurchasesSettingPayload?: GQLUpdateEnterpriseMembersCanMakePurchasesSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload?: GQLUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload?: GQLUpdateEnterpriseMembersCanViewDependencyInsightsSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseOrganizationProjectsSettingPayload?: GQLUpdateEnterpriseOrganizationProjectsSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseProfilePayload?: GQLUpdateEnterpriseProfilePayloadResolvers<ContextType>;
  UpdateEnterpriseRepositoryProjectsSettingPayload?: GQLUpdateEnterpriseRepositoryProjectsSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseTeamDiscussionsSettingPayload?: GQLUpdateEnterpriseTeamDiscussionsSettingPayloadResolvers<ContextType>;
  UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload?: GQLUpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayloadResolvers<ContextType>;
  UpdateIpAllowListEnabledSettingPayload?: GQLUpdateIpAllowListEnabledSettingPayloadResolvers<ContextType>;
  UpdateIpAllowListEntryPayload?: GQLUpdateIpAllowListEntryPayloadResolvers<ContextType>;
  UpdateIssueCommentPayload?: GQLUpdateIssueCommentPayloadResolvers<ContextType>;
  UpdateIssuePayload?: GQLUpdateIssuePayloadResolvers<ContextType>;
  UpdateLabelPayload?: GQLUpdateLabelPayloadResolvers<ContextType>;
  UpdateProjectCardPayload?: GQLUpdateProjectCardPayloadResolvers<ContextType>;
  UpdateProjectColumnPayload?: GQLUpdateProjectColumnPayloadResolvers<ContextType>;
  UpdateProjectPayload?: GQLUpdateProjectPayloadResolvers<ContextType>;
  UpdatePullRequestPayload?: GQLUpdatePullRequestPayloadResolvers<ContextType>;
  UpdatePullRequestReviewCommentPayload?: GQLUpdatePullRequestReviewCommentPayloadResolvers<ContextType>;
  UpdatePullRequestReviewPayload?: GQLUpdatePullRequestReviewPayloadResolvers<ContextType>;
  UpdateRefPayload?: GQLUpdateRefPayloadResolvers<ContextType>;
  UpdateRefsPayload?: GQLUpdateRefsPayloadResolvers<ContextType>;
  UpdateRepositoryPayload?: GQLUpdateRepositoryPayloadResolvers<ContextType>;
  UpdateSubscriptionPayload?: GQLUpdateSubscriptionPayloadResolvers<ContextType>;
  UpdateTeamDiscussionCommentPayload?: GQLUpdateTeamDiscussionCommentPayloadResolvers<ContextType>;
  UpdateTeamDiscussionPayload?: GQLUpdateTeamDiscussionPayloadResolvers<ContextType>;
  UpdateTeamReviewAssignmentPayload?: GQLUpdateTeamReviewAssignmentPayloadResolvers<ContextType>;
  UpdateTopicsPayload?: GQLUpdateTopicsPayloadResolvers<ContextType>;
  User?: GQLUserResolvers<ContextType>;
  UserBlockedEvent?: GQLUserBlockedEventResolvers<ContextType>;
  UserConnection?: GQLUserConnectionResolvers<ContextType>;
  UserContentEdit?: GQLUserContentEditResolvers<ContextType>;
  UserContentEditConnection?: GQLUserContentEditConnectionResolvers<ContextType>;
  UserContentEditEdge?: GQLUserContentEditEdgeResolvers<ContextType>;
  UserEdge?: GQLUserEdgeResolvers<ContextType>;
  UserStatus?: GQLUserStatusResolvers<ContextType>;
  UserStatusConnection?: GQLUserStatusConnectionResolvers<ContextType>;
  UserStatusEdge?: GQLUserStatusEdgeResolvers<ContextType>;
  ViewerHovercardContext?: GQLViewerHovercardContextResolvers<ContextType>;
  X509Certificate?: GraphQLScalarType;
};


export type GQLDirectiveResolvers<ContextType = any> = {
  possibleTypes?: GQLPossibleTypesDirectiveResolver<any, any, ContextType>;
  preview?: GQLPreviewDirectiveResolver<any, any, ContextType>;
};

